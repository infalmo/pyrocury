[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high-quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.ANA BELL: All right,\neveryone, let's get started.So today is going to\nbe the second lectureon object-oriented programming.So just a quick recap of\nlast time-- on Monday,we saw-- we were\nintroduced to this ideaof object-oriented\nprogramming, and wesaw these things called\nabstract data types.And these abstract data\ntypes we implementedthrough Python classes.And they allowed us to\ncreate our own data typesthat sort of abstracted a\ngeneral object of our choosing,right?So we've used lists\nbefore, for example.But with abstract\ndata types, we wereable to create objects\nthat were of our own types.We saw the coordinate example.And then at the\nend of the class,we saw the fraction example.So today we're going to\ntalk a little bit moreabout object-oriented\nprogramming and classes.We're going to see\na few more examples.And we're going to talk about\na few other nuances of classes,talk about information\nhiding and class variables.And in the second\nhalf of the lecture,we're going to talk about\nthe idea of inheritance.So we're going to use\nobject-oriented programmingto simulate how real life works.So in real life, you\nhave inheritance.And in object-oriented\nprogramming,you can also simulate that.OK, so the first\nfew slides are goingto be a little bit of recap just\nto make sure that everyone'son the same page\nbefore I introducea couple of new concepts\nrelated to classes.", "start": 0.0, "heat": 0.1}, {"text": "So recall that when--\nin the last lecture,we talked about\nwriting code from twodifferent perspectives, right?The first was from someone who\nwanted to implement a class.So implementing the class meant\ndefining your own object type.So you defined the object type\nwhen you defined the class.And then you decided what\ndata attributes you wantedto define in your object.So what data makes\nup the object?What is the object, OK?In addition to data\nattributes, we alsosaw these things called methods.And methods were\nways to tell someonehow to use your data type.So what are ways that someone\ncan interact with the datatype, OK?So that's from the\npoint of view of someonewho wants to write\ntheir own object type.So you're implementing a class.And the other perspective\nwas to write codefrom the point of\nview of someonewho wanted to use a class\nthat was already written, OK?So this involved creating\ninstances of objects.So you're using the object type.Once you created\ninstances of objects,you were able to do\noperations on them.So you were able to see\nwhat methods whoeverimplemented the class added.And then, you can\nuse those methodsin order to do operations\nwith your instances.So just looking at the\ncoordinate example wesaw last time, a little\nbit more in detailabout what that meant--\nso we had a classdefinition of an object\ntype, which included decidingwhat the class name was.And the class name\nbasically toldPython what type of an\nobject this was, OK?In this case, we\ndecided we wantedto name a coordinate-- we wanted\nto create a Coordinate object.And the type of this\nobject was thereforegoing to be a coordinate.We defined the class in the\nsort of general way, OK?So we needed a way to\nbe able to access dataattributes of any instance.", "start": 120.0, "heat": 0.152}, {"text": "So we use this\nself variable, OK?And the self variable\nwe used to referto any instance-- to the data\nattributes of any instancein a general way\nwithout actuallyhaving a particular\ninstance in mind, OK?So whenever we access\ndata attributes,we would say something like self\ndot to access a data attribute.You'd access the attribute\ndirectly with self.x.Or if you wanted\nto access a method,you would say self, dot,\nand then the method name--for example, distance.And really, the bottom line\nof the class definitionis that your class defines\nall of the data-- so dataattributes-- and\nall of the methodsthat are going to be common\nacross all of the instances.So any instance that you create\nof a particular object type,that instance is going to have\nthis exact same structure, OK?The difference is that\nevery instance's valuesare going to be different.So when you're creating\ninstances of classes,you can create more than one\ninstance of the same class.So we can create a\nCoordinate object hereusing this syntax right here.So you say the type, and then,\nwhatever values it takes in.And you can create more\nthan one Coordinate object.Each Coordinate object is\ngoing to have different dataattributes.Sorry, it's going to have\ndifferent data attributevalues, OK?Every Coordinate object is\ngoing to have an x value and a yvalue.But the x and y values\namong different instancesare going to vary, OK?So that's the difference\nbetween defining a classand looking at a particular\ninstance of a class.So instances have the\nstructure of the class.So for a coordinate,\nall instanceshave an x value and a y value.But the actual values\nare going to vary", "start": 240.0, "heat": 0.134}, {"text": "between the different instances.OK, so ultimately,\nwhy do we wantto use object-oriented\nprogramming?So, so far, the\nexamples that we've seenwere numerical, right--\na coordinate, a fraction.But using object-oriented\nprogramming,you can create objects\nthat mimic real life.So if I wanted to create\nobjects of-- an object thatdefined a cat and an object\nthat defined a rabbit,I could do that with\nobject-oriented programming.I would just have to decide,\nas a programmer, whatdata and what methods\nI'd want to assignto these groups of objects, OK?So using object-oriented\nprogramming, each one of theseis considered a\ndifferent object.And as a different\nobject, I can decidethat a cat is going to have\na name, an age, and maybea color associated with it.And these three\nhere, on the right,each one of these rabbits\nis also an object.And I'm going to\ndecide that I'm goingto represent a rabbit by\njust an age and a color, OK?And with object-oriented\nprogramming,using these\nattributes, I can groupthese three objects together and\nthese three objects together,OK?So I'm grouping\nsets of objects thatare going to have the\nsame attributes together.And attributes-- this is also\na recap of last time-- comein two forms, right,\ndata attributesand procedural attributes.So the data attributes\nare basicallythings that define\nwhat the object is.So how do you represent\na cat as an object?And it's up to you,\nas the programmer,to decide how you\nwant to do that.For a coordinate, it was\npretty straightforward.", "start": 360.0, "heat": 0.142}, {"text": "You had an x and a y value.If we're representing something\nmore abstract like an animal,then maybe I would\nsay, well, I'mgoing to represent an animal\nby an age and a name, OK?So it's really up\nto you to decidehow you want to represent--\nwhat data attributes you wantto represent your object with.Procedural attributes were\nalso known as methods.And the methods are\nessentially asking,what can your object do, OK?So how can someone who wants\nto use your object-- howcan someone interact with it?So for a coordinate,\nwe saw that youcould find the distance\nbetween two coordinates.Maybe for our abstract\nAnimal object,you might have it\nmake a sound, OK,by maybe printing to the\nscreen or something like that.OK, this slide's also a recap\nof how to create a class justto make sure everyone's on\nthe same page before we go on.So we defined a class\nusing this class keyword.And we said, class,\nthe name of the class.So now we're going to create\na more abstract Animal class.We're going to see,\nin the second halfof the lecture, what it\nmeans to put somethingelse in the parentheses.But for now, we say that an\nanimal is an object in Python.So that means it's going to\nhave all of the propertiesthat any other\nobject in Python has.And as we're\ncreating this animal,we're going to\ndefine how to createan instance of this class.So we say def.And this __init__ was the\nspecial method that told Pythonhow to create an object.Inside the\nparentheses, remember,we have the self,\nwhich is a variablethat we use to refer to any\ninstance of the class, OK?We don't have a particular\ninstance in mind,we just want to be able to\nrefer to any instance, OK?So we use this self variable.And then, the second\nparameter hereis going to represent\nwhat other data we use", "start": 480.0, "heat": 0.287}, {"text": "to initialize our object with.So in this case,\nI'm going to say,I'm going to initialize an\nAnimal object with an age, OK?So when I create an animal,\nI need to give it an age.Inside the __init__ are any\ninitializations that I wantto make.So the first thing is, I'm\ngoing to assign an instancevariable, age-- so this is\ngoing to be the data attributeage-- to be whatever\nis passed in.And then, I'm also making\nanother assignment here,where I'm assigning\nthe data attributename to be None originally.Later on in the code, when\nI want to create an Animalobject, I say the class name.And then I pass it in\nwhatever parametersit takes-- in this\ncase, the age.And I'm assigning it to\nthis instance here, OK?All right, so now we\nhave this class, Animal.We've done the first\npart here, which isto initialize the class, right?So we've told Python how to\ncreate an object of this type.There's a few other methods\nhere that I've implemented.Next two we call\ngetters, and the twoafter that we call setters, OK?And getters and setters\nare very commonlyused when implementing a class.So getters essentially\nreturn the values of anyof the data attributes, OK?So if you look carefully,\nget_age() is just returningself.age, and get_name()\njust returns self.name.So they're very simple methods.Similarly, set_age()\nand set_name()--we're going to see what this\nfunny equal sign is doing herein the next couple of slides.But setters do a\nvery similar thingwhere they're going to\nset the data attributesto whatever is passed in, OK?", "start": 600.0, "heat": 0.234}, {"text": "So those are\ngetters and setters.And then, the last thing down\nhere is this __str__ method.And this __str__ method is used\nto tell Python how to printan object of this type Animal.So if you didn't have\nthis __str__ method,if you remember\nfrom last lecture,what ends up happening is you're\ngoing to get some message whenyou print your object that\nsays, this is an object of typeAnimal at this memory location,\nwhich is very uninformative,right?So you implement\nthis method here,which tells Python how to print\nan object of this type, OK?So the big point\nof this slide isthat you should be using\ngetters and setters-- youshould be implementing getters\nand setters for your classes.And we're going to see, in\nthe next couple of slides,why exactly.But basically, they're\ngoing to prevent bugsfrom coming into play\nlater on if someone decidesto change implementation.So we saw how to-- so\nthe previous slide,this slide here, shows the\nimplementation of the Animalclass.And here we can see\nhow we can createan instance of this object.So we can say a = Animal(3).So this is going to create a new\nAnimal object with an age of 3.And we can access the object\nthrough the variable a.Dot notation, recall,\nis a way for youto access data attributes\nand methods of a class, OK?So you can say a.age\nlater on in your program,and that is allowed.It'll try to access\nthe age data attributeof this particular\ninstance of the class, a.So this is going to give you 3.However, it's actually\nnot recommended to accessdata attributes directly.So this is the\nreason-- so you'regoing to see in the next slide,\nthe reason-- why we're goingto use getters and setters.Instead, you should use the\nget_age() getter method to getthe age of the animal.", "start": 720.0, "heat": 0.283}, {"text": "So this is going\nto return, also, 3.So these are going\nto do the same thing.And the reason why you'd want\nto use getters and settersis this idea of\ninformation hiding, OK?So the whole reason\nwhy we're using classesin object-oriented\nprogramming isso that you can abstract\ncertain data from the user, OK?One of the things you\nshould be abstractingis these data attributes.So users shouldn't\nreally need to knowhow a class is implemented.They should just know\nhow to use the class, OK?So consider the following case.Let's say whoever wrote\nthe Animal class wantsto change the implementation.And they've decided\nthey don't wantto call the data attribute\n\"age\" anymore, theywant to call it \"years,\" OK?So when they\ninitialize an animalthey say self.years = age.So an animal still gets\ninitialized by its age.And the age gets passed into a\ndata attribute named \"years,\"OK?Since I'm implementing\nthis class,I want to have a getter, which\nis going to return self.years.So I'm not returning\nself.age anymore,because age is no longer the\ndata attribute I'm using.So with this new\nimplementation, if someonewas using this implementation\nand was accessing age directlyas-- was accessing the data\nattribute age directly--with this new\nimplementation, they'dactually get an error, right?Because this animal\nthat they createdusing my old\nimplementation no longerhas an attribute named \"age.\"And so Python's\ngoing to spit outan error saying no attribute\nfound or something like that,OK?If they were using the\ngetter a.get_age()--the person who implemented the\nclass re-implemented get_age()to work correctly, right,\nwith their new data attribute,years, as opposed to age--\nso if I was using the getterget_age(), I wouldn't\nhave run into the bug, OK?", "start": 840.0, "heat": 0.329}, {"text": "So things to remember--\nwrite getters and settersfor your classes.And later on in your code,\nuse getters and settersto prevent bugs and to\npromote easy to maintain code.OK, so information\nhiding is great.But having said that,\nPython's actually notvery great at\ninformation hiding, OK?Python allows you\nto do certain thingsthat you should never be doing.OK.So the first, we've just seen.The first is to\naccess data attributesfrom outside of the class, OK?So if I were to\nsay a.age, Pythonallows me to do that without\nusing a getter and setter.Python also allows you to\nwrite to data attributesfrom outside the class.So if I implemented\nthe class Animalassuming that age was\na number, an integer,and all of my methods work\nas long as age is an integer,but someone decided to be smart\nand, outside of the class,set age to be infinite\nas a string, that mightcause the code to crash, OK?Python allows you to do that.But now you're breaking\nthe fact that agehas to be an integer, right?So now the methods\nshould probablybe checking the fact that age\nis an integer all the time.The other thing that\nyou're allowed to dois to create data attributes\noutside of the classdefinition, OK?So if I wanted to create a new\ndata attribute called \"size\"for this particular\ninstance, Python alsoallows me to do that.And I can set it to\nwhatever I want, OK?So Python allows you\nto do all these things,but it's actually not good\nstyle to do any of them.So just don't do it.All right.So the last thing I want\nto mention-- the last thing", "start": 960.0, "heat": 0.487}, {"text": "about classes before we\ngo on to inheritance--is this idea called\ndefault arguments.And default arguments\nare passed into methods.And since methods\nare functions, youcan also pass in different\narguments to functions.So for example, this\nset_name() method had self.And then, this new name is equal\nto this empty string here, OK?We haven't seen this before.But this is called\na default argument.And you can use the\nfunction in one of two ways.The first way is\nso we can createa new instance of an Animal\ntype object with this linehere, a = Animal(3).And then we can\nsay a.set_name().So this calls the setter\nmethod to set the name.And notice, we've\nalways said that youhave to put in parameters for\neverything other than self, OK?But here we have no\nparameters passed in.But that's OK, because\nnewname actuallyhas a default argument, OK?So that tells Python, if no\nparameter is passed in for thisparticular formal parameter,\nthen use whatever is up hereby default. So if I haven't\npassed in the parametera.get_na-- a.set_name(), sorry--\na.sett_name() is going to besetting the name to\nthe empty string,because that's what the\ndefault parameter is.So in the next line, when\nI print a.get_name(),this is just going to\nprint the empty string, OK?If you do want to\npass in a parameter,you can do so as normal.So you can say a =\nAnimal(3), a.set_name(),and then pass in\na parameter here.And then, newname is going to be\nassigned to whatever parameteris passed in like that.Whatever you pass in overrides\nthe default argument,and everything is good.", "start": 1080.0, "heat": 0.262}, {"text": "So when I print a.get_name(),\nthis is going to print outthe name that you've passed in.Questions about default?Yeah.AUDIENCE: [INAUDIBLE]ANA BELL: What if you don't\nprovide a default value for--AUDIENCE: For newname?ANA BELL: For newname?If you don't provide a\ndefault argument for newnameand you do this case\nhere, then that'sgoing to give you an error.So Python's going to\nsay something like,expected one argument, got\nzero, or something like that.Great question.OK.All right, so let's move on to\nthis idea of hierarchies, OK?So the great thing about\nobject-oriented programmingis that it allows us to\nadd layers of abstractionto our code, all right?So we don't need to know how\nvery, very low-level things areimplemented in\norder to use them.And we can build up our code\nto be more and more complexas we use up these\ndifferent abstractions.So consider every one of these\nthings on this slide as beinga separate object, all right?Every one of these things can be\nconsidered to be an animal, OK?According to our\nimplementation of an animal,the one thing that an\nanimal has is an age, OK?And that's probably true, right?Every one of these\nthings has an age.But now I want to\nbuild up on thisand create separate\ngroups, right?And each one of\nthese separate groupsthat I create on\ntop of Animal isgoing to have its own\nfunctionality, right?They're going to be a little\nbit more specific, a little morespecialized.So I can create these three\ngroups now, a cat, a rabbit,and a person group.And for example-- so\nthey're all animals, right?They all have an age.But for example,\nmaybe a person'sgoing to have a list of friends\nwhereas a cat and a rabbit", "start": 1200.0, "heat": 0.178}, {"text": "do not.Maybe a cat has a data attribute\nfor the number of livesthey have left, right, whereas a\nperson and a rabbit do not, OK?So you can think of adding\nthese more specialized-- addingfunctionality to each one\nof these subgroups, OK?So they're going to be\nmore and more specialized,but all of them retaining the\nfact that they are animals.So they all have an\nage, for example.So on top of these, we\ncan add another layerand say that a student is a\nperson and is an animal, OK?But in addition to having an\nage and maybe also having a listof friends, a student\nmight also have a majoror-- they're pretty, so\nmaybe-- their favorite subjectin school.So that's the general\nidea of hierarchies, OK?So we can sort of abstract the\nprevious slide into this oneand say that we have parent\nclasses and child classes, OK?The Animal class is\nlike our parent class.It's the highest-level class.Inheriting from\nthe Animal class,we have these child\nclasses or subclasses, OK?Whatever an animal can\ndo, a person can do.Whatever an animal\ncan do, a cat can do.And whatever an animal can do,\na rabbit can do, OK-- that is,have an age and maybe some\nreally basic functionality, OK?But between person,\ncat, and rabbit,they're going to\nbe varying wildlyas to the kinds of things\nthat they can do, right?But they can all do\nwhatever Animal can do.So child classes inherit\nall of the data attributesand all of the\nmethods, or behaviors,that their parent's\nclasses have, OK?But child classes can\nadd more information.Like for example, a person\ncan have a list of friendswhereas a general\nanimal will not.It can add more behavior.", "start": 1320.0, "heat": 0.246}, {"text": "Like, maybe a cat can\nclimb trees whereas peopleand rabbits cannot.Or you can also\noverride behavior.So in the previous one, we\nhad animal, person, student.So maybe we have, an animal\ndoesn't speak at all,but a person can speak.So that's added\nfunctionality to the person.And maybe a person\ncan only say hello.But then, when we\ntalk to a student,we can override the fact--\noverride the speak() methodof a person and say that a\nstudent can say, you know,I have homework, or I need\nsleep, or something like that,OK?So we have the same speak()\nmethod for both personand student, because\nthey can both speak.But student will\noverride the factthat they say hello\nwith something else.OK, so let's look at some code\nto put this into perspective.So we have this Animal class,\nwhich we've seen before.This is the parent class, OK?It inherits from object,\nwhich means that everythingthat a basic object can do\nin Python, an animal can do,which is things like\nbinding variables,you know, very\nlow-level things, OK?We've seen the __init__.We've seen the two getters, the\nsetters, and the string methodto print an object\nof type Animal.All right, now, let's\ncreate a subclass of Animal.We'll call it Cat, OK?We create a class named Cat.In parentheses, instead\nof putting \"object,\"we now put \"Animal.\"And this tells Python that\nCat's parent class is Animal.So everything that an\nanimal can do, a cat can do.So that includes all of\nthe attributes, whichwas age and name, and\nall of the methods.So all the getters, the setters,\nthe __str__, the __init__,everything that the animal\nhad, now the cat has--the Cat class has.In the Cat class, we're going\nto add two more methods though.The first is speak().So speak() is going to be a\nmethod that's going to just", "start": 1440.0, "heat": 0.101}, {"text": "take in the self, OK--\nno other parameters.And all it's doing is printing\n\"meow\" to the screen-- verysimple, OK?So through this speak(),\nwe've added new functionalityto the class.So an animal couldn't speak,\nwhereas a cat says \"meow.\"Additionally, through\nthis __str__ method here,we're overriding the\nanimal __str__, OK?So if we go back to\nthe previous slide,we can see that the\nanimal's __str__ had animal,plus the name, plus the age here\nwhereas the cat's __str__ nowsays \"cat,\" name,\nand the age, OK?So this is just how I chose\nto implement this, OK?So here I've overridden the\n__str__ method of the Animalclass.Notice that this class\ndoesn't have an __init__,and that's OK.Because Python's actually\ngoing to say, well,if there's no __init__ in this\nparticular method-- sorry,in this particular class-- then\nlook to my parents and say,do my parents have\nan __init__, OK?And if so, use that __init__.So that's actually true\nfor any other methods.So the idea here is, when\nyou have hierarchies,you have a parent class,\nyou have a child class,you could have a child\nclass to that child class,and so on and so on.So you can have multiple\nlevels of inheritance.What happens when you\ncreate an object thatis of type something that's\nbeen-- of a type that'sthe child class of a child\nclass of a child class, right?What happens when you call\na method on that object?Well, Python's are going\nto say, does a method withthat name exist in my\ncurrent class definition?And if so, use that.But if not, then,\nlook to my parents.Do my parents know\nhow to do that, right?Do my parents have a method\nfor whatever I want to do?", "start": 1560.0, "heat": 0.1}, {"text": "If so, use that.If not, look to their\nparents, and so on and so on.So you're sort of tracing\nback up your ancestryto figure out if you can\ndo this method or not.So let's look at a slightly\nmore complicated example.We have a class named Person.It's going to\ninherit from Animal.Inside this person, I'm\ngoing to create my own--I'm going to create\nan __init__ method.And the __init__ method is going\nto do something different thanwhat the animal's\n__init__ method is doing.It's going to take\nin self, as usual.And it's going to take in\ntwo parameters as opposedto one, a name and an age.First thing the __init__\nmethod's doing is it's callingthe animal's __init__ method.Why am I doing that?Well, I could theoretically\ninitialize the nameand the age data\nattributes that Animalinitializes in this method.But I'm using the\nfact that I've alreadywritten code that initializes\nthose two data attributes.So why not just use it, OK?So here, this says, I'm going\nto call the class Animal.I'm going to call\nits __init__ method.And I'm going to leave it up to\nyou to-- not you as the class,but I'm talking as the\nprograms is running--I'm going to leave it\nup to you to figure outhow to initialize an animal\nwith this particular ageand what to name it.So Python says, yep,\nI know how to do this,so I'm going to go ahead\nand do that for you.So now it says\nperson is an animal.And I've initialized the\nage and the name for you.The next thing I'm doing in the\n__init__ is I'm going to setthe name to whatever\nname was passed in, OK?So in the __init__, notice,\nI can do whatever I want,including calling methods.And then, the last\nthing I'm doing hereis I'm going to create a new\ndata attribute for Person,which is a list of friends, OK?So an animal didn't\nhave a list of friends,but a person is going to.", "start": 1680.0, "heat": 0.137}, {"text": "The next four methods here\nare-- this one's a getter,so it's going to return\nthe list of friends.This is going to append a\nfriend to the end of my list.I want to make a note that I\nactually didn't write a methodto remove friends.So once you get a friend,\nthey're friends for life.But that's OK.The next method here is speak(),\nwhich is going to print \"hello\"to the screen.And the last method\nhere is goingto get the age difference\nbetween two people.So that just basically\nsubtracts their ageand says it's a five-year age\ndifference, or whatever it is.And down here, I have\nan __str__ method,which I've overridden\nfrom the Animal, which,instead of \"animal: name,\" it's\ngoing to say \"person: name :age,\" OK?So we can run this code.So that's down here.I have an animal person here.So I'm going to run this code.And what did I do?I created a new person.I gave it a name and an age.I created another person,\na name and an age.And here I've just run\nsome methods on it,which was get_name(),\nget_age(), get_name(),and get_age() for each\nof the two people.So that printed, Jack\nis 30, Jill is 25.If I print p1, this is going\nto use the __str__ methodof Person.So it's to print \"person:\",\ntheir name, and then,their age.p1.speak() just says \"hello.\"And then, the age difference\nbetween p1 and p2 is just 5.So that's just subtracting\nand then printing that outto the screen.OK, so that's my person.Let's add another class.This class is going\nto be a student,and it's going to be\na subclass of Person.", "start": 1800.0, "heat": 0.179}, {"text": "Since it's a subclass\nof Person, it'sgoing to-- a student\nis going inheritall the attributes of a\nperson, and therefore, all theattributes of an animal.The __init__ method of a\nstudent is going to be a littledifferent from\nthe one of Person.We're going to give it a\nname, an age, and a major.Notice we're using\ndefault arguments here.So if I create a student\nwithout giving it a major,the major is going to be\nset to None originally.Once again, this line here,\nPerson. init (self, name, age),tells Python, hey,\nyou already knowhow to initialize a person for\nme with this name and this age.So can you just do that?And Python says, yes,\nI can do that for you.And so that saves you, maybe,\nlike five lines of code justby calling the __init__ method\nthat you've already writtenthrough Person, OK?So Student has been\ninitialized to be a person.And additionally, we're going\nto set another data attributefor the student to be the major.And we're going to set\nthe major to be None.The student is going to get\nthis setter here, this settermethod, which is going to\nchange the major to whateverelse they want if they\nwant to change it.And then, I'm going to\noverride the speak() method.So the speak method\nfor the person,recall, just said \"hello.\"A student is going to be\na little bit more complex.I'm going to use the\nfact that someonecreated this random class, OK?So this is where we can\nwrite more interesting codeby reusing code that\nother people have written.So someone wrote a\nrandom class thatcan do cool things\nwith random numbers.So if I want to use\nrandom numbers in my code,I'm going to put this \"import\nrandom\" at the top of my code,which essentially brings in all\nof the methods from the Randomclass, one of the methods\nbeing this random() method.So random() is a random()\nmethod from the Random class.", "start": 1920.0, "heat": 0.138}, {"text": "And this essentially gives\nme a number between 0 and 1,including 0 but not\nincluding 1, OK?So this random number I get\nhere is going to help me writemy method for speak(), where\nit's going to-- with 25%probability, it's either going\nto say, \"I have homework,\"\"I need sleep,\" \"I should\neat,\" or \"I'm watching TV,\" OK?So a student is going to say\none of those four things.And the last thing I'm doing\ndown here is overwritingthe __str__ method.So let's look at the code.I'm going to comment this part\nout, and uncomment the student,and see what we get.OK, so here, I am\ncreating the student.I'm creating one student whose\nmajor is CS, name is Alice,and age is 20.s2 is going to be\nanother student-- name--Beth, age-- 18.And the major is going\nto be None, because Ididn't pass in any major here.So by default, using\nthe default argument,it's going to be None.If I print s1, s2, that's going\nto print out these two thingsover here just by whatever\n__str__ method does.And then I'm going to get\nthe students to speak.And if I run it\nmultiple times, youcan see that it's going to print\ndifferent things each time.So \"I need sleep,\" \"I have\nhomework,\" \"I need sleep,\"\"I have homework,\" yeah.So every time, it's going to\nprint something different.OK, questions about\ninheritance in this example?OK.Last thing we're going to\ntalk about in this classis an idea of-- or\nin this lecture,is the idea of-- a\nclass variable, OK?So to illustrate this, I'm going\nto create yet another subclassof my animal called a rabbit.", "start": 2040.0, "heat": 0.114}, {"text": "So class variables-- so so\nfar, we've seen-- sorry,let me back up.So so far, we've seen\ninstance variables, right?So things like self.name,\nself.age, thoseare all instance variables.So they're variables\nthat are specif--they are common across all of\nthe instances of the class,right?Every instance of the class\nhas this particular variable.But the value of the\nvariable is goingto be different between all\nof the different instances.So class variables are\ngoing to be variableswhose values are\nshared between allof the instances in the class.So if one instance of the class\nmodifies this class variable,then, any other\ninstance of the classis going to see\nthe modified value.So it's sort of shared among\nall of the different instances.So we're going to\nuse class variablesto keep track of rabbits.OK, so we're creating\nthis class, Rabbit.tag = 1.We haven't seen something\nlike this before.So tag is our class variable.Class variables are typically\ndefined inside the classdefinition but outside\nof the __init__.So tag is going to\nbe a class variable,and I'm initializing it to 1.Inside the __init__, this\ntells us how to create a Rabbitobject.So I'm going to give it self\nas usual, an age, and thentwo parents.Don't worry about the\ntwo parents for now.Inside the __init__--\nsorry, inside the __init__--I'm going to call the __init__\nof the animal just to do lesswork.Python already knows how to\ninitialize an animal for me,so let's do that.So that's going to set the two\ndata attributes, name and age.I'm going to set\nthe data attributesfor parent1,\nparent2 for a rabbitto be whatever's passed in.", "start": 2160.0, "heat": 0.161}, {"text": "And then, this is\nwhere I'm goingto use this class variable.So I'm creating\nthis data attributeinstance variable particular\nto a specific instance calledrid, OK?And I'm assigning this instance\nvariable to the class variable.And I access class\nvariables using not self,but the class name-- so\nin this case, rabbit.tag.So initially, tag\nis going to be 1.And then, the __init__ is going\nto increment the tag by 1 here,OK?So that means that,\nfrom now on, if Icreate any other instances,\nthe other instancesare going to be accessing the\nupdated value of tag insteadof being 1.So let's do a quick drawing\nto show you what I mean.So let's say I have\nRabbit.tag here, OK?So initially, tag is\ngoing to be 1, OK?And then I'm going to\ncreate a new Rabbit object.So this is as I'm\ncalling the code, OK?So let's say this is a rabbit\nobject-- oh boy, OK-- r1.You know, I actually googled\nhow to draw a rabbit,but that didn't help at all.OK, so r1 is going to be a\nnew rabbit that we create.Initially, what happens is, when\nI first create this new rabbit,it's going to access the\nclass variable, which,it's current value is 1.So when I create the\nrabbit ID-- the rabbit ID,r1.rid-- this is going\nto get the value 1.And according to\nthe code, after Iset the rabbit ID\nto whatever tag is,I'm going to increment the tag.So this is going to say,\nOK, now that I've said it,", "start": 2280.0, "heat": 0.342}, {"text": "I'm going to go back up here\nand increment the tag to be 2.OK.So let's say I create\nanother Rabbit object, OK?All right, there--\nthat's a sad rabbit, r2.The ID of r2 is\ngoing to be what?Well, according to the way\nwe create a new Rabbit objectis it's going to access\nwhatever the value of tagis, which is a class variable.It was changed by the previous\ncreation of my rabbit,so now I'm going to\naccess that, right?So the value is going to be 2.And according to the\ncode, the next thingI do after I create\nthe instance ridis I'm going to increment tag.So I'm incrementing the\nclass variable to be 3, OK?So notice that all\nof my instancesare accessing this\nshared resource,this shared variable called tag.So as I'm creating\nmore and more rabbits,they're all going to be\nincrementing the value of tag,because it's shared among\nall of the instances.And so this value, this\ntag class variable,keeps track of how many\ndifferent instances of a rab--of how many different\ninstances of rabbitsI've created throughout\nmy entire program, OK?So the big idea here is that\nclass variables are sharedacross all the instances.So they can all modify them.But these rids, right,\nthese instance variables,are only for that\nparticular instance.So r2 can't have access to r1's\nID value, nor could change it.But it won't change it across\nall of the different instances,OK?", "start": 2400.0, "heat": 0.299}, {"text": "So that's how the __init__\nmethod works of Rabbit, OK?So we have these tags that\nkeep track of how many rabbitswe've created.We have a couple of getter--\nwe have some getters hereto get all the parents.So now let's add a somewhat\nmore interesting function.Oh, I just want to mention,\nwhen I'm getting the rid,I'm actually using this\ncool zfill() function here,or method, which actually pads\nthe beginning of any numberwith however many zeros in order\nto get to that number here.So the number 1\nbecomes 001 and so on.So it ensures that I have\nthis nice-looking ID typething that's always\nthree digits long.So let's try to work\nwith this Rabbit object.Let's define what happens when\nyou add two rabbits together,OK-- in this class,\nnot in the real world.OK.So if I want to use the plus\noperator between two rabbitinstances, I have to implement\nthis __add__ method, OK?So all I'm doing here is I'm\nreturning a new Rabbit object,OK?Whoops, sorry about that.And let's recall the __init__\nmethod of the rabbit, OK?So when I'm returning\na new Rabbit object,I'm returning a new\nRabbit object that'sgoing to have an age of 0.Self-- so the Rabbit object\nI'm calling this method onis going to be the\nparent of the new rabbit.And other is going to be the\nother parent of the new rabbit,OK?So if we look at the\ncode, and I run it,this part here, I'm creating\nthree rabbits, r1, r2, and r3.", "start": 2520.0, "heat": 0.494}, {"text": "Notice this class\nvariable is workingas expected, because the\nIDs of each of my rabbitsincrements as I\ncreate more rabbits.So we have 001, 002, 003.If I print r1, and\nr2, and r3-- thatwas these three lines over\nhere-- the parents of r1 and r2are None, because that's just\nthe default-- yes, the defaultarguments for creating a rabbit.To add two rabbits together,\nI use the plus operatorbetween two Rabbit objects.And on the right here, I'm\ntesting rabbit addition.And I can print out the\nIDs of all my rabbits.And notice that, when I've\ncreated this new rabbit,r4, the ID of it still\nkept incrementing.So now, the ID of the\nfourth rabbit is 004.And then, when I\nget r4's parents,they are as we want them\nto be, so r1 and r2.The other thing I want to do\nis to compare two rabbits.So if I want to\ncompare two rabbits,I want to make sure that\ntheir parents are the same.So I can compare the first\nparent of the first rabbitwith the first parent\nof the second rabbitand the second parent\nof the first rabbitto the second parent\nof second rabbitor getting the\ncombinations of those two.So that's what these\ntwo Booleans are doing.So these are going\nto tell me-- theseare going to be Boolean\nvalues, either True or False.And I'm going to\nreturn either theyhave the same\nparents of that typeor the same parents\ncriss-crossed, OK?So here, notice\nthat I'm actuallycomparing the IDs of the\nrabbits as opposed to the Rabbitobjects directly, OK?So if, instead of\ncomparing the IDs in here,I was comparing the parents\nthemselves, directly,what would end up happening\nis this function, this method,eq(), would get called\nover and over again.", "start": 2640.0, "heat": 0.955}, {"text": "Because here, we have\nparents that are rabbits.And at some point, the parents\nof the very, very first rabbitsever created by this\nprogram are None.And so when I try\nto call-- when Itry to call the parent one of\nNone, that's going to give mean error, OK, something\nlike an attribute errorwhere None doesn't have\nthis parent attribute, OK?So that's why I'm\ncomparing IDs here, OK?And the code in the\nlecture here showsyou some tests about whether\nrabbits have the same parents.And I've created\nnew rabbits here,r3 and r4, the\naddition of those two.And r5 and r6 are going to have\nthe same parents down here--True-- but r4 and r6 don't, OK?So just to wrap it up,\nobject-oriented programmingis the idea of creating\nyour own collections of datawhere you can organize\nthe information in a veryconsistent manner.So every single type\nof object that youcreate of this particular\ntype that you create-- sorry,every object instance\nof a particular typeis going to have the\nexact same data attributesand the exact same methods, OK?So this really comes back\nto the idea of decompositionand abstraction in programming.All right, thanks, everyone.", "start": 2760.0, "heat": 0.648}]