[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.ERIK DEMAINE: All right,\nlet's get started.Today, we have another cool\ngraph algorithm or problem.Actually, we'll\nhave two algorithms.The problem is called\nminimum spanning tree.You can probably guess from the\ntitle what it's trying to do.We'll see two\nalgorithms for doing it.Both of them are in the category\nof greedy algorithms, whichis something we've\nseen a couple of timesalready in 6.046,\nstarting with lecture 1.This is the definition of\ngreedy algorithm from lecture 1,roughly.The idea is to always make\ngreedy choices, meaningthe choice is locally best.For right now, it seems\nlike a good thing to do,but maybe in the future\nit will screw you over.And if you have a\ncorrect greedy algorithm,you prove that it\nwon't screw you over.So it's sort of like\nCookie Monster here, alwayslocally seems like a good\nidea to eat another cookie,but maybe it'll bite\nyou in the future.So today we will embrace\nour inner Cookie Monsterand eat as many-- eat\nthe largest cookie first,would be the standard\nalgorithm for Cookie Monster.I don't know if you learned\nthat in Sesame Street,but-- all right.So what's the problem?Minimum spanning tree.Can anyone tell\nme what a tree is?Formally, not the outside thing.In graph land.Acyclic graph, close.Connected acyclic graph, good.That's important.This is 604.2 stuff.", "start": 0.0, "heat": 0.1}, {"text": "OK, so how about\na spanning tree?Sorry?AUDIENCE: It contains\nall the vertices.ERIK DEMAINE: It contains\nall the vertices.Yeah.So let me go over here.Spanning means it contains all\nthe vertices, so implicit here,I guess, is subtree or subgraph.You're given a graph.You want a spanning\ntree of that graph.It's going to be a tree\nthat lives inside the graph.So we're going to take\nsome of the edges of G,make a tree out of them, make\na connected acyclic graph.And that tree should hit\nall the vertices in G.So this is going to be a subset\nof the edges, or subgraph.Those edges should form a tree.And, I'll say, hit\nall vertices of G.OK, if I just said they\nshould form a tree,then I could say, well,\nI'll take no edges,and here's a tree\nwith one vertex.That's not very interesting.You want a vertex--\nyou want, basically,the vertex set of the tree\nto be the same as the vertexset of the graph.That's the spanning property.But you still want\nit to be a tree,so you want it to be connected\nand you want it to be acyclic.Now if G is disconnected,\nthis is impossible.And for that, you could\ndefine a spanning forestto be like a maximal\nthing like this,but we'll focus on the case\nhere as G is connected.That's the interesting case.And so we can get\na spanning tree.", "start": 120.0, "heat": 0.1}, {"text": "All right?So what is this minimum\nspanning tree problem?Minimum spanning tree.We're given a weighted\ngraph, just like last time,with shortest paths.We have an edge weight function\nW giving me a real number, say,for every edge.And we want to find a spanning\ntree of minimum total weight.So I'm going to define\nthe weight of a tree Tto be the sum over\nall edges in T,because I'm viewing a spanning\ntree as a set of edges,of the weight of that edge.OK, so pretty much\nwhat you would expect.Minimum weight spanning tree.It's a relatively\nsimple problem,but it's not so easy\nto find an algorithm.You need to prove a lot to\nmake sure that you reallyfind the right tree.I guess the really\nnaive algorithm herewould be to try\nall spanning trees,compute the weight\nof each spanning treeand return the minimum.That sounds reasonable.That's correct.But it's bad, because-- n to\nthe fourth, that would be nice.It's larger than that.", "start": 240.0, "heat": 0.19}, {"text": "Maybe not so obvious, but\nit can be exponential.Here's a graph where the\nnumber of spanning treesis exponential.This is a complete\nbipartite graphwith two vertices on one side\nand n vertices on the other,and so you can-- let's\nsay we put these twoedges into the spanning tree.And now, for each\nof these vertices,we can choose whether it\nconnects to the left vertexor the right vertix.It can only do one, but it could\ndo either one independently.So maybe this guy\nchooses the left one,this one chooses the right one.This one chooses the\nleft one, and so on.If I have n vertices down here,\nI have 2 to the n differentspanning trees.So there can be an\nexponential number.So that algorithm\nis not so good.Exponential bad.Polynomial good.So today, we're going to\nget a polynomial algorithm.In fact, we will get an almost\nlinear time algorithm as fastas Dijkstra's algorithm.But we can't use\nDijkstra's algorithm,there's no shortest paths here.Plus, one of the algorithms will\nactually look pretty similar.Two lectures ago, the\ndynamic programming lecture,we saw an example where\nwe tried to do greedy,and it gave the\nwrong answer, and sowe fell back on\ndynamic programming.Today, we're going to try\nto do dynamic programming,it's going to fail, and we're\ngoing to fall back on greedy.It's like the reverse.But the way it's\ngoing to fail iswe're going to get\nexponential time initially,and then greedy will let\nus get polynomial time.This is actually a bit unusual.I would say more typically,\ndynamic programmingcan solve anything,\nbut, you know, with nto the seventh running\ntime, something slow.And then you apply\ngreedy, and you get downto like n or n log\nn running time.So that's more common.But today, we're going\nto go from exponential", "start": 360.0, "heat": 0.137}, {"text": "down to polynomial.And that's pretty nice.Cool.So let me tell you a little\nbit about greedy algorithmtheory, so to speak.This is from the textbook.If your problem can be\nsolved by greedy algorithm,usually you can\nprove two propertiesabout that algorithm.One of them is called\noptimal substructure.And the other is called\nthe greedy choice property.Optimal substructure\nshould be familiar ideabecause it's essentially\nan encapsulationof dynamic programming.Greedy algorithms\nare, in some sense,a special form of\ndynamic programming.So this is saying\nsomething like,if you can solve\nsubproblems optimally,smaller subproblems, or\nwhatever, then you cansolve your original problem.And this may happen\nrecursively, whatever.That's essentially\nwhat makes a recurrence", "start": 480.0, "heat": 0.183}, {"text": "work for dynamic programming.And with dynamic programming,\nfor this to be possible,we need to guess some\nfeature of the solution.For example, in\nminimum spanning tree,maybe you guess one of the edges\nthat's in the right answer.And then, once you do\nthat, you can reduce itto some other subproblems.And if you can solve\nthose subproblems,you combine them and\nget an optimal solutionto your original thing.So this is a familiar property.I don't usually think of it this\nway for dynamic programming,but that is essentially what\nwe're doing via guessing.But with greedy algorithms,\nwe're not going to guess.We're just going to be greedy.Eat the largest cookie.And so that's the\ngreedy choice property.This says that eating\nthe largest cookieis actually a good thing to do.If we keep making\nlocally optimal choices,will end up with a\nglobally optimal solution.No tummy ache.This is something you wouldn't\nexpect to be true in general,but it's going to be true\nfor minimum spanning tree.And it's true for a\nhandful of other problems.You'll see a bunch more\nin recitation tomorrow.This is sort of general\ntheory, but I'm actuallygoing to have a theorem like\nthis for minimum spanning treeand a theorem like this\nfor minimum spanning tree.This is the prototype, but most\nof today is all about minimumspanning tree.", "start": 600.0, "heat": 0.156}, {"text": "And for minimum spanning\ntree, neither of theseis very obvious.So I'm just going to\nshow you these theorems.They're fairly easy to prove,\nin fact, but finding themis probably the tricky part.Actually, I guess optimal\nsubstructure is probablythe least intuitive or the\nleast obvious greedy choice.You're probably\nalready thinking,what are good greedy choices?Minimum weight edge seems\nlike a good starting point,which we will get to.But there's even\na stronger versionof that, which we will prove.And first, optimal substructure.So here, I'm going to think\nlike a dynamic program.Let's suppose that we know an\nedge that's in our solution.Suppose we know\nan edge that livesin a minimum spanning tree.We could guess that.We're not going\nto, but we could.Either way, let's just\nsuppose than an edge e--I should mention, I\nguess I didn't say,this graph is undirected.A minimum spanning tree\ndoesn't quite make sensewith directed graphs.There are other\nversions of the problembut here, the graph\nis undirected.So probably, I should write\nthis as a unordered set, u,v. And there are possibly\nmany minimum spanning trees.There could be many solutions\nwith the same weight.For example, if all of\nthese edges have weight 1,all of these trees\nare actually minimum.If all the edges have weight\n1, every spanning treeis minimum, because every\nspanning tree has exactlyn minus 1 edges.But let's suppose we\nknow an edge that'sguaranteed to be in some minimum\nspanning tree, at least one.", "start": 720.0, "heat": 0.366}, {"text": "What I would like to do is take\nthis, so let me draw a picture.I have a graph.We've identified some edge\nin the graph, e, that livesin some minimum spanning tree.I'm going to draw some kind\nof tree structure here.OK.The wiggly lines are the tree.There are some\nother edges in here,which I don't want to draw too\nmany of them because it's ugly.Those are other\nedges in the graph.Who knows where they are?They could be all\nsorts of things.OK?But I've highlighted the\ngraph in a particular way.Because the minimum\nspanning treeis a tree, if I delete\ne from the tree, thenI get two components.Every edge I remove--\nI'm minimally connected.So if I delete an edge, I\ndisconnect into two parts,so I've drawn that as the left\ncircle and the right circle.It's just a general way\nto think about a tree.Now there are other unused\nedges in this picture,who knows where they live?OK?What I would like to do is\nsomehow simplify this graphand get a smaller problem,\nsay a graph with fewer edges.Any suggestions\non how to do that?I don't actually know where\nall these white edges are,but what I'd like to do is--\nI'm supposing I know where e is,and that's an edge in my\nminimum spanning tree.So how could I get rid of it?Yeah.AUDIENCE: Find\nthe minimum weightspanning tree of the two edges.ERIK DEMAINE: I'd like\nto divide and conquer.Maybe find the\nminimum weight overhere, minimum weight over here.Of course, I don't know\nwhich nodes are in what side.So that's a little trickier.", "start": 840.0, "heat": 0.201}, {"text": "But what do I do but E itself?Let's start with that.Yeah.AUDIENCE: You remove it?ERIK DEMAINE: You\ncould remove it.That's a good idea.Doesn't work, but worth\na Frisbee nonetheless.If I delete this\nedge, one problemis maybe none of these red\nedges exist and then my graphis disconnected.Well, maybe that's\nactually a good case.That probably would\nbe a good case.Then I know how to\ndivide and conquer.I just look at the\nconnected components.In general, if I\ndelete the edge,and I have these red\nedges, then I maybefind a minimum spanning\ntree on what remains.Maybe I'll end up including\none of these edges.Maybe this edge ends up\nin the spanning tree,and then I can't put E in.So it's a little awkward.Yeah?AUDIENCE: Can you merge\nthe two nodes into one?Merge the two nodes into one.Yes.Purple Frisbee.Impressive.This is what we call\ncontracting the edge.It just means merge\nthe endpoints.Merge u and v. So I will draw\na new version of the graph.So this was u and v before.You've got to put\nthe label inside.And now we have a new\nvertex here, which is uv.Or you can think it\nas the set u, v. Wewon't really need to\nkeep track of names.And whatever edges\nyou had over here,you're going to have over here.OK?Just collapse u and v.\nThe edge e disappears.And one other thing can happen.", "start": 960.0, "heat": 0.168}, {"text": "Let me-- go over here.We could end up with duplicate\nedges by this process.So for example, suppose\nwe have u and v,and they have a common neighbor.Might have many common\nneighbors, who knows.Add some other edges,\nuncommon neighbors.When I merge, I'd\nlike to just havea single edge to that vertex and\na single edge to that vertex.And what I'm going\nto do is, if Ihave some weights on these\nedges, let's say a and b,and c and d, I'm just\ngoing to take the minimum.Because what I'm about to do is\ncompute a minimum spanning treein this graph.And if I take the minimum\nspanning tree here,and I had multiple\nedges-- one weight a,one weight b-- do you think I\nwould choose the larger weightedge?It does-- they're\nexactly the same edge,but one is higher weight.There's no point in keeping\nthe higher weight one,so I'm just going to throw\naway the higher weight one.Take them in.So this is a particular form\nof edge contraction and graphs.And I claim it's a good\nthing to do, in the sensethat if I can find a\nminimum spanning treein this new graph--\nthis is usuallycalled a G slash e, slash\ninstead of negative, to removee.I'm contracting e.So this is G slash e.This is G. If I can find a\nminimum spanning tree in Gslash e, I claim I can find\none in the original graph Gjust by adding the edge e.", "start": 1080.0, "heat": 0.1}, {"text": "So I'm going to\nsay if G prime isa minimum spanning\ntree, of G slash e,then T prime union e is a\nminimum spanning tree of G.So overall, you\ncan think of thisas a recurrence in\na dynamic program,and let me write down\nthat dynamic program.It won't be very\ngood dynamic program,but it's a starting point.This is conceptually\nwhat we want to do.We're trying to guess\nan edge e that'sin a minimum spanning tree.Then we're going to\ncontract that edge.Then we're going to recurse,\nfind the minimum spanning treeon what remains, and then we\nfind the minimum spanning tree.Then we want to\ndecontract the edge,put it back, put the\ngraph back the way it was.And then add e to the\nminimum spanning tree.And what this lemma\ntells us, is that thisis a correct algorithm.If you're lucky-- and we're\ngoing to force luckinessby trying all edges-- but if\nwe start with an edge thatis guaranteed to be in some\nminimum spanning tree, call ita safe edge, and\nwe contract, and wefind a minimum spanning\ntree on what remains,then we can put e\nback in at the end,and we'll get a minimum spanning\ntree of the original graph.", "start": 1200.0, "heat": 0.1}, {"text": "So this gives us correctness\nof this algorithm.Now, this algorithm's\nbad, again,from a complexity standpoint.The running time is\ngoing to be exponential.The number of sub problems we\nmight have to consider hereis all subsets of edges.There's no particular way--\nbecause at every step,we're guessing an arbitrary\nedge in the graph,there's no structure.Like, we can't say well,\nit's the first k edges,or some substring of edges.It's just going to be\nsome subset of edges.There's exponentially\nmany subsets, 2 to the e,so this is exponential.But we're going to\nmake a polynomialby removing the guessing.This is actually a\nreally good prototypefor a greedy algorithm.If instead of guessing,\ntrying all edges,if we could find a\ngood edge to choosethat's guaranteed to be in\na minimum spanning tree,then we could actually\nfollow this procedure,and this would be like\nan iterative algorithm.If you-- you don't\nguess-- you correctlychoose a good-- you\ntake the biggest cookie,you contract it, and then\nyou repeat that processover and over, that\nwould be a prototypefor a greedy algorithm and\nthat's what's going to work.There's different ways to\nchoose this greedy edge,and we're going to get\ntwo different algorithmsaccordingly.But that's where we're going.First, I should prove\nthis claim, cause,you know, where did edge\ncontraction come from?Why does it work?It's not too hard to prove.Let's do it.Question?Oh.All right.I should be able to do\nthis without looking.So--Proof of optimal substructure.So we're given a lot.We're told that e belongs\nto a minimize spanning tree.", "start": 1320.0, "heat": 0.209}, {"text": "Let's give that\nspanning tree a name.Say we have a minimum spanning\ntree T star, which contains e.So we're assuming that\nexists, then we contract e.And then we're\ngiven T prime, whichis a minimum spanning\ntree of G slash e.And then we want to\nanalyze this thing.So I want to claim\nthat this thing isa minimum spanning\ntree, in other words,that the weight of\nthat spanning treeis equal to the weight\nof this spanning tree,because this one is minimum.This is a minimum spanning\nof G. And this is alsosupposed to be a minimum\nspanning tree of G.OK.Sounds easy, right?I'm going to cheat, sorry.I see.Right.Duh.Easy, once you know how.So what we're going to do is\nthink about contracting e.OK, we already\nknow we're supposedto be thinking about\ncontracting e in the graph.Let's look at how it changes\nthat given minimum spanningtree.So we have T star,\nminimum spanningtree of the whole graph, and\nthen I'm going to contract e.What I mean is, if\nthat edge happensto be in the spanning\ntree-- it is, actually.We assumed that e is in there.So I'm basically removing,\nI'm just deleting that edge,maybe I should call it minus e.Then that should be a\nspanning tree of G slash e.So when I contract\nthe edge in the graph,if I throw away the edge\nfrom this spanning tree,I should still have\na spanning tree,", "start": 1440.0, "heat": 0.187}, {"text": "and I don't know\nwhether it's minimum.Probably, it is, but we\nwon't prove that right now.I claim it's still\na spanning tree.What would that take?It still hits all the vertices,\nbecause if I removed the edge,things would not be\nconnected together.But this edge was in\nthe spanning tree,and then I fused those\ntwo vertices together,so whatever spanning-- I\nmean, whatever was connectedbefore is still connected.Contraction generally\npreserves connectivity.If these things were already\nconnected directly by an edgewhen I contract, I still\nhave a connected structure,so I'm still hitting\nall the vertices.And also, the number of\nedges is still exactly right.Before, I had n minus 1 edges.Afterwards, I'll still\nhave n minus 1 edges,because I removed one edge\nand I removed one vertex,in terms of the count.So that proves that it's\nstill a spanning tree,using properties of trees.Cool.So that means the minimum\nspanning tree, this thing,T prime, the minimum\nspanning tree of G slash e,has a smaller weight\nthan this one.Because this is a\nspanning tree, the minimumis smaller than\nall spanning trees.So we know the\nweight of T prime isless than or equal to the\nweight of T star minus e.Cool.And now we want to know about\nthis thing, the weight of Tprime plus e.Well, that's just the weight of\nT prime plus the weight of e,because the weight\nof a tree is justthe sum of the\nweights of the edges.So this is less\nthan or equal to wof T star minus e plus e, which\nis just the weight of T star.", "start": 1560.0, "heat": 0.1}, {"text": "So we proved that the weight\nof our proposed spanning treeis less than or equal to\nthe weight of the minimumspanning tree in G, and\ntherefore, T prime unione actually is a\nminimum spanning tree.OK?This is really easy.It actually implies that\nall of these inequalitieshave to be\nequalities, because westarted with something minimum.Clear?That's the easier half.TheMore interesting property is\ngoing to be this greedy choiceproperty.This is sort of where the\naction is for greedy algorithms,and this is usually\nthe heart of provinggreedy algorithms are correct.We don't yet have\na greedy algorithm,but we're thinking about it.We need some way to\nintelligently choose an edge e,and I'm going to give\nyou a whole bunch of waysto intelligently\nchoose an edge e.So here's a really\npowerful lemma,and we're going to make it\neven stronger in a moment.", "start": 1680.0, "heat": 0.175}, {"text": "So I'm going to introduce\nthe notion of a cut, that'sgoing to be a similar\npicture to what I had before.I'm going to look at\nsome set of vertices.S here is a subset\nof the vertices,and that leaves in the\ngraph, everything else.This would be V minus\nS. OK, so there'ssome vertices over here,\nsome vertices over here,there's some edges\nthat are purelyinside one side of the cut.And then what I'm\ninterested in arethe edges that cross the cut.OK, whatever they look\nlike, these edges.If an edge has one vertex in\nV and one vertex not in V,I call that edge\na crossing edge.OK, so let's suppose that e is\na least-weight edge crossingthe cut.So let's say, let me be\nspecific, if e is uv,then I want one of the\nendpoints, let's u, to be in S,and I want the other\none to be not in S,so it's in capital\nV minus S. And thatwould be a crossing edge, and\namong all the crossing edges,I want to take one\nof minimum weight.There might be many,\nbut pick any one.Then I claim that edge is\nin a minimum spanning tree.", "start": 1800.0, "heat": 0.102}, {"text": "This is our golden\nticket, right?If we can guarantee an edge is\nin the minimum spanning tree,then we plug that in here.Instead of guessing, we'll\njust take that edge--we know it's in a\nminimum spanning tree--and then we'll contract it\nand repeat this process.So the tricky part-- I mean, it\nis true that the minimum weightedge is in a minimum spanning\ntree, I'll give that away.But the question is,\nwhat you do then?And I guess you\ncontract and repeatbut, that will be\nKruskal's algorithm.But this is, in some\nsense, a more general toolthat will let us identify\nedges that are guaranteedto be in the minimum\nspanning tree,even after we've already\nidentified some edges as beingin the minimum spanning tree,\nso it's a little more powerful.Let's prove this claim.This is where things\nget particularly cool.And this is where we're\ngoing to use somethingcalled a c and paste argument.And if you are ever\ntrying to provea greedy algorithm\ncorrect, the first thingthat should come to your\nmind is cut and paste.This is almost universally how\nyou prove greedy algorithmsto be correct, which is, suppose\nyou have some optimal solutionwhich doesn't have\nthe property you want,like that it includes e here.And then you modify it,\nusually by cutting outone part of the solution and\npasting in a different part,like e, and prove that you\nstill have an optimal solution,and therefore, there\nis an optimal solution.There is an MST that has\nthe property you want.OK, so we're going to do that\nby starting from an arbitraryminimum spanning tree.", "start": 1920.0, "heat": 0.278}, {"text": "So let T star be a minimum\nspanning tree of G,and if the edge e is\nin there, we're done.So presumably, e is not in\nthat minimum spanning tree.We're going to modify\nT star to include e.So again, let me draw the cut.There's S and V minus\nS. We have some edge ewhich crosses the\ncut, goes from u to v,that's not in the\nminimum spanning tree.Let's say in blue, I draw\nthe minimum spanning tree.So you know, the\nminimum spanning treeconnects everything\ntogether here.I claim it's got to have some\nedges that cross the cut,because if it has no\nedges that cross the cut,it doesn't connect vertices over\nhere with vertices over here.So it may not use e, but some\nof the edges must cross the cut.So here's a possible\nminimum spanning tree.It happens to have sort of\ntwo components over herein S, maybe.Who knows?But there's got to be at least\none edge the crosses over.In fact, the minimum\nspanning tree, T star,has to connect vertex\nu to vertex v, somehow.It doesn't use e, but there's\ngot to be-- it's a tree,so in fact, there has to\nbe a unique path from uto v in the minimum\nspanning tree.And now u is in S, v is not in\nS. So if you look at that path,for a while, you\nmight stay in S,but eventually you\nhave to leave S, whichmeans there has to be an\nedge like this one, which", "start": 2040.0, "heat": 0.294}, {"text": "I'll call it e prime,\nwhich transitionsfrom S to V minus S.So there must be an edge e prime\nin the minimum spanning treethat crosses the cut, because\nu and v are connected by a pathand that path starts in S,\nends not in S, so it's gotto transition at least once.It might transition many\ntimes, but there hasto be at least one such edge.And now what I'm going\nto do is cut and paste.I'm going to remove e\nprime and add an e instead.So I'm going to look at T\nstar minus e prime plus e.I claim that is a\nminimum spanning tree.First I want to claim, this is\nmaybe the more annoying part,that it is a spanning tree.This is more of a\ngraph theory thing.I guess one comforting\nthing is that you'vepreserved the number of\nedges, so it should stillbe if you get one\nproperty, you getthe other, because I remove\none edge, add in one edge,I'm still going to\nhave n minus 1 edges.The worry, I guess, is that\nthings become disconnectedwhen you do that, but\nthat's essentially notgoing to happen\nbecause if I thinkof removing e prime, again, that\ndisconnects the tree into twoparts.And I know, by this path, that\none part contains this vertex,another part\ncontains this vertex,and I know that this\nvertex is connected to uand this vertex is connected\nto v. Maybe I should", "start": 2160.0, "heat": 0.465}, {"text": "call this u prime and v prime.I know u and u prime\nare connected by a path.I know v and v prime\nare connected by a path.But I know that by\ndeleting e prime,u prime and v prime are not\nconnected to each other.Therefore, u and v are not\nconnected to each other,after removing e prime.So when I add in e, I newly\nconnect u and v again,and so everything's\nconnected back together.I have exactly the\nright number of edges.Therefore, I'm a spanning tree.So that's the graph\nthree theory part.Now the interesting part\nfrom a greedy algorithmis to prove to this is minimum,\nthat the weight is not too big.So let's do that over here.So I have the weight of T\nstar minus e plus-- minus eprime plus e.By linearity, this\nis just the weightof T star minus the weight e\nprime plus the weight of e.And now we're going\nto use this property,we haven't that yet, e is a\nleast-weight edge crossingthe cut.So e prime crosses\nthe cut, so does e,but e is the smallest\npossible weight youcould have crossing the cut.That means that-- I'll put that\nover here-- the weight of eis less than or equal\nto the weight of eprime, because e prime is\na particular edge crossingthe cut, e was the\nsmallest weight of them.So that tells us\nsomething about this.Signs are so difficult.\nI think that meansthat this is negative or zero.So this should be less than\nor equal to w of T star,", "start": 2280.0, "heat": 0.392}, {"text": "and that's what I\nwant, because thatsays the weight of this\nspanning tree is less thanor equal to the optimum\nweight, the minimum weight.So that means, actually,\nthis must be minimum.So what I've done is I've\nconstructed a new minimumspanning tree.It's just as good as T star,\nbut now it includes my edge e,and that's what I\nwanted to prove.There is a minimum\nspanning tree thatcontains e, provided e\nis the minimum weightedge crossing a cut.So that proves this\ngreedy choice property.And I'm going to observe one\nextra feature of this proof,which is that-- so\nwe cut and paste,in the sense that we removed\none thing, which was e prime,and we added a\ndifferent thing, e.And a useful feature is that\nthe things that we change onlyare edges that cross the cut.So we only, let's say, modified\nedges that cross the cut.I'm going to use that later.We removed one edge that crossed\nthe cut, and we put in the onethat we wanted.OK so far?There's a bunch of lemmas.Now we actually get to do\nalgorithms using these lemmas.We'll start with maybe the\nless obvious algorithm,but it's nice because it's\nvery much like Dijkstra.It follows very closely\nto the Dijkstra model.And then we'll get to\nthe one that we've allbeen thinking about, which\nwas choose a minimum weightedge, contract, and repeat.That doesn't-- well, that does\nwork, but the obvious way is,", "start": 2400.0, "heat": 0.3}, {"text": "maybe, slow.We want to do it in\nnear linear time.Let's start with the\nDijkstra-like algorithm.This is Prim's algorithm.Maybe I'll start by\nwriting down the algorithm.It's a little long.In general, the idea-- we want\nto apply this greedy choiceproperty.To apply the greedy\nchoice property,you need to choose a cut.With Prim, we're going to start\nout with an obvious cut, whichis a single vertex.If we have a single\nvertex S, and wesay that is our set\ncapital S, then you know,there's some images\ncoming out of it.There's basically S\nversus everyone else.That's a cut.And so I could take\nthe minimum weight edgecoming out of that\ncut and put thatin my minimum spanning tree.So when I do that, I put it\nin my minimum spanning treebecause I know it's in\nsome minimum spanning tree.Now, I'm going to make capital\nS grow a little bit to includethat vertex, and repeat.That's actually also a\nvery natural algorithm.Start with a tiny s and just\nkeep growing it one by one.At each stage use this lemma to\nguarantee the edge I'm addingis still in the\nminimum spanning tree.So to make that work\nout, we're alwaysgoing to need to choose the\nminimum weight edge that'scoming out of the cut.And we'll do that\nusing a priority queue,", "start": 2520.0, "heat": 0.115}, {"text": "just like we do in Dijkstra.So for every vertex\nthat's in V minus S,we're going to have that\nvertex in the priority queue.And the question is, what is\nthe key value of that nodestored in the priority queue?So the invariant I'm going\nto have is that the key of vis the minimum of the\nweights of the edgesthat cross the cut into\nv. So for vertex v,I want to look at\nthe-- I'm not goingto compute this every time,\nI'm only going to maintain it.I want the minimum weight\nof an edge that starts in Sand goes to v, which is not in\nS because v in Q-- Q only storesvertices that are not in\nS-- I want the key valueto be that minimum\nweight so if I choosethe overall minimum\nvertex, that gives methe edge of minimum weight\nthat crosses the cut.OK?I've sort of divided this\nminimum vertex by vertex.For every vertex\nover here, I'm goingto say, what's the minimum\nincoming weight from somebodyover here?What's the minimum\nincoming weightfrom someone over here to there?To here?Take the minimum\nof those things.And of course, the\nmin of all thosewill be the min of\nall those edges.OK, that's how I'm\ndividing things up.And this will be easier\nto maintain, but let mefirst initialize everything.OK, I guess we're going\nto actually initializewith S being the empty set,\nso Q will store everybody,except I'm going to get\nthings started by settingfor particular vertex little s.", "start": 2640.0, "heat": 0.207}, {"text": "I'm going to set\nits key to zero.It doesn't matter\nwho little s is.That's just your start vertex.Just pick one vertex\nand set its key to zero.That will force it\nto be chosen firstbecause for everyone else,\nfor v not equal to S,I'm going to set\nthe key to infinity,because we haven't yet seen\nany edges that go in there,but we'll change\nthat in a moment.OK, so that was the\ninitialization, nowwe're going to do a loop.We're going to keep going\nuntil the Q is empty,because when the Q is empty,\nthat means S is everybody,and at that point, we'll\nhave a spanning treeon the whole graph, and\nit better be minimum.OK, and we're going to\ndo that by extractingthe minimum from\nour priority Q. Whenwe remove Q-- we remove\nvertex u from the queue Q,this means that we're\nadding u to S. OK,by taking it out of Q,\nthat means it enters S,by the invariant at the top.So now we need to\nupdate this invariant,that all the key\nvalues are correct.As soon as we move\na vertex into S,now there are new edges we have\nto consider from S to not S,", "start": 2760.0, "heat": 0.303}, {"text": "and we do that just by looking\nat all of the neighbors of u.I haven't written\nthis in a long time,but this is how it's\nusually written in Dijkstra,except in Dijkstra, these\nare the outgoing edges from uand v are the neighbors.Here, it's an undirected\ngraph, so these areall of the neighbors v of u.This as an adjacency list.OK, so we're looking at u,\nwhich has just been added to S,and we're looking at the edges.We want to look at the edge\nas they go to V minus S, onlythose ones.And then for those vertices v,\nwe need to update their keys,because it used to just\ncount all of these edges thatwent from the rest of S to\nv. And now we have a new edgeuv that v needs to consider,\nbecause u just got added to S.So the first thing I'm\ngoing say is if v in in Q.So we're just going to store\na Boolean for every vertexabout whether it's\nin the queue, and sowhen I extract it\nfrom the queue,I just set that\nBoolean to false.Being in the queue is the\nsame as being not in S,this is what Q represents.So Q is over here, kind of.So if we're in the queue,\nsame as saying v is not in S,then we're going\nto do a check whichlets us compute the minimum.This is going to look a\nlot like a relaxation.Sorry.", "start": 2880.0, "heat": 0.556}, {"text": "A couple things\ngoing on because Iwant to compute\nnot just the valueof the minimum spanning\ntree, I actuallywant to find the\nminimum spanning tree,so I'm going to store\nparent pointers.But this is just\nbasically taking a min.I say, if the\nweight of this edgeis smaller than what's\ncurrently in the key,then update the key, because the\nkey is supposed to be the min.OK, that's all we need to do to\nmaintain this invariant, thisfor loop.After the for loop, this\nproperty will be restored,v dot key will be that minimum.And furthermore, we kept track\nof where the minimums camefrom, so when you end\nup extracting a vertex,you've already figured\nout which edge youadded to put that into the set.So in fact, u\nalready had a parent,this would be u\ndot parent, and wewant to add that edge into\nthe minimum spanning treewhen we add u to S. Overall, let\nme write why this is happening.At the end of the algorithm,\nfor every vertex v,we want the v dot parent.And that will be our\nminimum spanning tree.Those are the edges that form\nthe minimum spanning tree.Let's prove that this works.Actually, let's do an example.We've done enough\nproofs for a while.Let's do it over here.", "start": 3000.0, "heat": 0.403}, {"text": "I need a little break.Examples are fun, though easy\nto make mistakes, so correct meif you see me making a mistake.And let me draw a graph.OK, weights.14, 3, 8, 5, 6, 12, 7, 9, 15.10.OK.Colors.So I want to start\nat this vertexjust because I know it\ndoes an interesting thing,or it's a nice example.Here's my weighted\nundirected graph.I want to compute\nminimum spanning tree.I'm going to start\nwith a capitalS being-- well actually, I start\nwith capital S being nothing,and all of the weights--\nall of the key valuesare initially infinity.So I'm going to write\nthe key values in blue.So initially everything is\ninfinity for every vertex,except for S the value is zero.So all of these things\nare in my priority queue,and so when I extract from the\nqueue, I of course get S. OK,that's the point of that set up.", "start": 3120.0, "heat": 0.386}, {"text": "So that's when I draw the red\ncircle containing little s.The red circle here is\nsupposed to be capital S.So at this point, I've\nadded capital S-- little sto capital S, and then I look\nat all of the neighbors v of S.And I make sure that they are\noutside of S. In this case,they all are.All three neighbors, these\nthree guys, are not in S.And then I look at the\nweights of the edges.Here I have a weight 7 edge.That's smaller than\ninfinity, so I'mgoing to cross out\ninfinity and write 7.And 15 is smaller\nthan infinity, so I'mgoing to cross out\ninfinity and write 15.And 10, surprise, is\nsmaller than infinity.So I'm going to cross\nout infinity rate 10.So now I've updated the key\nvalues for those three nodes.I should mention in\nthe priority queue,to do that, that is a\ndecrease-key operation.This thing here\nis a decrease-key.You need to update the\npriority queue to say,hey look, the key of\nthis node changed.And so you're going to have\nto move it around in the heap,or whatever.Just like Dijkstra,\nsame thing happens.OK, so I've decreased the\nkey of those three nodes.Now I do another iteration.I look at all of the\nkey values stored.The smallest one is 7, because\nthis node's no longer in there.So I'm going to add\nthis node to capital S.So capital S is going to\ngrow to include that node.I've extracted it\nfrom the queue.And now I look at all the\nneighbors of that node.So, for example,\nhere's a neighbor.9 is less than\ninfinity, so I write 9.Here's a neighbor.12 is less than\ninfinity, so I write 12.5 is less than\ninfinity, so I write 5.Here's a neighbor,\nbut s is in big S,so we're not going\nto touch that edge.I'm not going to touch s.", "start": 3240.0, "heat": 0.178}, {"text": "OK?I will end up looking at every\nedge twice, so no big deal.Right now, who's smallest?5, I think.It's the smallest blue key.So we're going to\nadd 5 to the set.Sorry, add this\nvertex to the set S,and then look at all of the\noutgoing edges from here.So 6 is actually less\nthan 12, so this edgeis better than that one was.Then, what's that, an 8?8 Is less than 10.14 is definitely\nless than infinity.And we look at this\nedge, but that edgestays inside the red set,\nso we forget about it.Next smallest value is 6.So 6, we add this guy in.We look at the edges\nfrom that vertex,but actually nothing happens\nbecause all those verticesare inside capital S, so we\ndon't care about those edges.Next one is 8, so we'll\nadd in this vertex.And there's only one edge that\nleaves the cut, so that's 3,and 3 is indeed better than 14.So never mind.Stop.So good, now I think\nthe smallest key is 3.Notice smallest key is\nsmaller than anythingwe've seen before, other\nthan 0, but that's OK.I'll just add it in,\nand there's no edgesleaving the cut from there.And then over here,\nwe have 9 and 15.So first we'll add 9.There's no edges there.Then we add 15.OK, now s is everything.We're done.Q is empty.Where's the minimal\nspanning tree?I forgot to draw it.", "start": 3360.0, "heat": 0.23}, {"text": "Luckily, all of the edges\nhere have different numbersas labels.So when I have a 3\nhere, what I mean is,include 3 in the\nminimum spanning tree,the edge that was labeled 3.OK, so this will be a\nminimum spanning tree edge.5 will be a minimum\nspanning tree edge.These are actually\nthe parent pointers.6 will be a minimum\nspanning tree edge.7, 9, 15, and 8.Every vertex except\nthe starting onewill have a parent, which means\nwe'll have exactly n minus 1edges, that's a good sign.And in fact, this will be\na minimum spanning tree.That's the claim, because\nevery time we grew the circleto include a bigger\nthing, we wereguaranteed that this edge was\nin the minimum spanning treeby applying this\nproperty with that cut.Let me just write that down.OK, to prove\ncorrectness, you needto prove an invariant that this\nkey, the key of every vertex,always remains this minimum.So this is an invariant.You should prove\nthat by induction.I won't prove it here.But we have another invariant,\na more interesting onefrom an MST\nperspective, you know,it's just a sort of algorithm\nimplementation detail,that the tree T sub S,\nwithin S is always containedin a minimum spanning\ntree of G. So over here,", "start": 3480.0, "heat": 0.526}, {"text": "we have this way of computing\nminimum spanning treefor all vertices v,\nbut what I'd liketo do is just look\nat v that's currentlyin S. By the end, that\nwill be the whole thing,but if I look at v in S, and I\nalways look at the edge from vto v dot parent, that\ngives me this tree TS.I claim it will be contained\nin a minimum spanning treeof the entire graph,\nproof by induction.So by induction, let's assume--\ninduction hypothesis willbe that, let's say there is\na minimum spanning tree Tstar, which contains\nT sub S, and then whatthe algorithm does, is it\nrepeatedly grows S by addingthis vertex u to S. So let's\nsuppose that it adds u to S.So I'm actually going to look\nat the edge that it adds.So we have S and V minus S, and\nwe do this thing, like we justsaw, of growing by one.We add one new vertex\nover here to S,and that vertex has a parent\nedge, has a parent pointer.So this edge, I'm\ngoing to call e.So we're adding some vertex u\nthat we extract at the minimum,and we also added an\nedge e to this TS,because we grew S by 1.OK, when I do that,\nall I do is say, look,greedy choice\nproperty guaranteesthere's a minimum spanning\ntree that contains e.", "start": 3600.0, "heat": 0.342}, {"text": "Because we extracted\nthe min from the queue,and the key values are this,\nas I was arguing before,that is the minimum overall\nedge that crosses the cut.e is a minimum weight\nedge that crosses the cut,and so by greedy\nchoice property,there is some minimum\nspanning tree that contains e.But actually, I need that\nthe minimum spanning treenot only contains e, but also\ncontains all the other spanningtree edges that we had\nalready said were in T star.OK, so here's where I'm going\nto use the stronger property.I can modify T star to\ninclude e and T sub S.So we already assumed that T\nstar includes T sub S. I justdon't want to break that.And if you remember the proof\nof this greedy choice property,we said, well all we need to do\nis remove one edge that crossesthe cut and replace it with e.So here what I'm saying\nis there's some edge,yeah, maybe there's some\nedge over here in T starthat we had to remove,\nand then we put e in.And then we get a minimum\nspanning tree again,T star prime.OK, this edge that I remove\ncannot be one of the TS edgesbecause the TS edges\nare all inside S.So because I'm only removing\nan edge that crosses the cut,I'm not disturbing TS.TS will remain inside T star,\nbut then I get the new propertythat e is inside T star, and so\nI prove this invariant holds.", "start": 3720.0, "heat": 0.367}, {"text": "OK?I keep changing T star, but I\nalways preserve the propertythat all of the spanning\ntree edges that are inside Sare contained in some minimum\nspanning tree of G. MaybeI'll add in some for emphasis.Cool?So that's how we use\nthe greedy choiceproperty to get correctness\nof Prim's algorithm.What's the running time\nof Prim's algorithm?Same as Dijkstra, good answer.I guess it depends what\npriority queue you use,but whatever priority queue you\nuse, it's the same as Dijkstra.And so in particular, if we\nuse Fibonacci heaps, which,again, we're not covering, we\nget V log V plus E. In general,for every edge, we have\nto do a decrease-key.Actually, for every edge we do\ntwo decrease-key operations,potentially, if\nyou think about it.But this for loop over\nthe adjacency, the costof this stuff is constant.The cost of this is the\ndegree of the vertex u.And so we're basically\ndoing the sumof the degrees of\nthe vertices, whichis the number of edges times 2.That's the handshaking lemma.So for every edge,\nwe're potentiallydoing one decrease-key\noperation,and with Fibonacci heaps,\nthat's constant time.But we're also doing V extract\nmins those cost log V time,cause the size of\nthe queue is at mostV, and so that is actually\nthe right running time.Just like Dijkstra, so\neasy formula to remember.", "start": 3840.0, "heat": 0.597}, {"text": "All right, let's do one more\nalgorithm, Kruskal's algorithm.Kruskal's algorithm is a\nlittle bit weirder from the Sperspective, I guess.We'll see what cuts\nwe're using in a moment,but it's based\naround this idea of,well, the globally\nminimum weightedge is the minimum weight edge\nfor all cuts that cross it,or for all cuts that it crosses.The globally minimum weight edge\nis going to be a valid choice,and so, by this\ntheorem, you picksome S that partitions\nthe endpoints of e,therefore e is in a\nminimum spanning tree.So let's choose that one\nfirst, and then repeat.Conceptually, what we want to\ndo is that DP idea of contractthe vertex, sorry,\ncontract the edgeand then find the minimum\nweight edge that remains.But the way I'm going to phrase\nit doesn't explicitly contract,although implicitly,\nit's doing that.And there's a catch.The catch is suppose I've\npicked some edges out to bein my minimum spanning tree.Suppose this was\nthe minimum weightand this was the next minimum,\nnext minimum, next minimum,next minimum.Suppose that the next\nlar-- at this point,after contracting those\nedges, the minimum weight edgeis this one.", "start": 3960.0, "heat": 0.852}, {"text": "Do I want to put this edge\nin my minimum spanning tree?No.That would add a cycle.Cycles are bad.This is the tricky\npart of this algorithm.I have to keep track of\nwhether I should actuallyadd an edge, in other\nwords, whether this vertexand this vertex have already\nbeen connected to each other.And it turns out you've\nalready seen a data structureto do that.This is what I call\nunion-find and the textbookcalls it disjoint-set\ndata structure.So it's in recitation.Recitation 3.So I want to maintain\nfor my MST so far,so I'm adding edges\none at a time.And I have some tree-- well,\nit's actually a forest,but I'm still\ngoing to call it T,and I'm going to maintain it\nin a union-find structure,disjoint-set set data structure.Remember, this had three\noperations, make set, union,and find set.Tell me given an item which\nset does it belong to?We're going to use\nthat, the sets are goingto be the connected components.So after I've added these edges,\nthese guys, these verticeshere, will form one\nconnected component,and, you know,\neverybody else will justbe in its own\nseparate component.So to get started, I'm not going\nto have any edges in my tree,and so every vertex is in\nits own connected component.So I represent that by calling\nmake-set v for all vertices.So every vertex lives in\nits own singleton set.OK, now I'd like to do the\nminimum weight edge, and then", "start": 4080.0, "heat": 0.674}, {"text": "the next minimum weight edge,\nand the next minimum weightedge.That's also known\nas sorting, so I'mgoing to sort E by\nweight, increasing weight,so I get to start with\nthe minimum weight edge.So now I'm going to do a\nfor-loop over the edges,increasing order by weight.Now I want to know--\nI have an edge,it's basically the minimum\nweight edge among the edgesthat remain, and so I want to\nknow whether I should add it.I'm going to add it provided\nthe endpoints of the edgeare not in the same\nconnected component.How can I find out\nwhether two verticesare in the same connected\ncomponent, given this setup?Yeah?AUDIENCE: Call find-set\ntwice and then--ERIK DEMAINE: Call\nfind-set twice and seewhether they're equal, exactly.Good answer.So if you find-set of u\nis from find-set of v,find-set just returns\nsome identifier.We don't really care\nwhat it is, as longas it returns the same\nthing for the same set.So if u and v are in the\nsame set, in other words,they're in the same\nconnected component,then find-set will return\nthe same thing for both.But provided they're\nnot equal, thenwe can add this\nedge into our tree.", "start": 4200.0, "heat": 0.164}, {"text": "So we add e to the\nset T, and thenwe have to represent\nthe fact that we justmerged the connected\ncomponents of u and v,and we do that\nwith a union call.And if you're ever\nwondering whatthe heck do we use union-find\nfor, this is the answer.The union-find data structure\nwas invented in orderto implement Kruskal's\nalgorithm faster, OK?In fact, a lot of\ndata structurescome from graph algorithms.The reason Fibonacci\nheaps were inventedwas because there was\nDijkstra's algorithmand we wanted it to run fast.So same deal here, you just\nsaw it in the reverse order.First you saw union-find.Now, union-find, you\nknow you can solve vin alpha of n time, the\ninverse Ackermann function,super, super tiny, slow growing\nfunction, smaller than loglog log log log log log.Really small.But we have this sorting,\nwhich is kind of annoying.So the overall\nrunning time-- we'llworry about correctness\nin a moment.We have to sort--\nto sort E by weight.So I'll just call\nthat's sort of E.Then we have to do some unions.I guess for every edge,\npotentially, we do a union.I'll just write E times alpha\nof v. And then we have to do,well, we also have to\nfind-sets, but same deal.So find-set and union\ncost alpha amortized,so the total cost for\ndoing this for all edgesis going to be the number\nof edges times alpha,and then there's like plus v,\nI guess, but that's smaller.That's a connected graph.So other than the sorting time,\nthis algorithm is really good.It's faster.But if you're sorting\nby an n log n algorithm,this is not so great.", "start": 4320.0, "heat": 0.371}, {"text": "That's how it goes.I think you can reduce this to\nsorting just v things, insteadof E things, with a\nlittle bit of effort,like doing a select operation.But when this algorithm\nis really goodis if your weights are integers.If You have weights, let's\nsay weight of e is 0 or 1or, say, n to the c,\nfor some constant c,then I can use rate x\nsort, linear time sorting,and then this will\nbe linear time,and I'm only paying\nE times alpha.So if you have\nreasonably small weights,Kruskal's algorithm is better.Otherwise, I guess you\nprefer Prim's algorithm.But either away.I actually used a variation\nof this algorithm recently.If you want to generate\na random spanning tree,then you can use exactly\nthe same algorithm.You pick a random manage that\nyou haven't picked already, yousee, can I add this\nedge with this test?If you can, add it and repeat.That will give you a\nrandom spanning tree.It will generate all spanning\ntrees uniform leap likely.So that's a fun fact,\nuseful thing for union-find.Let me tell you briefly\nabout correctness.Again, we proved correctness\nwith an invariant.Claim that at all\ntimes the tree Tof edges that\nwe've picked so faris contained in some minimum\nspanning tree, T star.", "start": 4440.0, "heat": 0.487}, {"text": "T start is going to\nchange, but I alwayswant the edges I've chosen to be\ninside a minimum spanning tree.Again, we can prove\nthis by induction.So assume by induction\nthat this is trueso far, and then suppose that\nwe're adding an edge here.So we're converting T into\nT prime, which is T union e.By the data structural\nsetup, I knowthat the endpoints\nof e, u, and vare in different\nconnected components.In general, what my\npicture looks like,is I have some various\nconnected components,maybe there's a single\nvertex, whatever.I've built a minimum\nspanning tree for each one.I built some tree,\nand I actuallyknow that these trees are\ncontained in one global minimumspanning tree.OK, and now we're\nlooking at an edge thatgoes from some vertex u\nin one connected componentto some vertex v in a\ndifferent connected component.This is our edge e.That's our setup.Because the union-find\ndata structuremaintains connected\ncomponents, that'sanother invariant to prove.We're considering adding\nthis edge, which connects twodifferent connected components.So I want to use the greedy\nchoice property with some S.What should S be?I want e to cross a cut,\nso what's a good cut?", "start": 4560.0, "heat": 0.508}, {"text": "Yeah?AUDIENCE: The\nconnected componentof u and then everything else.ERIK DEMAINE:\nConnected componentof u and everything else?AUDIENCE: Yeah.ERIK DEMAINE: That\nwould work, whichis also the opposite of the\nconnected component containingv. There are many\nchoices that work.I could take basically\nthis cut, whichis the connected component\nof you with everythingelse versus the\nconnected component of v.I could take this cut, which\nis the connected component of uonly versus everybody else.Either of those will work.Good.Good curve, all right.So let's say S equals the\nconnected component of u,or connected component of v.\ne crosses that, all right?Because it goes from u to\nv, and u is on one side,v is on the other side.I wanted to include an\nentire connected componentbecause when I apply the\ngreedy choice property,I modify T star,\nand I don't wantto modify, I don't want to\ndelete any of these edges thatare already in my\nconnected components,that I've already put in there.But if I choose my\ncut to just be this,I know that the edge\nthat I potentially removewill cross this\ncut, which means itgoes between connected\ncomponents, which meansI haven't added that yet to T.So when I apply this\ngreedy choice property,I'm not deleting anything\nfrom T. Everything thatwas in T is still in T star.So that tells me that T prime\nis contained in T star prime.The new T star that I get\nwhen I apply the cut and pasteargument, I modify\nT star potentiallyby removing one edge\nand putting e in.And the edge that\nI remove was notalready in T, which means\nI preserve this part,but I also get that\nmy new edge e is", "start": 4680.0, "heat": 0.546}, {"text": "in the minimum spanning tree.And so that's how you prove\nby induction that at all timesthe edges that you've\nchosen so far are in T star.Actually, to apply the\ngreedy choice property,I need not only that e is cut--\nsorry, that e crosses the cut,I also need that e\nis the minimum weightedge crossing the cut.That's a little more\nargument to prove.The rough idea is\nthat if you forgetabout the edges we've\nalready dealt with,e is the globally\nminimum weight edge.OK, but what about the edges\nwe've already dealt with?Some of them are in the tree.The edges that are in\nthese-- that are in T, thoseobviously don't cross the cut.That's how we designed the cut.The cup was designed\nnot to cross,not two separate any of\nthese connected components.So all the edges that we've\nadded to T, those are OK.They're not related to the\nedges that cross this cut.But we may have already\nconsidered some lower weightedges that we didn't add to T.\nIf we didn't add an edge to T,that means actually they\nwere in the same set, whichmeans also those are-- I'm going\nto use my other color, blue.Those are extra\nedges in here thatare inside a\nconnected component,have smaller weight\nthan e, but they'reinside the connected component.So again, they're not crossed.So they don't cross\nthe cut, rather.So e is basically the\nfirst edge that we'reconsidering that\ncrosses this cut,because otherwise we would have\nadded that other edge first.So here, we have to do sort\nof the greedy argument again,considering edges\nby weight and eis going to be the\nfirst edge thatcrosses this\nparticular cut, whichis this connected component\nversus everyone else.So e has to be the minimum\nweight edge crossing the cut,so the greedy choice\nproperty applies.So we can put e in the\nminimum spanning tree,and this algorithm is correct.", "start": 4800.0, "heat": 0.565}, {"text": "OK?So we've used that lemma\na zillion times by now.That's minimum spanning\ntree and nearly linear time.", "start": 4920.0, "heat": 0.53}]