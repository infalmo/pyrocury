[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or to\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.JOHN GUTTAG: All right,\nwelcome to the 60002,or if you were in 600,\nthe second half of 600.I'm John Guttag.Let me start with a few\nadministrative things.What's the workload?There are problem sets.They'll all be\nprogramming problemsmuch in the style of 60001.And the goal-- really twofold.60001 problem sets\nwere mostly about youlearning to be a programmer.A lot of that carries over.No one learns to be a\nprogrammer in half a semester.So a lot of it is to\nimprove your skills,but also there's a\nlot more, I would say,conceptual, algorithmic\nmaterial in 60002,and the problem\nsets are designedto help cement that\nas well as justto give you\nprogramming experience.Finger exercises, small things.If they're taking you more\nthan 15 minutes, let us know.They really shouldn't,\nand they're generallydesigned to help you learn\na single concept, usuallya programming concept.Reading assignments\nin the textbooks,I've already posted the\nfirst reading assignment,and essentially they should\nprovide you a very differenttake on the same\nmaterial we're covering", "start": 0.0, "heat": 0.1}, {"text": "in lectures and recitations.We've tried to choose\ndifferent examples for lecturesand from the textbooks\nfor the most part,so you get to see things in\ntwo slightly different ways.There'll be a final exam\nbased upon all of the above.All right,\nprerequisites-- experiencewriting object-oriented\nprograms in Python, preferablyPython 3.5.Familiarity with concepts\nof computational complexity.You'll see even in\ntoday's lecture,we'll be assuming that.Familiarity with some\nsimple algorithms.If you took 60001 or you\ntook the 60001 advancedstanding exam, you'll be fine.Odds are you'll be\nfine anyway, but that'sthe safest way to do it.So the programming\nassignments aregoing to be a bit\neasier, at least that'swhat students have\nreported in the past,because they'll be more focused\non the problem to be solvedthan on the actual programming.The lecture content,\nmore abstract.The lectures will be--and maybe I'm speaking\neuphemistically--a bit faster paced.So hang on to your seats.And the course is really\nless about programmingand more about dipping your toe\ninto the exotic world of datascience.We do want you to hone\nyour programming skills.There'll be a few\nadditional bits of Python.Today, for example, we'll\ntalk about lambda abstraction.Inevitably, some comments\nabout software engineering,how to structure your code,\nmore emphasis in using packages.Hopefully it will go\na little bit smootherthan in the last\nproblem set in 60001.And finally, it's the old\njoke about programmingthat somebody walks up to a\ntaxi driver in New York City", "start": 120.0, "heat": 0.137}, {"text": "and says, \"I'm lost.How do I get to Carnegie Hall?\"The taxi driver\nturns to the personand says, \"practice,\npractice, practice.\"And that's really the only\nway to learn to programis practice, practice, practice.The main topic of the\ncourse is what I thinkof as computational models.How do we use\ncomputation to understandthe world in which we live?What is a model?To me I think of it as\nan experimental devicethat can help us to either\nunderstand something thathas happened, to sort of build\na model that explains phenomenawe see every day,\nor a model thatwill allow us to predict\nthe future, somethingthat hasn't happened.So you can think of, for\nexample, a climate changemodel.We can build models that sort\nof explain how the climate haschanged over the\nmillennia, and then wecan build probably a\nslightly different modelthat might predict what it\nwill be like in the future.So essentially\nwhat's happening isscience is moving out of the\nwet lab and into the computer.Increasingly, I'm sure\nyou all see this--those of you who\nare science majors--an increasing reliance on\ncomputation rather thantraditional experimentation.As we'll talk about,\ntraditional experimentationis and will remain\nimportant, but now ithas to really be\nsupplemented by computation.We'll talk about three\nkinds of models--optimization models, statistical\nmodels, and simulation models.So let's talk first about\noptimization models.An optimization model\nis a very simple thing.We start with an objective\nfunction that's eitherto be maximized or minimized.", "start": 240.0, "heat": 0.1}, {"text": "So for, example, if I'm going\nfrom New York to Boston,I might want to find a\nroute by car or planeor train that minimizes\nthe total travel time.So my objective\nfunction would bethe number of minutes spent in\ntransit getting from a to b.We then often have to layer on\ntop of that objective functiona set of constraints, sometimes\nempty, that we have to obey.So maybe the fastest way to\nget from New York to Bostonis to take a plane, but I\nonly have $100 to spend.So that option is off the table.So I have the constraints\nthere on the amountof money I can spend.Or maybe I have to be\nin Boston before 5:00 PMand while the bus would\nget me there for $15,it won't get me\nthere before 5:00.And so maybe what I'm\nleft with is driving,something like that.So objective function,\nsomething you're eitherminimizing or maximizing,\nand a set of constraintsthat eliminate some solutions.And as we'll see, there's\nan asymmetry here.We handle these two\nthings differently.We use these things\nall the time.I commute to work using Waze,\nwhich essentially is solving--not very well, I believe--\nan optimization problemto minimize my time\nfrom home to here.When you travel, maybe you log\ninto various advisory programsthat try and optimize\nthings for you.They're all over the place.Today you really can't avoid\nusing optimization algorithmas you get through life.", "start": 360.0, "heat": 0.1}, {"text": "Pretty abstract.Let's talk about a specific\noptimization problemcalled the knapsack problem.The first time I talked\nabout the knapsack problemI neglected to show a\npicture of a knapsack,and I was 10 minutes\ninto it before Irealized most of the class had\nno idea what a knapsack was.It's what we old people\nused to call a backpack,and they used to look more\nlike that than they look today.So the knapsack\nproblem involves--usually it's told in terms of a\nburglar who breaks into a houseand wants to steal\na bunch of stuffbut has a knapsack\nthat will onlyhold a finite amount of stuff\nthat he or she wishes to steal.And so the burglar has to\nsolve the optimization problemof stealing the stuff with\nthe most value while obeyingthe constraint that it all\nhas to fit in the knapsack.So we have an\nobjective function.I'll get the most for\nthis when I fence it.And a constraint, it has\nto fit in my backpack.And you can guess\nwhich of these might bethe most valuable items here.So here is in words, written\nwords what I just said orally.There's more stuff\nthan you can carry,and you have to choose\nwhich stuff to takeand which to leave behind.I should point out that\nthere are two variants of it.There's the 0/1 knapsack\nproblem and the continuous.The 0/1 would be illustrated\nby something like this.So the 0/1 knapsack problem\nmeans you either takethe object or you don't.I take that whole gold\nbar or I take none of it.", "start": 480.0, "heat": 0.1}, {"text": "The continuous or so-called\nfractional knapsack problemsays I can take pieces of it.So maybe if I take\nin my gold barand shaved it into gold\ndust, I then can say,well, the whole\nthing won't fit in,but I can fit in a\npath, part of it.The continuous knapsack\nproblem is really boring.It's easy to solve.How do you think you would\nsolve the continuous problem?Suppose you had over here a pile\nof gold and a pile of silverand a pile of raisins, and you\nwanted to maximize your value.Well, you'd fill up\nyour knapsack with golduntil you either ran out of\ngold or ran out of space.If you haven't run\nout of space, you'llnow put silver in until\nyou run out of space.If you still haven't\nrun out of space,well, then you'll take as many\nraisins as you can fit in.But you can solve it with what's\ncalled a greedy algorithm,and we'll talk much more\nabout this as we go forward.Where you take the best\nthing first as long asyou can and then you move\non to the next thing.As we'll see, the\n0/1 knapsack problemis much more complicated because\nonce you make a decision,it will affect the\nfuture decisions.Let's look at an example, and\nI should probably warn you,if you're hungry, this is not\ngoing to be a fun lecture.So here is my least\nfavorite because I alwayswant to eat more than\nI'm supposed to eat.So the point is typically\nknapsack problemsare not physical knapsacks\nbut some conceptual idea.So let's say that I'm allowed\n1,500 calories of food,and these are my options.I have to go about deciding,\nlooking at this food--", "start": 600.0, "heat": 0.1}, {"text": "and it's interesting, again,\nthere's things showing upon your screen that are not\nshowing up on my screen,but they're harmless, things\nlike how my mouse works.Anyway, so I'm trying to take\nsome fraction of this food,and it can't add up to\nmore than 1,500 calories.The problem might be that\nonce I take something that's1,485 calories, I\ncan't take anythingelse, or maybe 1,200 calories\nand everything else ismore than 300.So once I take one thing, it\nconstrains possible solutions.A greedy algorithm,\nas we'll see,is not guaranteed to\ngive me the best answer.Let's look at a\nformalization of it.So each item is represented by\na pair, the value of the itemand the weight of the item.And let's assume the knapsack\ncan accommodate itemswith the total weight\nof no more than w.I apologize for the\nshort variable names,but they're easier\nto fit on a slide.Finally, we're going\nto have a vector lof length n representing\nthe set of available items.This is assuming we have\nn items to choose from.So each element of the\nvector represents an item.So those are the items we have.And then another\nvector v is goingto indicate whether or\nnot an item was taken.So essentially I'm going\nto use a binary numberto represent the set of\nitems I choose to take.For item three say,\nif bit three is zeroI'm not taking the item.", "start": 720.0, "heat": 0.1}, {"text": "If bit three is one, then\nI am taking the item.So it just shows I\ncan now very nicelyrepresent what I've done\nby a single vector of zerosand ones.Let me pause for a second.Does anyone have any\nquestions about this setup?It's important to get\nthis setup because whatwe're going to see now depends\nupon that setting in your head.So I've kind of used mathematics\nto describe the backpackproblem.And that's typically the way\nwe deal with these optimizationproblems.We start with some\ninformal description,and then we translate them into\na mathematical representation.So here it is.We're going to try\nand find a vectorv that maximizes the sum\nof V sub i times I sub i.Now, remember I sub i is\nthe value of the item.V sub i is either zero or one\nSo if I didn't take the item,I'm multiplying\nits value by zero.So it contributes\nnothing to the sum.If I did take the item, I'm\nmultiplying its value by one.So the value of the item\ngets added to the sum.So that tells me the\nvalue of V. And Iwant to get the\nmost valuable V Ican get subject\nto the constraintthat if I look at the item's\ndot weight and multiply it by V,the sum of the weights\nis no greater than w.So I'm playing the same\ntrick with the valuesof multiplying each\none by zero or one,", "start": 840.0, "heat": 0.1}, {"text": "and that's my constraint.Make sense?All right, so now we have\nthe problem formalized.How do we solve it?Well, the most obvious\nsolution is brute force.I enumerate all\npossible combinationsof items; that is to say,\nI generate all subsetsof the items that\nare available--I don't know why it\nsays subjects here,but we should have said items.Let me fix that.This is called the power set.So the power set of a set\nincludes the empty subset.It includes the set\nthat includes everythingand everything in between.So subsets of size one,\nsubsets of size two, et cetera.So now I've generated all\npossible sets of items.I can now go through\nand sum up the weightsand remove all those sets that\nweigh more than I'm allowed.And then from the\nremaining combinations,choose any one whose\nvalue is the largest.I say choose any\none because therecould be ties, in which case\nI don't care which I choose.So it's pretty obvious\nthat this is goingto give you a correct answer.You're considering\nall possibilitiesand choosing a winner.Unfortunately, it's\nusually not very practical.What we see here is\nthat's what the powerset is if you have 100 vec.Not very practical, right,\neven for a fast computergenerating that many\npossibilities is going", "start": 960.0, "heat": 0.1}, {"text": "to take a rather long time.So kind of disappointing.We look at it and say, well,\nwe got a brute force algorithm.It will solve the problem,\nbut it'll take too long.We can't actually do it.100 is a pretty\nsmall number, right.We often end up solving\noptimization problemswhere n is something\ncloser to 1,000, sometimeseven a million.Clearly, brute force\nisn't going to work.So that raises\nthe next question,are we just being stupid?Is there a better algorithm\nthat I should have showed you?I shouldn't say we.Am I just being stupid?Is there a better algorithm that\nwould have given us the answer?The sad answer to that is\nno for the knapsack problem.And indeed many\noptimization problemsare inherently exponential.What that means is there\nis no algorithm thatprovides an exact solution\nto this problem whose worstcase running time is not\nexponential in the numberof items.It is an exponentially\nhard problem.There is no really\ngood solution.But that should not make you\nsad because while there'sno perfect solution, we're going\nto look at a couple of reallyvery good solutions that\nwill make this poor womana happier person.So let's start with\nthe greedy algorithm.I already talked to you\nabout greedy algorithms.So it could hardly be simpler.We say while the\nknapsack is not full,put the best available\nitem into the knapsack.When it's full, we're done.", "start": 1080.0, "heat": 0.111}, {"text": "You do need to ask a question.What does best mean?Is the best item\nthe most valuable?Is it the least\nexpensive in termsof, say, the fewest\ncalories, in my case?Or is it the highest\nratio of value to units?Now, maybe I think a\ncalorie in a glass of beeris worth more than a calorie\nin a bar of chocolate,maybe vice versa.Which gets me to a\nconcrete example.So you're about to\nsit down to a meal.You know how much you value\nthe various different foods.For example, maybe\nyou like donutsmore than you like apples.You have a calorie\nbudget, and here we'regoing to have a fairly\naustere budget--it's only one meal;\nit's not the whole day--of 750 calories, and we're going\nto have to go through menusand choose what to eat.That is as we've seen\na knapsack problem.They should probably\nhave a knapsack solverat every McDonald's\nand Burger King.So here's a menu I just made up\nof wine, beer, pizza, burger,fries, Coke,\napples, and a donut,and the value I might\nplace on each of theseand the number of calories that\nactually are in each of these.And we're going to\nbuild a program thatwill find an optimal menu.And if you don't like this\nmenu, you can run the programand change the values\nto be whatever you like.Well, as you saw\nif you took 60001,we like to start with\nan abstract data type,like to organize our program\naround data abstractions.So I've got this class food.", "start": 1200.0, "heat": 0.2}, {"text": "I can initialize things.I have a getValue,\na getCost, density,which is going to be the value\ndivided by the cost, and thena string representation.So nothing here that you should\nnot all be very familiar with.Then I'm going to have a\nfunction called buildMenu,which will take\nin a list of namesand a list of values of equal\nlength and a list of calories.They're all the same length.And it will build the menu.So it's going to be\na menu of tuples--a menu of foods, rather.And I build each food by\ngiving it its name, its value,and its caloric content.Now I have a menu.Now comes the fun part.Here is an implementation\nof a greedy algorithm.I called it a flexible\ngreedy primarily becauseof this key function over here.So you'll notice in red there's\na parameter called keyfunction.That's going to be-- map the\nelements of items to numbers.So it will be used\nto sort the items.So I want to sort them\nfrom best to worst,and this function will be used\nto tell me what I mean by best.So maybe keyfunction will\njust return the value or maybeit will return the weight\nor maybe it will returnsome function of the density.But the idea here\nis I want to useone greedy algorithm\nindependently", "start": 1320.0, "heat": 0.187}, {"text": "of my definition of best.So I use keyfunction to\ndefine what I mean by best.So I'm going to come in.I'm going to sort it\nfrom best to worst.And then for i in range\nlen of items sub copy--I'm being good.I've copied it.That's why you sorted\nrather than sort.I don't want to have a side\neffect in the parameter.In general, it's not\ngood hygiene to do that.And so for-- I'll go through\nit in order from best to worst.And if the value is less\nthan the maximum cost,if putting it in would keep\nme under the cost or notover the cost, I put\nit in, and I justdo that until I can't\nput anything else in.So I might skip a few because\nI might get to the pointwhere there's only\na few calories left,and the next best item is\nover that budget but maybefurther down I'll find one that\nis not over it and put it in.That's why I can't exit\nas soon as I reach--as soon as I find an\nitem that won't fit.And then I'll just return.Does this make sense?Does anyone have any doubts\nabout whether this algorithmactually works?I hope not because I\nthink it does work.Let's ask the next question.How efficient do we think it is?What is the efficiency\nof this algorithm?Let's see where the time goes.", "start": 1440.0, "heat": 0.116}, {"text": "That's the algorithm\nwe just looked at.So I deleted the\ncomment, so we'dhave a little more\nroom in the slide.Who wants to make a guess?By the way, this\nis the question.So please go answer\nthe questions.We'll see how people do.But we can think about\nit as well together.Well, let's see\nwhere the time goes.The first thing is at the sort.So I'm going to\nsort all the items.And we heard from\nProfessor Grimsonhow long the sort takes.See who remembers.Python uses something\ncalled timsort,which is a variant of something\ncalled quicksort, whichhas the same worst-case\ncomplexity as merge sort.And so we know that is n\nlog n where n in this casewould be the len of items.So we know we have that.Then we have a loop.How many times do we\ngo through this loop?Well, we go through the loop\nn times, once for each itembecause we do end up\nlooking at every item.And if we know that,\nwhat's the order?AUDIENCE: [INAUDIBLE].JOHN GUTTAG: N log n plus n--", "start": 1560.0, "heat": 0.212}, {"text": "I guess is order n log n, right?So it's pretty efficient.And we can do this for big\nnumbers like a million.Log of a million times a million\nis not a very big number.So it's very efficient.Here's some code\nthat uses greedy.Takes in the items, the\nconstraint, in this casewill be the weight,\nand just calls greedy,but with the keyfunction\nand prints what we have.So we're going to test greedy.I actually think I used 750 in\nthe code, but we can use 800.It doesn't matter.And here's something\nwe haven't seen before.So used greedy by\nvalue to allocateand calls testGreedy with food,\nmaxUnits and Food.getValue.Notice it's passing\nthe function.That's why it's not--no closed parentheses after it.Used greedy to allocate.And then we have something\npretty interesting.What's going on\nwith this lambda?So here we're going to be using\ngreedy by density to allocate--actually, sorry, this\nis greedy by cost.And you'll notice\nwhat we're doing is--we don't want to\npass in the cost,right, because we really want\nthe opposite of the cost.We want to reverse the sort\nbecause we want the cheaper", "start": 1680.0, "heat": 0.435}, {"text": "items to get chosen first.The ones that have fewer\ncalories, not the ones thathave more calories.As it happens,\nwhen I define cost,I defined it in the obvious way,\nthe total number of calories.So I could have gone and written\nanother function to do it,but since it was so simple,\nI decided to do it in line.So let's talk about lambda\nand then come back to it.Lambda is used to create\nan anonymous function,anonymous in the sense\nthat it has no name.So you start with\nthe keyword lambda.You then give it a\nsequence of identifiersand then some expression.What lambda does is\nit builds a functionthat evaluates that expression\non those parameters and returnsthe result of evaluating\nthe expression.So instead of writing def, I\nhave inline defined a function.So if we go back to it here,\nyou can see that what I've doneis lambda x one divided\nby Food.getCost of x.Notice food is the\nclass name here.So I'm taking the function\ngetCost from the class food,and I'm passing it the parameter\nx, which is going to be what?What's the type\nof x going to be?I can wait you out.What is the type of x have to\nbe for this lambda expression", "start": 1800.0, "heat": 0.229}, {"text": "to make sense?Well, go back to the class food.What's the type of the\nargument of getCost?What's the name of the\nargument to getCost?That's an easier question.We'll go back and\nwe'll look at it.What's the type of the\nargument to getCost?AUDIENCE: Food.JOHN GUTTAG: Food.Thank you.So I do have--\nspeaking of food, wedo have a tradition\nin this classthat people who answer\nquestions correctly getrewarded with food.Oh, Napoli would\nhave caught that.So it has to be of\ntype food because it'sself in the class food.So if we go back to here, this\nx has to be of type food, right.And sure enough, when\nwe use it, it will be.Let's now use it.I should point out that lambda\ncan be really handy as itis here, and it's\npossible to writeamazing, beautiful,\ncomplicated lambda expressions.", "start": 1920.0, "heat": 0.136}, {"text": "And back in the good old days of\n6001 people learned to do that.And then they learned\nthat they shouldn't.My view on lambda expressions\nis if I can't fit itin a single line,\nI just go rightdef and write a\nfunction definitionbecause it's easier to debug.But for one-liners,\nlambda is great.Let's look at using greedy.So here's this\nfunction testGreedy,takes foods and the\nmaximum number of units.And it's going to\ngo through and it'sgoing to test all three\ngreedy algorithms.And we just saw that, and\nthen here is the call of it.And so I picked up some\nnames and the values.This is just the menu we saw.I'm going to build the\nmenus, and then I'mgoing to call testGreedys.So let's go look at the\ncode that does this.So here you have it or maybe\nyou don't, because every timeI switch applications\nWindows decides I don't wantto show you the screen anyway.This really shouldn't\nbe necessary.Keep changes.Why it keeps forgetting,\nI don't know.Anyway, so here's the code.It's all the code\nwe just looked at.Now let's run it.Well, what we see\nhere is that weuse greedy by value to\nallocate 750 calories,and it chooses a\nburger, the pizza,and the wine for a total of--", "start": 2040.0, "heat": 0.155}, {"text": "a value of 284 happiness\npoints, if you will.On the other hand, if\nwe use greedy by cost,I get 318 happiness points and\na different menu, the apple,the wine, the cola, the\nbeer, and the donut.I've lost the pizza\nand the burger.I guess this is what\nI signed up for whenI put my preferences on.And here's another solution\nwith 318, apple, wine--yeah, all right.So I actually got\nthe same solution,but it just found them\nin a different order.Why did it find them\nin a different order?Because the sort order was\ndifferent because in this caseI was sorting by density.From this, we see\nan important pointabout greedy algorithms, right,\nthat we used the algorithmand we got different answers.Why do we have\ndifferent answers?The problem is that\na greedy algorithmmakes a sequence of\nlocal optimizations,chooses the locally optimal\nanswer at every point,and that doesn't\nnecessarily add upto a globally optimal answer.This is often illustrated by\nshowing an example of, say,hill climbing.So imagine you're in a terrain\nthat looks something like this,and you want to get to the\nhighest point you can get.So you might choose\nas a greedy algorithmif you can go up, go up; if\nyou can't go up, you stop.", "start": 2160.0, "heat": 0.272}, {"text": "So whenever you get\na choice, you go up.And so if I start here, I\ncould right in the middlemaybe say, all right, it's not\nup but it's not down either.So I'll go either left or right.And let's say I go\nright, so I come to here.Then I'll just make my way\nup to the top of the hill,making a locally optimal\ndecision head up at each point,and I'll get here and I'll\nsay, well, now any place I gotakes me to a lower point.So I don't want to do it, right,\nbecause the greedy algorithmsays never go backwards.So I'm here and I'm happy.On the other hand, if I had\ngone here for my first step,then my next step up would take\nme up, up, up, I'd get to here,and I'd stop and say, OK,\nno way to go but down.I don't want to go down.I'm done.And what I would find is I'm\nat a local maximum rather thana global maximum.And that's the problem\nwith greedy algorithms,that you can get stuck\nat a local optimal pointand not get to the best one.Now, we could ask\nthe question, canI just say don't\nworry about a densitywill always get me\nthe best answer?Well, I've tried a\ndifferent experiment.Let's say I'm feeling\nexpansive and I'm goingto allow myself 1,000 calories.Well, here what we see is the\nwinner will be greedy by value,", "start": 2280.0, "heat": 0.125}, {"text": "happens to find a better\nanswer, 424 instead of 413.So there is no way\nto know in advance.Sometimes this definition\nof best might work.Sometimes that might work.Sometimes no definition\nof best will work,and you can't get\nto a good solution--you get to a good solution.You can't get to\nan optimal solutionwith a greedy algorithm.On Wednesday, we'll talk\nabout how do you actuallyguarantee finding an\noptimal solution in a betterway than brute force.See you then.", "start": 2400.0, "heat": 0.149}]