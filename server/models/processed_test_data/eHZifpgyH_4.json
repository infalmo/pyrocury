[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.ERIC DEMAINE: All right,\ntoday we do NP completeness,an entire field in one lecture.Should be fun.I actually taught an entire\nclass about this topiclast semester, but now we're\ngoing to do it in 80 minutes.And we're going to look at\nlots of different problems,from Super Mario Brothers\nto jigsaw puzzles,and show that\nthey're NP -complete.This is a fun area.As Srini mentioned last class,\nit's all about reductions.It's all about\nconverting one probleminto another, which is a fun\nkind of puzzle in itself.It's an algorithmic challenge.And we're going to do it a lot.But first I'm going to remind\nyou of some of the things youlearned from 006, and tell you\nwhat we need to do in orderto prove all of these relations,\nwhat exactly we need to showfor each of those arrows,\nand why it's interesting.So this is generally around\nthe P versus NP problem.So remember, P is all\nthe problems we know howto solve in polynomial time.Well not just the ones\nwe know how to solve,but also the ones that can be\nsolved, which is pretty much--which is the topic of 6.006,\nand 6.046 up till now.But for now, in the\nnext few lectures,we'll be talking about\nproblems that are probably notpolynomially solvable,\nand what to do about them.Polynomial, as you now, is\nlike n to the some constant.Polynomial good exponential bad.", "start": 0.0, "heat": 0.195}, {"text": "What is n?I guess n is the size\nof the problem, whichwe'll have to be a little\nbit careful about today.And then NP is not\nproblem solvablenot in polynomial time,\nbut it's problem solvablein nondeterministic\npolynomial time.And in this case\nwe need to focuson a particular type of problem,\nwhich is decision problems.Decision just means that the\nanswer is either yes or no.So it's a single bit answer.We will see why we\nneed to restrictto that kind of\nproblem in a moment.So this is problems you can\nsolve in polynomial time.Same notion of polynomials,\nsame notion of n,but in a totally unrealistic\nmodel of computation.Which is a\nnondeterministic model.In a nondeterministic\nmodel, whatyou can do is say\ninstead of computingsomething from something you\nknow, you could make a guess.So you can guess one out of\npolynomially many optionsin constant time.", "start": 120.0, "heat": 0.175}, {"text": "So normally a constant time\noperation, in regular models,like you add two numbers, or you\ndo an if, that sort of thing.Here we can make a guess.I give the computer polynomially\nmany options I'm interested in.Computer's going to\ngive me one of them.It's going to give\nme a good guess.Guess is guaranteed to be good.And good means here\nthat I want to getto a yes answer if I can.So the formal statement\nis, if any guesswould lead to a yes answer,\nthen we get such a guess.OK, this is weird.And it's asymmetric.It's biased towards yes.And this is why we can only\nthink about decision problems,yes or no.You could bias towards no.You get something\nelse called coNP.But we'll focus here just on NP.So the idea is I'd really\nlike to find a guess thatleads to a yes answer.And the machine magically\ngives me one if there is one.Which means if I end\nup saying no, thatmeans there was absolutely no\npath that would lead to a yes.So when you get a no, you\nget a lot of information.When you get a yes, you\nget some information.But hey, you were lucky.Hard to complain.So in 006, I often call this\nthe lucky model of computation.That's the informal version.But nondeterminism is\nwhat's really going on here.So maybe it's useful\nto get an example.So here's a problem we'll--this is sort of the granddaddy\nof all NP-complete problems.We'll get to\ncompleteness in a moment.3SAT-- SAT stands\nfor satisfiability.", "start": 240.0, "heat": 0.336}, {"text": "So in 3SAT, the\ninput to the problemlooks something like this.I'm just going to\ngive an example.And in case you've forgotten\nyour weird logic notation,this is an and.These are ORs.And I'm using this\nfor negation, not.So in other words, I'm given\na formula which is and of ORs.And each or clause only\nhas three things in it.These things are\ncalled literals.And a literal is either\na variable x sub i,or it's the negation of\na variable, not x sub i.So this is a typical example.You could have no negations.You could here have one\nnegation, two negations,any number of\nnegations per clause.These groups of three--these or of three things, three\nliterals, are called clauses.And they're all ANDed together.And my goal is, this should\nbe a decision question,so I have a yes or no question.And that question is, can\nyou set the variables--So they're x1 to true or false?So each variable I get to choose\na true or false designationsuch that the formula\ncomes out true.", "start": 360.0, "heat": 0.383}, {"text": "I use T and F for\ntrue and false.So I want to set\nthese variables suchthat every clause comes\nout true, because they'reANDed together.So I have to satisfy this\nclause in one of three ways.Maybe I satisfy\nit all three ways.Doesn't matter, as long\nas at least one of theseshould be true, and at least\none of these should be true,and at least one of each\nclause should be true.So that's the 3SAT problem.This is a hard problem.We don't know a\npolynomial time algorithm.There probably isn't one.But there is a polynomial time\nnondeterministic algorithm.So this problem is in NP\nbecause if I have lucky guesses,it's kind of designed to\nsolve this kind of problem.What I'm going to do is guess\nwhether x1 is true or false.So I have two choices.And I'm going to ask my machine\nto make the right choice,whether it should\nbe true or false.Then I'll guess x2.Each of these guess operations\ntakes constant time.So I do it for every variable.And then I'm going\nto check whether Ihappen to satisfy the formula.And if it comes out true,\nthen I'll return yes.And if it comes out\nfalse, I'll return no.And because NP is biased\ntowards yes answers,it always finds a yes\nanswer if you can.If there's some way to\nsatisfy the formula,then I will get it.If there's some way to make\nthe formula come out true,then this algorithm\nwill return yes.If there's no way\nto satisfy it, then", "start": 480.0, "heat": 0.392}, {"text": "this nondeterministic\nalgorithm will return no.That's just the\ndefinition of hownondeterministic machines work.It's a little weird.But you can see from\nthis kind of prototypeof a nondeterministic algorithm,\nyou can actually alwaysarrange for your guessing\nto be at the beginning.And then you do some regular\npolynomial time checkingor deterministic checking.So when you rewrite\nyour algorithmlike this with guesses up\nfront and then checking,you can also think of it as\na verification algorithm.So you can say, your friend\nclaims that this 3SAT formulais satisfiable,\nmeaning there's a wayto set the variable so\nthat it comes out true.So this is called a\nsatisfying assignment.Satisfying just means make true.And you're like, no,\nI don't believe you.And your friend says no,\nno, no, really, it's true.And here's how I can prove it.You set x1 to false.You set x2 to true.You set x3-- basically\nthey give you the guesses.And then you don't\nhave to be convincedthat those are\nthe right guesses,you can check that\nit's the right guess.You can compute this\nformula in linear time,see what the outcome is.If someone tells you\nwhat the xi's are,you can very quickly\nsee whether thatwas a satisfying assignment.So you could call\nthis a solution,and then there's a\npolynomial time verificationalgorithm that checks\nthat solutions are valid.But, you can only do\nthat for yes answers.Your friend says no,\nthis is not satisfiable,they have no way of\nproving it to you.I mean, other than checking\nall the assignments separately,which would take\nexponential time,there's no easy way to confirm\nthat the answer to this problemis no.But there is an\neasy way to checkthat the answer is yes, namely\nI give you the satisfyingassignment.So this definition of NP\nis what I'll stick to.", "start": 600.0, "heat": 0.434}, {"text": "It's this sort of--I like guessing because it's\nlike dynamic programming.With dynamic programming\nwe also guess,and guessing actually originally\ncomes from this world,nondeterminism.In dynamic programming, we\ndon't allow this kind of model.And so we have to check\nthe guesses separately.And so we spend lots of time.Here, magically, you\nalways get the rightguess in only constant time.So this is a much\nmore powerful model.Of course there's no computers\nthat work like this, sadly,or I guess more interestingly.So this is more about confirming\nthat your problem is nottotally impossible.At least you can check the\nanswers in polynomial time.So that's one thing.So this is an equivalent\ndefinition of NPbecause you can take a\nnondeterministic algorithmand put the guessing up top.You can call the\nresults of those guessesa certificate that\nan answer is yes.And then you have a regular old\ndeterministic polynomial timealgorithm that, given\nthat certificate,will verify that it actually\nproves that the answer is yes.It's just that certificate\nhas to be polynomial size.", "start": 720.0, "heat": 0.388}, {"text": "You can't guess something\nof exponential size.You can only guess something of\npolynomial size in this model.So seems a little weird.But we'll see why this is\nuseful in a little bit.So let me go to NP completeness.So if I have a problem X,\nit's NP-complete if X is in NPand X is NP-hard.But I haven't told\nyou what NP-hard is.Maybe you remember from\n006, but let me remind you.So, I need to define reduce.So maybe I'll do\nthat as well, thenwe can talk about all these.", "start": 840.0, "heat": 0.176}, {"text": "OK, a lot of definitions.But the idea of NP\nhardness is very simple.If problem X is NP-hard,\nit means that it's at leastas hard as--sorry, that is a Y--it's at least as hard\nas all problems in NP.Intuitively, X means\nit's at least ashard as everything in NP.Whereas being in NP is\na positive statement.That says it's not\ntoo hard, at leastthere's a polynomial time\nverification algorithm.So being in NP is good news.It says you're no\nharder than NP.NP-hard says you're at least\nas hard as everything in NP.And so NP-complete is a nice\nanswer because this saysyou're exactly as hard\nas everything in NP--no harder, no easier.If you draw, in\nthis vague sense,computational\ndifficulty on one axis--which is not really accurate,\nbut I like to do it anyway--and you have P is all of\nthese easy problems down here.And NP is some\nlarger set like this.NP-hard is from here over.And this point right\nhere is NP-complete.Being in NP means you're left\nof this line, or on the line.And being NP-hard means\nyou're right of this line,or on the line.NP-complete means\nyou're right there.So that's a very definitive\nsense of hardness.", "start": 960.0, "heat": 0.19}, {"text": "Now there is this\nslight catch, whichis we don't know\nwhether P equals NP.So maybe this is the same\nas this, but probably not.Unless you believe\nin luck, basically,unless you imagine\nthat a computer couldengineer luck and always\nguess the right thingswithout spending a lot of\ntime, then P does not equal NP.And in that world, what\nwe get is that if you havean NP-complete problem, or\nactually any NP-hard problem,you know it cannot be NP.So if you have\nthat X is NP-hard,then you know that X is\nnot in P unless all of NPis in P. So unless P equals NP.And most reasonable people\ndo not believe this.And so instead they\nhave to believe this,that your problem is not\npolynomially solvable.So why is this true?Because if your\nproblem is NP-hard,it is at least as hard\nas every problem in NP.And if you believe that\nthere is some problem in NP--we don't necessarily\nknow which one--but if there is any problem out\nthere in NP that is not in P,then X has to be at\nleast as hard as it.So it also requires\nnonpolynomial time, somethinglarger than polynomial time.What does at least\nas hard mean though?We're going to define it\nin terms of reductions.Reduction from one\nproblem to anotheris just a polynomial\ntime algorithm,regular deterministic\npolynomial time,that converts an\ninput to the problem Ainto an equivalent\ninput to problemB. Equivalent means that it\nhas the same yes or no answer.And we'll just be thinking\nabout decision problems today.So why would I care\nabout a reduction?Because what it tells me is that\nif I know how to solve problem", "start": 1080.0, "heat": 0.405}, {"text": "B, then I also know how\nto solve problem A. If Ihave a, say, a polynomial\ntime algorithm for solving Band I want one for A,\nI just take my A input.I convert it into the\nequivalent B input.Then I run my algorithm\nfor B, and then itgives me the answer\nto the A problembecause the answers\nare the same.So if you have a reduction\nlike this and if say,B, has a polynomial\ntime algorithm,then so does A, because you\ncan just convert A into B,and then solve B.\nAlso this worksfor nondeterministic algorithms.Not too important.So what this tells us is\nthat in a certain sense--get this right--\nwell this is saying,if I can solve B,\nthat I can solve A.So this is saying\nthat B is at least ashard as A. I think I got\nthat right, a little tricky.So if we want to prove\nthe problem is NP hard,what we do is show that\nevery problem in NPcan be reduced to the problem\nof X. So now we can go backand say well, if we believe\nthat there is some problem Y,that is in NP minus P, if\nthere's something out here thatis not in P, then we\ncan take that problem Y,and by this definition,\nwe can reduce itto X, because everything\nin NP reduces to X.And so then I can\nsolve my problemY, which is in NP minus P,by converting it\nto X and solvingX. So that means X better\nnot have a polynomial timealgorithm, because if\nit did, Y would alsohave a polynomial\ntime algorithm.", "start": 1200.0, "heat": 0.443}, {"text": "And then in general,\nP would equalNP, because every problem\nin NP can be converted to X.So if X has a polynomial\ntime algorithm,then every problem Y does.Question?AUDIENCE: For the\nsecond if statement,why can't you say that if\nA is in NP, B is in NP?ERIC DEMAINE: So you're asked\nus about the reverse question.If is A in NP, can we\nconclude that B is in NP?And the answer is no.Because this reduction only\nlets us convert from A to B.It doesn't let us do anything\nfor converting from B to A.So if we know how to\nsolve A and we alsoknow how to convert A into B,\nit doesn't tell us anything.It could be B is a much\nharder problem than A,in that situation.That's, I think, as good\nas I can do for that.Other questions?All right.It is really tricky to get\nthese directions right.So let me give you a handy guide\non how to not make a mistake.So maybe over here.What we care about, from\nan algorithmic perspective,is proving the problems\nare NP-complete.Because if we prove\nNP-completeness--I mean, really we care\nabout NP-hardness,but we might as well\ndo NP-completeness.Most of the problems that\nwe'll see that are NP-hardare also NP-complete.So when we prove this, we\nprove that there is basicallyno polynomial time\nalgorithm for that problem.So that's good to\nknow, because then wecan just give up searching for\na polynomial time algorithm.So all the problems\nwe've seen so far", "start": 1320.0, "heat": 0.36}, {"text": "have polynomial time algorithms,\nexcept a couple in your problemsets, which were\nactually NP-complete.And the best you could\nhave done was exponential,unless P equals NP.So here's how you can prove\nthis kind of lower boundto say look, I don't need\nto look for algorithmsany more because my\nproblem is just too hard.It's as hard as\neverything in NP.So this is just a summary\nof those definitions.The first thing you do\nis prove that X is in NP.The second thing you do is\nprove that X is NP-hard.And to do that, you reduce\nfrom some known NP-completeproblem--or I guess NP-hard, but\nwe'll use NP-complete--to your problem X. Maybe\nI'll give this a name Y.OK, so to prove\nthat X is in NP, youdo something like\nwhat we did over here,which is to give a\nnondeterministic algorithm.Or you can think\nof it as definingwhat the certificate is and\nthen giving a polynomial timeverification algorithm.So sort of two approaches.You can give a nondeterministic\npolynomial time algorithm,or you give a certificate\nand a verifier.There's no right or\nwrong certificate.I mean, a certificate, you\ncan define however you want,as long as the verifier\ncan actually check itand when it says yes, then the\nanswer to the problem was yes.So it's really the same thing.Just want to say\nthere's some certificatethat a verifier\ncould actually check.So that's proving that\nyour problem is in NP.It's sort of an\nalgorithmic thing.", "start": 1440.0, "heat": 0.298}, {"text": "The second part is\nall about reductions.Now the definition\nsays that I shouldreduce every problem\nin NP to my problem X.That's tedious,\nbecause there area lot of problems in the world.So I don't want to do it\nfor every problem in NP.I'd like to just do it for one.Now if I reduce\nsorting to my problem,that's not very interesting.It says my problem is at\nleast as hard as sorting.But I already know\nhow to solve sorting.But if I start from an\nNP-complete problem,then I know, by the definition,\nthat every problem in NPcan be reduced to that problem.And if I show how to reduce\nthe NP-complete problem to me,then I know that\nI'm NP-complete too.Because if I have\nany problem Z in NP,by the definition of NP-complete\nof Y I can reduce that to Y.And then if I can build\na reduction from Y to X,then I get this reduction.And so that means I can\nconvert any problem in NPto my problem X, which\nmeans X is NP-hard.That's the definition.So all this is to\nsay the first timeyou prove a problem is\nNP-complete in the world-- thishappened in the '70s by Cook.Basically he proved that\n3SAT is NP-complete.That was annoying,\nbecause he hadto start from any\nproblem in NP, and hehad to show that you could\nreduce any problem in NPto 3SAT.But now that that hard work is\ndone, our life is much easier.And in this class all\nyou need to think aboutis picking your favorite\nNP-complete problem.3SAT's a good choice\nfor almost anything,but we'll see a bunch of other\nproblems today from here.And then reduce from that\nknown problem to your problemthat you're trying\nto prove is NP-hard.If you can do that, you know\nyour problem is NP-hard.So we only need one reduction\nfor each hardness result, whichis nice.And this picture is a\ncollection of reductions.We're going to start from 3SAT.I'm not going to prove\nthat it's NP-complete,although I'll give you a\nhint as to why that's true.", "start": 1560.0, "heat": 0.359}, {"text": "We're going to reduce it\nto Super Mario Brothers.We're going to reduce it to\nthree dimensional matching.We're going to reduce\nthree dimensional matchingto subsets sum, to partition,\nto rectangle packing,to jig saw puzzles.And we're going to do all\nthose reductions, hopefully.And that's proving NP-hardness\nof all those problems.They're also all in NP.So 30 second intuition\nwhy 3SAT is NP-hard.Well, if you have\nany problem in NP,that means there is one of these\nnondeterministic polynomialtime algorithms, or there\nis some verifier givena polynomial size certificate.So that verifier is\njust some algorithm.And software and hardware\nare basically the same thing,right?So you can convert\nthat algorithminto a circuit that\nimplements the algorithm.And if I have a circuit with\nlike ANDs and ORs and NOTs,I can convert that\ninto a Boolean formulawith ANDs, ORs, and NOTs.Circuits and formulas\nare about the same.And if I have a formula--fun fact, although this\nis a little less obvious--you can convert it into this\nform, an AND of triple ORs.And once you've done\nthat, that formulais equivalent to the\noriginal algorithm.And the inputs to that\nverification algorithm,the certificate, are represented\nby these variables, the xi's.And so deciding whether\nthere's some wayto set the xi's to\nmake the formula trueis the same thing as saying is\nthere some certificate wherethe verifier says yes, which\nis the same thing as sayingthat the problem has answer yes.So given an NP algorithm, one\nof these nondeterministic funnyalgorithms, we can convert it\ninto a formula satisfactionproblem.And that's how you prove\n3SAT is NP-complete.But to do that can\ntake many lectures,so I'm not going\nto do the details.", "start": 1680.0, "heat": 0.341}, {"text": "The main annoying part is\nbeing formal about what exactlyan algorithm is, which we\ndon't do in this class.If you're interested,\ntake 6.045,which is some\npeople are actuallyin the overlap this semester.Cool.Let's do some reductions.This is where things get fun.So we're going to start\nwith reducing 3SATto Super Mario Brothers.So how many people have\nplayed Super Mario Brothers?Easy one.I hope if you haven't\nplayed, you've seen it,because we're going to rely very\nmuch on Super Mario Brothersphysics, which I hope\nis fairly intuitive.But if you haven't played,\nyou should, obviously.And we're going to reduce\n3SAT to Super Mario Brothers.Now this is a theorem by a\nbunch of people, one MIT gradstudent, myself, and a couple\nother collaborators not at MIT.And of course this result holds\nfor all versions of Super MarioBrothers so far\nreleased, I think.The proofs are a\nlittle bit differentfor each one, especially Mario\n2, which is its own universe.What I'm going to talk about the\noriginal Super Mario Brothers,NES classic which\nI grew up with.Now the real Super Mario\nBrothers is on a 320by 240 screen.It's a little bit small.Once you go right, you can't go\nback left, except in the mazelevels anyway.So I need to generalize\na little bit.Because if you assume that\nthe screen size of Super MarioBrothers is\nconstant, in fact you", "start": 1800.0, "heat": 0.551}, {"text": "can dynamic program\nyour way throughand find the optimal\nsolution in polynomial time.So I need to generalize a little\nbit to arbitrary board size,arbitrary screen size.So in fact, my entire level will\nbe in one screen, no scrolling.Never mind this is a\nside scrolling adventure.And so that's my\ngeneralized problem.And I claim this is NP-hard.If I give you a\nlevel and I ask you,can you get to the\nend of this level?That problem is NP-hard.Also no time limit.The time limit would be OK,\nbut you have to generalize it.Instead of 300\nseconds or whatever,it has to be an arbitrary value.So how are we going to do this?We're going to reduce from\n3SAT to Super Mario Brothers.So that means I'm given--I don't get to choose.I'm given one of these formulas.And I have to convert it into an\nequivalent Super Mario Brotherinstance.So I have to convert it into\na level, a hypothetical levelof Super Mario Brothers.Given a formula, I have\nto build a level thatimplements that formula.So here's what it's\ngoing to look like.I'm going to start\nout somewhere.Here's my drawing of Mario.Mario-- or you could play Luigi.It doesn't matter.First thing it's going to do\nis enter a little black boxcalled a variable.This is supposed to\nrepresent, let's call it x1.And so it's some black box.I'm going to tell you\nwhat it is in a moment.And it has two outputs.There's the true output\nand the false output.And the idea is that Mario has\nto choose whether to set x1to true or false.Let me show you that gadget.So here's the--\nwhoops, upside down--here is the variable gadget.So here's Mario.", "start": 1920.0, "heat": 0.584}, {"text": "Could enter from\nthis way or that way.We'll need a couple of\nentrances in a moment.And then falls down.Once Mario is down here, if\nyou check the jump height,you cannot get back up to here.So this is like a one way.Once you're down here,\nyou have a choice.Should I fall to the left\nor fall to the right?And if you make these falls\nlarge enough, once you fall,you can't unfall.So once you make a\nchoice of whether Ileave on the true exit\nor the false exit,that's a permanent choice.So you can't undo it, unless\nyou can come back to here.But we'll set up so\nthat never happens.I mean, if you're trying\nto solve the level,you don't know which way to go.You have to guess.Can I go fall to the left\nor fall to the right,or do something.So the existence of a\nplay through, this level,is the same as saying there is\na choice for the x1 variable.Now we have to do this\nfor lots of variables.So there's x2 variable,\nx3 variable, and so on.Each one has a true\nexit and a false exit.So the actual level will\nhave n instances of thisif we have n variables.Now, what do I do\nonce Mario decidesthat this is a true thing?What I'm going to\ndo is have-- thisis called a gadget by the way.In general, most\nNP-hardness proofsuse these things called\ngadgets, which is just saying,we take various\nfeatures of the input,and we convert them into\ncorresponding featureson the output.So here I'm taking each\nvariable, x1, x2, x3,and so on, and building\nthis little gadgetfor each of those variables.Now the other main thing you\nhave in 3SAT are the clauses.We have triples of variables\nor their negations.They have to come\ntogether and be satisfied.One of them has to be true.So down here I'm going to have\nsome clause gadgets, whichI will show you in a moment.", "start": 2040.0, "heat": 0.491}, {"text": "OK, and I think\nI'll switch colors.This is about to get messy.So the idea is that some of\nthe clauses have x1 in them.The true version\nof x1, not x1 bar.So for those clauses,\nI want to connect.I'm going to dip into\nthe clause briefly.So from this wire going to\ndip into the clause here.And then I'm going to go to\nthe next clause that has x1.Maybe it's this one, and\nthe next one, and so on.All the clauses that have\nx1 in it, I dip into.The other ones I don't.And then once I'm\ndone, I'm goingto come back and feed into x2.Next, I look at this\nfalse wire for x1.So all the clauses that\nhave x1 bar in them,I'm going to connect.So I don't know\nwhich ones they are.Maybe this one, or\nthis one, something.And then I come here.And so the idea is that\nMario makes a choicewhether x1 is true or false.If x1 is true, Mario is going\nto visit all of the clauses thathave x1 true in them.And then it's going to\ngo to the x2 choice.Then it's going to choose\nwhether x2 is true or false,and repeat.Or Mario decides\nx1 should be false.That will satisfy\nall the clausesthat have x1 bar in them.And then again, we\nfeed back into x2.So this is why we have two\ninputs into the x2 gadget.One of them is when the\nprevious variable was true.The other is when the\nprevious variable was false.The choice of x2 doesn't\ndepend on the choice of x1.So they feed into\nthe same thing.And you have to\nmake your choice.So far, so good.Now the question is, what's\nhappening in these clauses.And then there's\none other aspect,", "start": 2160.0, "heat": 0.343}, {"text": "which is after you've set all of\nthe variables, at the very end,after this last variable\nxn, at the very end,what we're going to do is come\nand go through all the clauses.And then this is the flag.This is where you win the level.Sorry, I drew it backwards.But the goal is for Martin to\nstart here and get to here.In order to do\nthat, you have to beable to traverse\nthrough these clauses.So what do the\nclauses look like?This is a little\nbit more elaborate.So here we are.This is a clause gadget.So there are three ways\nto dip into the clause.It's actually upside down\nrelative to that picture,but that's not a problem.So if Mario comes here, then\nhe can hit the question markfrom below.And inside this question mark\nis an invincibility star.And the invincibility star\nwill come up here and justbounce around forever.We checked.The star will just stay there\nfor as long as you let it sit.Unfortunately, all of\nthese are solid blocks,so Mario can't actually get\nup to here to get the star.But as long as Mario\ncan visit this questionmark or this question mark\nor this question mark,then there will be at\nleast one star up here.So the idea is\nthat each of theserepresents one of the\nliterals that's in the clause.And if we choose--so let's look at this first\nclause, x1 or x3 or x6 bar.So if we choose x1 to be true,\nthen we'll follow the pathand we'll be able\nto hit the star.Or if we choose x3 to be\ntrue, then we'll come in hereand hit this star.Or if we choose x6 to\nbe false, then that pathwill lead to here and we'll be\nable to hit this question markand get the star up here.So as long as we\nsatisfy the clause,there will be at least one star.Won't help if you\nhave multiple stars.", "start": 2280.0, "heat": 1.0}, {"text": "Then the final traversal part--\nso that was this first clause.And now we're\ntraversing through.Actually in this picture,\nit's left to right.Just turn your head.And so now Mario\nis going to haveto traverse this gadget from\nleft to right on this top part.And if Mario comes in here and\nyou can barely jump over that.If there's a star, you\ncan collect the starand then run through all of\nthese flaming bars of death.If there's no star, you can't.You'll die if you\ntry to traverse.So in order to be able to\ntraverse all these clauses,they must all be true.And them all being true is the\nsame is their AND being true.So you will be able to survive\nthrough all these clausesif and only if this formula\nhas a satisfying assignment.The satisfying\nassignment would begiven to you by the level play.The choices that Mario\nmakes in this gadgetwill tell you\nwhether each variableshould be true or false.So to elaborate just\na little bit morein general, when you have\na reduction like this,to prove that it actually works,\nyou need to check two things.You need to check\nthat if there is a wayto satisfy this\nformula, then thereis a way to play this level.And then conversely you need\nto show that if there's a wayto play this level,\nthen the formulahas a satisfying assignment.So for that latter\npart, in orderto convert a level play into\na satisfying assignment,you just check which way Mario\nfalls in each of these gadgets,left or right.That tells you the\nvariable assignment.And because of the\nway the clauses work,you'll only be able to\nfinish the level if therewas at least one star here.And stars run out\nafter some time.So you can barely make it\nthrough all the flaming barsof death.Then you get to the next clause.You need another\nstar for each one.Conversely, if there is\na satisfying assignment,you can actually play\nthrough the level,you just make these\nchoices according to whatthe satisfying assignment is.", "start": 2400.0, "heat": 0.751}, {"text": "So either way it's equivalent.We always get a yes or\nno answer here wheneverwe get a corresponding yes or\nno answer to the 3SAT process.You also need to check that this\nreduction is polynomial size.It can be computed\nin polynomial time.So there's an issue.Given this thing, you have\nto lay this out in a gridand draw all these wires.And there's one\nproblem here, which is,these wires cross each other.And that's a little\nawkward, because these wiresare basically just long tunnels\nfor Mario to walk through.But what does it mean\nto have a crossing wire?Really, if Mario's\ncoming this way,I don't want them to\nbe able to go up here.He has to go straight.Otherwise this\nreduction won't work.So I need what's called\na crossover gadget.And everywhere here I have a\ncrossing, I have a crossover.And this gadget has\nto guarantee that Ican go through one\nway or the other way,but there's no leakage from\none path to the other path.Actually, if I first\ntraverse through here,and then I traverse through\nhere, it's OK if I leak back.Because once I visit a\nwire, it's kind of done.But I can't have leakage if\nonly one of them is traversed.So this is the last gadget, the\nmost complicated of them all.So this took a\nwhile to construct,as you might imagine.So this is what we call a\nunidirectional crossover.You can either go from left to\nright or from bottom to top,but you cannot go from bottom to\nright or bottom to left or leftto bottom, that kind of thing.So I'm told that\nMario is only goingto enter from here to here,\nbecause all of these wires,I can make one way wires.I only have to think about\ngoing in a particular direction.I can have falls to\nforce Mario to only goone way along these wires.And so let me show you\nthe valid traversals.", "start": 2520.0, "heat": 0.871}, {"text": "Maybe the simplest\none is from here.So let's say Mario\ncomes in here, falls.So I can't backtrack,\ncan jump up here.And then if Mario's big,\nhe can break this block,break this block.But if he's big--there should be a couple\nmore zig zags here.Let's try to run.You can crouch\nslide through here.But then you'll sort\nof lose your momentum,and you won't be able\nto go through allthese traversals as big Mario.So you can break these blocks\nand then get up to the topand leave.Or, if big Mario comes\nfrom over this way,you can first take a\ndamage, become small Mario.Then you can fit through\nthese wiggly blocks.But you cannot break blocks\nanymore as small Mario.So once you've committed\nto going small,you have to stay small,\nuntil you get to here.And then there's a\nmushroom in this block.So you can get big again, and\nthen you can break this blockand leave.But once you're big,\nyou can't backtrackbecause big Mario can't fit\nthrough these tiny tubes.See it clear, right?So slight detail, which\nis at the beginning,we need to make Mario big--\nso there's a little mushroom.I think they have three spots--at the beginning.And also at the\nend, there has to besomething like this that\nchecks that you actuallyhave a mushroom.So the only time you're\nallowed to take damageis briefly in this\ngadget you take damage.If you tried to backtrack,\nyou would get stuck.There's a long fall here.And then you have\nto get the mushroomso you can escape again.So at the end there's\nlike a mushroom check.Make sure you have it.So most of the\ntime Mario is big.And just in these\nlittle crossoversyou have to make\nthese decisions.This would make a\ngiant level, but itis polynomial size, probably\nquadratic or something.Therefore Super Mario\nBrothers is NP-hard.So if you want more\nfun examples like this,", "start": 2640.0, "heat": 0.76}, {"text": "you should check out 6.890, the\nclass I taught last semester,which has online video lectures,\nsoon to be on OpenCourseWare.So you can play with that.Any questions about Mario?All right, I hope you all play.So the next topic is\na problem you probablyhaven't heard about, three\ndimensional matching.This is a kind of a\ngraph theory problem.We're going to call\nit 3DM for short.And you've seen matching\nproblems based on flow.Matching problems are usually\nabout pairs of things.You're pairing them\nup, which you mightcall two dimensional matching.That can be solved\nin polynomial time.But if you change two to three\nand you're tripling things up,then suddenly the problem\nbecomes NP-complete.So it's a useful starting\npoint, similar to 3SAT.So you're given a\nset X of elements,a set Y of elements,\na set Z of elements.None of them are shared.But more importantly, you\nare given a bunch of triples.These are the allowable triples.So we'll call the set\nof allowable triples T.And so we're looking\nat the cross product.This is the set of all triples\nX, Y, and Z, or X is in X,Y is in Y, and Z is in Z. But\nnot all triples are allowed.Only some subset of\ntriples is allowed.And your goal is to choose\namong those subsets--", "start": 2760.0, "heat": 0.854}, {"text": "sorry, among those triples\na subset of the triples.So we're trying to\nchoose a subset Sof T such that every element--so the things in X, Y,\nand Z are called elements.So I'm just taking\nsomebody in the union XYZ.It should be in exactly\none triple s in big S.This is a little weird, but\nyou can think of this problemas you have an alien\nrace with three genders--male, female, neuter I guess.Those are the X, Y, and Z's.There's an equal number of each.And every triple reports\nto you whether thatis a compatible matching.Who knows what they're\ndoing, all three of them?So you're told up front--you take a survey.There's only n cubed\ndifferent triples.For each of them they\nsay, yeah, I'd do that.So you were given that subset.And now your goal is to\npermanently triple upthese guys.And everybody wants to\nbe in exactly one triple.So it's a monogamous\nrace, imagine.So everybody wants to be put\nin one triple, but only onetriple.And the question is,\nis this possible?This is three\ndimensional matching.Certainly not always going to be\npossible, but sometimes it is.If it is, you want\nto answer yes.If it's not possible,\nyou want to answer no.This problem is NP-complete.Why is it in NP?Because I can basically guess\nwhich elements of T are in S.There's only at most\nn cubed of them.", "start": 2880.0, "heat": 0.818}, {"text": "So for each one, it\nis guess yes or no,is that element of T in S?And then I check whether this\ncoverage constraint holds.So it's very easy to\nprove this is in NP.The challenge is to\nprove that it's NP-hard.And we're going to do that,\nagain, by reducing from 3SAT.So we're going to make\na reduction from 3SATto three dimensional matching.Direction is important.Always reduce from the\nthing you know is hardand reduce to the thing\nyou don't know is hard.So again, we're given a formula.And we want to\nconvert that formulainto an equivalent three\ndimensional matching input.So the formula has\nvariables and clauses.For each variable,\nwe're going to builda gadget that looks like this.And for each clause we're\ngoing to build a gadget.So here's what they look like.If we have a variable x1,\nwe're going to convert thatinto this picture.Stay monochromatic for now.Looks pretty crazy at the\nmoment, but it's not so crazy.This is not supposed\nto be obvious.You have to think for a while.", "start": 3000.0, "heat": 0.82}, {"text": "It's a puzzle to figure\nout this kind of thing.But I call this thing a variable\ngadget because locally--so there's basically a\nwheel in the center here.And then there's\nthese extra dotsfor every pair of dots,\nconsecutive pairs of dotsin a wheel.And what I've drawn is the set\nof triples that are allowed.There's tons of other\ntriples which are forbidden.The triples that are\nin T are the onesthat I draw as little triangles.And two color them because\nthere are exactly two waysto solve this gadget locally.Now these dots are going to\nbe connected to other gadgets.But these dots only exist\nin this gadget, which meansthey've got to be covered.They've got to be\ncovered exactly once.So either you choose\nthe blue triangles,or you choose the red triangles.Each of them will exactly\ncover each of these guys once.You cannot mix and\nmatch red and blue,because you either get overlap\nif you choose two guys thatshare a point, or\nyou'd miss one.If I choose like this\nblue and this red,then I can't cover this\npoint because both of thesewould overlap those two.And over here you have to\nchoose disjoint triples.They can't overlap at all.And everybody has\nto get covered.So just given those\nconstraints, locally youcan see you have to\nchoose red or blue.Guess what?One of them is true,\nthe other one is false.Let's say that red is\ntrue and blue is false.In general, when you're trying\nto build a variable gadget,you build something\nthat has exactlytwo solutions, one representing\ntrue, one representing false.Now how big do I\nmake this wheel?Big enough.You could make it as big\nas the number of clauses.I'm going to make\nit into two and x1.So wheel-- and this number\nis the number of occurrencesof x1 in the formula.", "start": 3120.0, "heat": 0.43}, {"text": "So this is the number of clauses\nthat contain either xi or xibar.That's in xi.I'm going to double that.Because what I get over\nhere is basically xibeing true for those guys.Actually, yeah,\nthat's actually right.It looks backwards.And false for these guys.One way or the other,\nwe'll figure it out.So in order for xi to appear\nin, say, five different clauses,I want five of the true things\nand five of the false things.And so I need to double\nin order to get--potentially I have twice\nas many as I actually need,but this way I'm guaranteed\nto have false or true,whichever I need.In reality I have\nsome true occurrences.I have some false occurrences,\nsome x1's, some x1 bars.This will guarantee that I have\nenough of these free pointsto connect into\nmy clause gadgets.How do I do a clause gadget?It's actually really easy.So these would be pretty\nboring by themselves.So a clause always\nlooks like this.Maybe there's some negations.Yeah, let's do\nsomething like that.I'm going to convert it\ninto a very simple picture.It's going to be xi dot,\nand xj bar dot, and xk dot.And then-- well maybe I'll\nstick to these colors.", "start": 3240.0, "heat": 0.426}, {"text": "Again, these two points only\nappear in this clause gadget.These dots are\nactually these dots.So there's one of\nthese pictures for x1.There's another one for x2, x3.And so xi has one\nof these wheels.I want this dot to be one\nof these dots of the wheel.And then I want\nthis dot to be oneof the dots in the xj wheel\nwith the false setting, oneof the red dots.I want this one to be xk\ntrue setting in the xk wheel.So these things are\nall connected togetherin a complicated pattern.But the point is that\nwithin this gadget,I only have three\nallowed triples.And these points only\nappear in this gadget,which means they have to\nbe covered in this gadget.They can be covered\nby this tripleor this triple or this triple.But once you choose one,\nyou can't choose the others.What this means is if\nI set x1 to be true,it leaves behind these\npoints marked true.If I choose the red\nthings, then it'sthe blue points that\nare left behind.Leaving points\nbehind in this caseis going to be good,\nbecause this clause,in order to satisfy\nthis clause, in orderto choose one of these three\ntriples, at least one of thesemust be left behind\nby the wheel.If all of these are\ncovered by their wheels,then there's no way.I can't choose\nany of these guys.But if at least one of these\nis left behind by the wheel,then I can choose the\ncorresponding tripleand cover these points.So I'll be able to cover\nthese points if and onlyif at least one\nof these is true.And that's a clause.That's what a clause is\nsupposed to do in 3SAT.If at least one\nof these is true,then the clause is satisfied.I need all the clauses\nto be satisfiedbecause I need to cover\nof these points for allthe instances of these clauses.And that's how it works.Now, slight catch.If you do this,\nnot all the pointswill be covered, even so.", "start": 3360.0, "heat": 0.472}, {"text": "Maybe all of these are true.And so they're all left behind.And I can only cover one\nof them with the clause.It's a little messy.You need another gadget, which\nis called garbage collection.I don't want to spend\ntoo much time on it.But you have two dots.And then you have\nevery single xi--these dots, all\ntrue and false dots.And you're going to\nhave this triple,and this triple, and this\ntriple, and this triple,and so on.It looks an awful\nlot like a clause.But this is like a clause\nthat's connected to everybodyin the entire universe.And you repeat this\nthe appropriate numberof times, which is\nsomething like sum of nxminus the number of clauses.OK, why?Because if you\nlook at a wheel, ithas size 2 times nx\nfor a variable x.And half of the points\nwill be left uncovered.So that means nx of\nthem will be uncovered.Then the clause, if everything\nworks out correctly,the clause will cover\nexactly one of those points.So for each clause we\ncover one of the points.That means this\ndifference is exactly howmany points are left uncovered.And so we make this gadget\nexactly that many times.And it's free to cover anybody.So whatever is left over,\nthis garbage collectorwill clean up.And if we use exactly\nthe right number of them,this garbage collector won't\nrun out of things to collect.", "start": 3480.0, "heat": 0.589}, {"text": "So this makes the proof messy.But I want to move on to\nsomewhat simpler proofsand for other problems.Yeah?AUDIENCE: Real quick,\nwhat about the t or fpoints that we didn't cover\nbecause we didn't actuallyneed that many?ERIC DEMAINE: Right.So this also includes the points\nthat weren't even connectedto clauses.I think this is the right\nnumber no matter what,because this is counting the\ntotal number of uncovered guys,whether they're connected\nto clauses or not.Each clause will, in\na satisfied situation,it will cover exactly\none of those points.The ones that are\nconnected to the clauseswon't be covered at\nall, but that will stillbe in this difference.So yeah, it's good\nto check that.The first time I wrote this\ndown I forgot about those pointsand got it wrong.But I think this is\nright, hopefully.I did not come up\nwith this proof.Garey and Johnson I think--or no.This is-- I forgot.Yeah, this is a Garey\nand Johnson proof.There's a cool book from the\nlate '70s by Garey and Johnson,does a lot of NP-completeness,\nif you're curious.All right, so\nhopefully you believethree dimensional\nmatching is hard.Now I'm going to use it to prove\nthat some very different typesof problems are hard.This is a kind of\ngraph theory problem.You'll see more graph theory\nproblems in recitation.This one, I can\nerase 3SAT and Mario.So in the world, most\nNP-hardness proofsare reductions from 3SAT,\nor some variation of 3SAT.In some sense, you can think\nof three dimensional matchingas kind of like a\nversion of 3SAT,but it's a little\nbit more stringent.And that stringency helps\nus to do other reductions.So here's another\nproblem where we'llreduce from three\ndimensional matching.It's called subset sum.", "start": 3600.0, "heat": 0.758}, {"text": "So you're given n\nintegers, a1 up to an.And you're given a target\nsum, also an integer.Call it t.What you'd like to know is, is\nthere a subset of the integersthat adds up to that target.Can you choose a sum of\nthe integers so that--I'll write it the\nsum of S. But whatthis means is the sum over the\nai's that are in S of the valueai.I want that to equal t.So this is the definition.This is the constraint.So I give you a\nbunch of numbers.Do any subset of\nthem add up to t?That's all this is asking.This problem is NP-hard.It's NP-complete, in fact, when\nyou can guess which integersshould go in the subset,\nand then add them upto see if you got it right.It is NP-hard, but\nit's something specialwe call weakly NP-hard.And why don't I come back to the\ndefinition of that in a moment?Let me first show you the proof.It's actually really easy\nnow that we have this threedimensional matching problem.It's pretty cool.So these numbers are\ngoing to be huge.What we're going to\nsay is, let's view--so again, we're given a three\ndimensional matching instance.Get the directions, right?We're given a set of triples.We want to solve this problem\nby reducing it to a subset sum.So we get to construct integers\nthat represent triples.", "start": 3720.0, "heat": 0.851}, {"text": "That's what we're going to do.So here we go.We get to choose a number.So I'm going to think of\nthem in a particular base, b,which is going to be 1\nplus the max of the mxi's.So again, this is the number\nof occurrences of variable xiin a true or false form.So I take the maximum occurrence\nof any variable, add 1.That's my base.It just has to be large enough.And this is basically the\nentire reduction, is one line.If I have three triples--if I have a triple\nxi, xj, xk, I'mgoing to convert that into a\nnumber that looks like thiswhere the one positions are--I don't really know the order,\nbut they are i, j, and k.Everything else is zero.And this is in\nbase b, not base 2.It's a little weird.All my digits are 0 or\n1, but I'm in base b.And three of the digits are 1.And the rest are zero.Why?Because of my target sum.Target sum is going\nto be 1111111111.So this number,\nin algebra, you'rewrite this as b to the i plus\nb to the j plus b to the k.This you would write as the\nsum of b to the i for all i.Do you see why this works?It's actually really simple.For this instance,\nmy goal is to choosea subset of these numbers\nthat add up to this number.How could that possibly happen?Well, I've got to choose--", "start": 3840.0, "heat": 0.459}, {"text": "every time I choose\none of the numbers,those three digits get\nset to 1 in my sum.If I ever have a collision,\nif I add two 1s together,I'm going to get a 2.That's not good,\nbecause once I get a 2,I'll never be able\nto get back to a 1,because my base is really big.This base is designed\nso that the total-- thisis the total number\nof colliding 1s.So we set it one\nlarger than that,which means you'll never get\na carry when you're adding upin this base.That's why I set the base to\nbe something large, not base 2.Base 2 might work, but\nthis is much safer.So what that means is for each\nof these 1s in the target sum,I've got to find a\ntriple that has those 1s.And those triples can't overlap.So that means choosing a set\nof numbers that add up to thisis exactly the same as\nchoosing a set of triples thatcovers all of the elements.Done, super easy once you\nhave the right problem.OK, good.Now why do I call\nthis weekly NP-hard?Because these numbers are giant.If I have n elements\nin X, Y, Z over there--I guess here they're\ncalled xi, yk, zk.Sorry, maybe I should've\ncalled them that here.Doesn't matter.If I have n of those elements\nin X union Y union Z,the number of digits here is n.So the number of\ndigits in order n.This is fine from an\nNP-completeness standpoint.This is polynomial size.The number of digits in my\nnumbers is a polynomial.And this base is\nalso pretty small.So if you wrote\nit out in binary,it would also be polynomial.So just lost a log factor.", "start": 3960.0, "heat": 0.595}, {"text": "But the size of the numbers, the\nactual values of the numbers,is exponential.With weak NP-hardness,\nthat's allowed.With strong NP-hardness,\nthat's forbidden.In strong NP-hardness, you\nwant the values of the numbersto be polynomial.So in this case, the\nnumber of bits is small,but the actual values\nare giant, because youhave to exponentiate.It would be cool.And this problem is\nonly weakly NP-hard.Maybe you actually know\na pseudo-polynomial timealgorithm for this.It's basically a knapsack.If these numbers have polynomial\nvalue, then you can basically,in your subproblems in\ndynamic programming,you can write down\nthe number t and justsolve it for all values of t.And it's easy to solve\nit in polynomial time,polynomial in the\ninteger values.So we call that\npseudo-polynomial, because it'snot really polynomial.It's not polynomial in\nthe number of digitsthat you have to\nwrite down the number.It's Polynomial in the values.Weak NP-hardness goes together\nwith pseudo-polynomial.That's kind of a matching\nresult. Say look,pseudo-polynomial is\nthe best you can do.You can't hope for a\npolynomial because if youlet the numbers get huge, then\nthe problem is NP-complete.But if you force the numbers to\nbe small, this problem is easy.So subset sum is a little\nfunny in that sense.Cool.", "start": 4080.0, "heat": 0.483}, {"text": "Let me tell you about\nanother problem, partition.So partition is pretty\nmuch the same set up.I'm given n integers.Let's say they're positive.And I want to know,\nis there a subset--I'm not given a target sum t.Target sum is basically forced.What I would like is the\nsum of all the values in Sto equal the sum\nof all the valuesnot in S. That's A minus\nS, which in other wordsis going to be the sum of\nall values in A divided by 2.So this is called partition\nbecause you're taking a set,you're splitting it into\ntwo halves of equal sum.Every element has to go\nin one of the two halves.And they're called S and A minus\nS, like cuts in the flow stuff.And you want those\ntwo halves to haveexactly the same\nsum, which means theywill be the sum divided by 2.So that better be\neven, otherwiseit's not going to be possible.So again, you want to\ndecide whether thisis possible or\nimpossible, yes or no.I claim this problem is\nalso weakly NP-complete,and we can reduce from\nsubset sum to partition.This is a little interesting\nbecause partition is actuallya special case of subset sum.It is the case\nwhere t equals this.Subset sum, you're trying to\nsolve it no matter what t is.t is a given input.So there's more\ninstances over here.", "start": 4200.0, "heat": 0.261}, {"text": "Some of them, some\nof these instancesare the case where t\nequals the sum over 2.Those are partition instances.So this is like a subset\nof the possible inputsas over there, which\nmeans this problem iseasier than this one--no harder anyway.In other words, I can reduce\npartition to subset sum.I just compute this\nvalue and set that to t,and then leave the a's alone.That will reduce\npartition to subset sum.But that's not the\ndirection I want.I want to reduce from subset\nsum, a problem I can proveis NP-complete, to\npartition, because Iwant to prove that\npartition is NP-complete.So in this case, there's an easy\nreduction in both directions.This direction is\na little harder.So reduction from subset sum.So I'm given a bunch of ai's.I'm not going to touch them.And I'm given a target sum t.And I basically want to make\nthat target sum into this half.To do that, I'm going to\nadd two numbers to my set.So I'm going to let sigma\nbe the sum of the given a's.And then I'm going to add--so I'm given a1 through an.I'm going to add an plus 1,\nis going to be sigma plus t.And I'm going to add an plus\n2 to be 2 sigma minus t.Why?So these are two\nbasically huge numbers.Because sigma is bigger than--I mean, it's the sum\nof all the numbers,so it's bigger than all of them.And so imagine for\na moment that Iput these two in the same\nside of the partition.", "start": 4320.0, "heat": 0.147}, {"text": "I put them both in S\nor I put them both outof S. Their sum by\nthemselves is 3 sigma.The t's cancel.Whereas all the other\nitems, their sum is sigma.So I'm host.If I have 3 sigma on one\nside and sigma on the other,I'm not going to\nmake them equal.So in fact, these two elements\nhave to be on opposite sides.So there's a side\nthat has sigma plus t.There's a side has\n2 sigma minus t.And then there's all the other\nn items, and some of themare going to go to\nthis side, some of themare going to go to this side.Their total value is sigma.Right now this is\nclose to sigma.This is close to 2 sigma.So they have to kind\nof meet in the middle.In fact, what you'll have to do\nis add sigma minus t over hereand add t over here.Think about it for a second.If I add sigma minus t,\nthis comes out to 2 sigma.If I add t to this, this\ncomes out to 2 sigma.That would be good\nbecause they're equal.And notice that this\nis sigma minus t.This is t.Their sum is sigma.So in fact, it has\nto be like this.You add something over here, and\nsigma minus something over herefor all the other ai's.And the something has to be t\nin order for these two valuesto equalize.So in order to solve this\nslightly larger partitionproblem, you have to actually\nsolve the subset sum problembecause you have to construct\na subset that adds up to t.t was an arbitrary given value.So this is pretty nifty.We're adding some values so that\nthe new target sum is the 50/50split when we're\ngiven some values thathave an arbitrary target sum.So partition is\nweakly NP-complete.Let me go to rectangle packing.", "start": 4440.0, "heat": 0.185}, {"text": "So rectangle packing--I'm going to draw a picture.I give you a bunch of\nrectangles of varying sizes.And I give you a\ntarget rectangle.Let's call it T.\nThese are the Ri's.I want to put these\nrectangles into this picturewithout any overlaps.Each of these rectangles\nhere corresponds to oneof the rectangles over here.So I'll tell you that the sum\nof the areas of these rectanglesis equal to the area of T.\nAnd the question is, can youpack those rectangles into\nT without any overlaps,and therefore without any gaps,\nbecause the areas are exactlythe same.I claim this problem\nis weakly NP-hard--I guess NP-complete by\nreduction from partition.This will be super easy\nif you followed whatthe definition of partition is.We're given some integers ai.And we're going to take each of\nthem and convert them into a,let's say, 1 by 3ai rectangle.Three is to avoid some\nrotation we'll see.And then we're also\ngiven the targets.Oh no, target sum is given.Target sum is the sum over 2.But anyway, we're going to build\nour target rectangle to be--", "start": 4560.0, "heat": 0.239}, {"text": "it's actually going\nto be really big.It's going to be 2 by 3 times t.So this is that thing.So this is 3/2 sum of the a's.OK, that's about it.In order to pack these\nrectangles into here,because each of them\nis at least three long,you cannot pack them vertically.They have to be horizontal.So in fact what your\npacking will look like isthey'll be the top half\nand the bottom half.And the top half, the total\nlength of those rectangleshas to add up to 3/2 sum of A.\nEverything was scaled up by 3,so that's 1/2 of A on\nthe top and the bottom.That's a partition.In order to pack the\nrectangles into here,you have to solve the partition\nproblem, and vice versa.Easy.OK, let me show you one\nmore thing, jigsaw puzzles.This is not the jigsaw puzzles\nyou grew up on, somewhat moregeneralized.So a piece is going to\nlook something like this.I drew them\nintentionally different.So on each, you\nhave a unit square.Some of the sides can be flat.Some of them can be tabs.Some of them can be pockets.Each tab and pocket has a shape.And they're not in a perfect\nmatching with each other.So there could be\nseven of these tabsand seven of these pockets,\nall the same shape.This is what you might call\nambiguous jigsaw puzzles.Plus, there is no\nimage on the piece,so this is like\nhardcore jigsaw puzzles.", "start": 4680.0, "heat": 0.218}, {"text": "This is NP-complete.And what I'd like to do\nis to simulate a rectanglewith a bunch of jigsaw pieces.So it would look\nsomething like this.If I have a 1 buy\nsomething rectangle,I'm going to simulate it\nwith that same something,little jigsaw pieces.And I'm going to make these\nshapes only match each other.And so for every\nrectangle, they'regoing to have a different shape.This one will be squares.At that point I ran out of\nshapes I can easily draw,but you get the idea.Each rectangle has\na different shape.And so these have to\nmatch to each other.You can't mix the\ntiles, which means youhave to build this rectangle.You have to build\nthis rectangle.And then if the jigsaw\nproblem is, can youfit these into a\ngiven rectangle,then you get rectangle packing.But this is not a\nvalid reduction.You can't reduce from partition.Why?Because these numbers are huge.Remember, the values of\nthe numbers in my partitioninstance are exponential.So if I have a value ai and it's\nexponential in my problem size,and I tried to make\nai have little tiles,that means a number\nof jigsaw pieceswill be exponential in n.That's not good.That's not allowed.This is why weak\nNP-hardness is annoying.So instead, we need a\nstrong NP-hard problem.", "start": 4800.0, "heat": 0.166}, {"text": "This is a problem\nthat's NP-hard even whenthe numbers are polynomial\nin value, not just in size.And it's called 4-partition.4-partition, you're given\nn integers, as usual.Say set is A. And you want\nto split those integersinto n over 4 quadruples\nof the same sum.So this would be the sum of\nA divided by n over four.That's your target sum.So before we had to\nsplit into two parts thathad the same sum.That was partition.Now we have to split\ninto n over 4 parts.Each part will have exactly\nfour numbers, four integers.And they should all\nhave the same sum.This problem is hard\neven when the integershave polynomial value.So the values are at most\nsome polynomial in n.I won't prove it here, but\nit's in my lecture notesif you're curious.It's like this\nproof, but harder.You end up, instead of\nhaving n digit numbers,you have five digit numbers.Each digit only has a polynomial\nin n different values.So the total value of the\nnumbers is only polynomial.It's like n to the\nfifth or something.Good news is that\nthis reduction I justgave you is also a\nreduction from 4-partitionbecause it's the same set up.Again, I'm given integers.", "start": 4920.0, "heat": 0.258}, {"text": "Each integer I'm going to\nrepresent by that many tiles.Now the number of tiles\nis only polynomial,so this is a valid reduction.And again, if I have to\npack all of these tilesinto a rectangular board,\nthat's exactly the sameas packing these integers.Well, I guess I should do\nrectangle packing again.So this is a proof rectangle\npacking was weakly NP-hard.But in fact it's\nstrongly NP-hard.You just change\nthese dimensions.You say well, I need whatever,\nn over 4 different parts, eachof size the sum over n over 4.You need some scale factor here.Three doesn't work.Use n or something--n and n.That will prove that\nrectangle packing is actuallystrongly NP-hard because\nwe're reducing for 4-partitioninstead of partition.And then you can reduce\nrectangle packingto jigsaw puzzles because you\nhave strong hardness over here.Over here we don't have numbers.We just have these pieces.So whenever you convert\nfrom a number problemto a non-number problem, if\nyou're representing the numbersin unary, which is\nwhat's going on here,you need strong\nNP-hardness for it to work.Weak NP-hardness isn't enough.Then we get jigsaw puzzles,\nwhich we know and love,are NP-complete.That's it.", "start": 5040.0, "heat": 0.204}]