[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Quick, quick recap\nof what we did last time.So last time we introduced\nthis idea of decompositionand abstraction.And we started putting\nthat into our programs.And these were sort of\nhigh level concepts,and we achieved them using\nthese concrete things calledfunctions in our programs.And functions\nallowed us to createcode that was coherent, that\nhad some structure to it,and was reusable.OK.And from now on in problem\nsets and in lectures,I'm going to be using\nfunctions a lot.So make sure that you\nunderstand how they workand all of those details.So today, we're going to\nintroduce two new data types.And they're called\ncompound data types,because they're actually\ndata types that are made upof other data types,\nparticularly ints, floats,Booleans, and strings.And actually not just these,\nbut other data types as well.So that's why they're\ncalled compound data types.So we're going to\nlook at a new datatype called a tuple and a\nnew data type called a list.And then we're going to\ntalk about these ideas thatcome about with--\nspecifically with lists.All right.So let's go right into tuples.So if you recall\nstrings, stringswere sequences of characters.Tuples are going to be similar\nto strings in that they'regoing to be sequences\nof something,except that tuples aren't\njust sequences of characters,they can be sequences\nof anything.They're a collection\nof data wherethat data can be of any type.", "start": 0.0, "heat": 0.1}, {"text": "So a tuple can contain\nelements that are integers,floats, strings, and so on.Tuples are immutable.And if you recall, we talked\nabout this word a little bitwhen we talked about strings.So that means once you\ncreate a tuple object,you can't modify it.So when you created\na string object,you were not allowed\nto modify it.So the way we create tuples\nare with these open and closeparentheses.This shouldn't be\nconfused with a function,because there's\nnothing-- there's no--this isn't a function call.It's just how you\nrepresent a tuple.For a function call,\nyou'd have something rightbefore the parentheses.This is just how we chose\nto represent a tuple.And just a plain open\nand close parenthesesrepresents an empty tuple.So it's of length 0.There's nothing in it.You can create a\ntuple that containssome elements by separating\neach element with a comma.So in this case,\nthis is a tuple thatcan be accessed with a variable\nt that contains three elements.The first is an integer,\nthe second is a string,and the third is\nanother integer.Much like strings, we can\nindex into tuples to find outvalues at particular indices.So you read this\nas t at position 0.So the tuple represented by\na variable t at position 0will evaluate to 2,\nbecause again, westart counting from 0\nin computer science.So that brings us-- gives\nus the first element.Just like strings, we can\nconcatenate tuples together.That just means\nadd them together.So if we add these\ntwo tuples together,we just get back\none larger tuplethat's just those two-- the\nelements of those tuplesjust put together\nin one larger tuple.", "start": 120.0, "heat": 0.167}, {"text": "Again, much like strings,\nwe can slice into tuples.So t sliced from\nindex 1 until index 2.Remember, we go until\nthis stop minus 1.So this only gives us one\nelement inside the tuple.And this is not a mistake.This extra comma here actually\nrepresents a tuple object.If I didn't have\nthis comma here,then this would\njust be a string.The parentheses would\njust-- wouldn't reallymake any difference.But the comma here\nmakes it clear to Pythonthat this is a tuple with\nonly one element in it.We can slice even further to\nget a tuple with two elements.And we can do the\nusual operationslike get the length of a tuple,\nwhich says, how many elementsare in my tuple?And len of this t\nwould evaluate to 3,because there are three\nelements inside the tuple.Each element, again,\nseparated by the comma.And just like strings,\nif we try to changea value inside the\ntuple-- in this case,I wanted to try to change the\nvalue of the second elementto 4-- Python\ndoesn't allow that,because tuples are immutable.So why would we\nwant to use tuples?Tuples are actually useful in a\ncouple of different scenarios.So recall a few years ago,\nwe looked at this codewhere we tried to swap the\nvalues of variables x and y.And this first code\nactually didn'twork, because you're\noverwriting the value for x.So instead, what\nwe ended up doingwas creating this\ntemporary variablewhere we stored the value of\nx, and then we overwrote it,and then we used the\ntemporary variable.Well, turns out this\nthree liner code righthere can actually be written\nin one line using tuples.So you say x comma y\nis equal to y comma x.", "start": 240.0, "heat": 0.215}, {"text": "And Python goes in and\nsays, what's the value of y?And assigns it to x.And then what's the value of x?And assigns it to y.Extending on that,\nwe can actuallyuse tuples to return more than\none value from a function.So functions, you're only\nallowed to return one object.So you're not allowed to\nreturn more than one object.However, if we use\na tuple object,and if that's the\nthing that we return,we can actually get\naround this sort of ruleby putting in as\nmany values as wewant inside the tuple object.And then we can return as\nmany values as we'd like.So in this specific\nexample, I'm tryingto calculate the\nquotient and remainderwhen we divide x by a y.So this is a function\ndefinition here.And down here I'm calling\nthe function with 4 and 5.So when I make\nthe function call,4 gets assigned to x and\n5 gets assigned to y.So then q is going to be\nthe integer division whenx is divided by y.And this double\nslash just means--it's like casting the\nresult to an integer.It says divide it, keep\nthe whole number part,and just delete everything\nelse beyond the decimal point.So when you divide\n4 by 5, this qis actually going to be 0,\nbecause it's 0 point something,and I don't care about\nthe point something.And then the remainder is just\nusing the percent operator.So I divide 4 by 5, the\nremainder is going to be 4.And notice that I'm\ngoing to be returningq and r, which are these\ntwo values that I calculatedinside my function.And I'm returning them in\nthe context of this tuple.So I'm only returning one\nobject, which is a tuple.", "start": 360.0, "heat": 0.33}, {"text": "It just so happens that\nI'm populating that objectwith a few different values.So when the function\nreturns here,this is going to say 0 comma 4.That's the tuple\nit's going to return.Q is going to be 0 and\nr is going to be 4.So then this line\nhere-- quot, remequals 0, 4-- is\nbasically this--it's sort of like\nwhat we did up here.So it assigns quot to 4-- sorry.Quot to 0 and rem to 4.So we can use tuples.This is very useful.We can use them to return more\nthan one value from a function.So tuples are great.Might seem a little\nbit confusing at first,but they're actually\npretty useful,because they hold\ncollections of data.So here, I wrote\na function whichI can apply to any set of data.And I'll explain what\nthis function does,and then we can apply\nit to some data.And you can see that you\ncan extract some very basicinformation from whatever\nset of data that youhappen to collect.So here's a function\ncalled get_data,and it does all of\nthis stuff in here.And in the actual code\nassociated with the lecture,I actually said what the\ncondition on a tuple was.So it has to be a\ntuple of a certain--that looks a certain way.And this is the\nway it has to look.So it's one tuple.The outer parentheses out\nhere represent the factthat it's a tuple.And the elements of this tuple\nare actually other tuples.So the first element\nis a tuple object,the second element\nis a tuple object,and third one is a\ntuple object, and so on.And each one of these\ninner tuple objectsare actually going to\ncontain two elements,the first being an integer\nand the second being a string.So that's sort of\nthe preconditionthat this function\nassumes on a tuple", "start": 480.0, "heat": 0.35}, {"text": "before it can-- before\nit actually can work.All right.So given a tuple\nthat looks like that,what's the function going to do?It's first creating\ntwo empty tuple.One is called nums and\none is called words.And then there's a for loop.And notice here the for loop\nis going to iterate overevery element inside the tuple.Remember in strings when we\nwere able to use for loops thatiterated over the characters\ndirectly as opposedto over the indices?Well, we're doing the\nsame sort of thing here.Instead of iterating\nover the indices,we're going to iterate over the\ntuple object at each position.So first time through\nthe loop, t hereis going to be this first tuple.The second time\nthrough the loop, tis going to be this tuple.And the third time, it's going\nto be this exact tuple object.So each time through\nthe loop, what I'm doingis I'm going to have\nthis nums tuple that I'mgoing to keep adding to.And each time I'm going\nto create a new objectand reassign it to\nthis variable nums.And each time\nthrough the loop, I'mlooking at what the\nprevious value of nums was.So what was my previous tuple?And I'm going to add it\nwith this singleton tuple.So it's a tuple of one\ncharacter or one element.This element being\nt at position zero.So you have to sort of\nwrap your mind aroundhow this is working.So if t is going to be this\ntuple element right here,then t at position zero is\ngoing to be this blue bar here.So it represents the integer\nportion of the tuple.So as we're going\nthrough the loop,this nums is going to\nget populated with allof the integers from\nevery one of my tuple--inside tuple objects.So that's basically what\nthis line here is doing.", "start": 600.0, "heat": 0.346}, {"text": "At the same time, I'm also\npopulating this words tuple.And the words tuple is\na little bit different,because I'm not adding every\nsingle one of these stringobjects.So t at position one being the\nstring part of the inner tuple.I'm actually adding the string\npart only if it's not alreadyin my words list.So here, I'm\nessentially grabbingall of the unique\nstrings from my list.These last sort of three\nlines-- three, four lines herejust do a little bit of\narithmetic on it saying,OK, now I have\nall of the numbershere, what's the minimum\nout of all of these,and then what's the maximum\namount of all these?And then this unique\nwords variabletells me how many unique words\ndo I have in my original tuple.So this feels sort of generic,\nso let's run it on some data.So here I have it-- I\ntested it on some test data.And then I got some actual data.And this actual data\nthat I wanted to analyzewas Taylor Swift data.And representing\nthe integer portionof the tuple representing a\nyear and the string portionof the tuple representing\nthe person who shewrote a song about that year.So some real world data that\nwe're working with here.Very important that we\nknow this information.OK.So with this data,\nI can run it--I can plug it into this\nfunction that I wrote up here.And I'm going to actually\ncomment this out,so it doesn't get cluttered.And if I run it--\nthis is the partwhere I'm calling my function.", "start": 720.0, "heat": 0.378}, {"text": "I'm calling it with\nthis data here.tswift being this\ntuple of tuples.And what I get\nback is-- up here,line 38-- is the return from the\nfunction being a large tuple.And that large tuple,\nI'm then assigning itto my own tuple in my program.And then I'm just writing out--\nprinting out some statementhere.So I'm getting the minimum\nyear, the maximum year,and then the number of people.So I can show you that\nit works if I replaceone of these names\nwith another onethat I already have in here.So instead of writing a\nsong about five people,she would have wrote a\nsong about four people.Yay, it worked.So that's tuples.And remeber or recall-- keep\nin mind, tuples were immutable.Now we're going to look at\na very, very similar datastructure to tuples\ncalled lists,except that instead of\nlists being immutable,lists are going to\nbe mutable objects.So much like lists,\nthey're goingto contain elements of any\ntype or objects of any type.You denote them with--\nyou denote a listwith square brackets\ninstead of parentheses.And the difference\nbeing that they'regoing to be immutable\nobjects instead of immutable.So creating an\nempty list, you justdo open close square brackets.You can have a list of\nelements of different types,even a list of lists.So one of the\nelements being a list.As usual, you can\napply length on a list,and that tells you how\nmany elements are in it.This is going to tell\nyou how many elementsare in your list l.So it's not going to look\nany further than that.So it's going to say, this is\nan integer, this is a string,", "start": 840.0, "heat": 0.337}, {"text": "this is an integer,\nthis is a list.It's not going to say how many\nelements are in this list.It's just going to look at the\nouter-- the shell of elements.Indexing and slicing\nworks the same way.So l at position 0\ngives you the value 2.You can index into a list,\nand then do somethingwith the value\nthat you get back.So l at position 2 says--\nthat's this value thereand add one to it.L at position 3, that's\ngoing to be this list here.Notice it evaluates\nto another list.You're not allowed\nto index outsideof the length of the list.So that's going to give you\nan error, because we onlyhave four elements.And you can also have\nexpressions for your index.So this-- Python just replaces\ni with 2 here and says,what's l at position 1?And then grabs\nthat from in there.OK.So very, very similar to\nthe kinds of operationswe've seen on\nstrings and tuples.The one difference,\nand that's whatwe're going to focus on\nfor the rest of this class,is that lists are\nmutable objects.So what does that\nmean internally?Internally, that means\nlet's say we have a list l,and we assign it-- sorry.Let's say we have a variable l\nthat's going to point to a listwith three elements,\n2, 1, and 3.OK.They're all-- each\nelement is an integer.When we were dealing with\ntuples or with strings,if we re-assign-- if we try\nto do this line right here,we've had an error.But this is actually\nallowed with lists.So when you execute\nthat line, Pythonis going to look at\nthat middle element,and it's going to change\nits value from a 1 to a 5.And that's just due to the\nmutability nature of the list.So notice that this list\nvariable, this variable l,", "start": 960.0, "heat": 0.262}, {"text": "which originally\npointed to this list,points to the exact same list.We haven't created a\nnew object in memory.We're just modifying the\nsame object in memory.And you're going to see\nwhy this is importantas we look at a few\nside effects thatcan happen when you have this.So I've said this a\ncouple of times before,but it'll make your\nlife a lot easierif you try to think\nof-- when you wantto iterate through a list if\nyou try to think about iteratingthrough the elements directly.It's a lot more Pythonic.I've used that word before.So this is sort of\na common patternthat you're going to see where\nyou're iterating over the listelements directly.We've done it over tuples.We've done it over strings.So these are identical codes.They do the exact same\nthing, except on the left,you're going from-- you're going\nthrough 0, 1, 2, 3, and so on.And then you're indexing into\neach one of these numbersto get the element value.Whereas on the right,\nthis loop variable iis going to have the\nelement value itself.So this code on the\nright is a lot cleaner.OK.So now let's look\nat some operationsthat we can do on lists.So there's a lot more\noperations that wecan do on lists, because\nof their mutability aspectthan we can do on tuples\nor strings, for example.So here's a few of them.And they're going\nto take advantageof this mutability concept.So we can add elements\ndirectly to the endof the list using this funky\nlooking notation L.append.And then the element we\nwant to add to the end.And this operation\nmutates the list.", "start": 1080.0, "heat": 0.365}, {"text": "So if I have L is\nequal to 2, 1, 3, and Iappend the element\n5 to the end, thenL-- the same L is going to\npoint to the same object,except it's going to have\nan extra number at the end.5.But now what's this dot?We haven't really\nseen this before.And it's going to\nbecome apparentwhat it means in a\nfew lectures from now.But for the moment,\nyou can thinkof this dot as an operation.It's like applying a function,\nexcept that the functionthat you're applying\ncan only workon certain types of objects.So in this case,\nappend, for example,is the function we're\ntrying to apply.And we want to\napply it to whateveris before the dot,\nwhich is the object.And append has only been defined\nto work with a list object,for example, which is why we're\nusing the dot in this case.We wouldn't be able to\nuse append on an integer,for example, because\nthat sort of functionis not defined on the integer.So for now, you'll sort\nof have to remember--which are functions\nthat work with a dotand which are functions\nlike [? ln, ?] thataren't with a dot.But in a couple of lectures, I\npromise it'll be a lot clearer.So for now, just think\nof it as whateveris before the dot is the object\nyou're applying a function to,and whatever is after the\ndot is the function you'reapplying on the object.So we can add things\nto the end of our list.We can also combine\nlists together usingthe plus operator.The plus operator does\nnot mutate the list.Instead, it gives\nyou a new list that'sthe sum of those\ntwo lists combined.So in this case, if L1 is\n2,1,3 and L2 is 4, 5, 6,", "start": 1200.0, "heat": 0.619}, {"text": "when we add those\ntwo lists together,that's going to give us an\nentirely new list leavingL1 and L2 the same.And that's why we have to assign\nthe result of the additionto a new list.Otherwise, the result is lost.If you want to mutate a\nlist directly and make itlonger by the elements\nwithin another list, thenyou can use this extend\nfunction or extent method.And this is going to\nmutate L1 directly.So if L1 was 2,1,3, if you\nextend it by the list 0,6,it's just going to tack\non 0,6 to L1 directly.So notice L1 has been mutated.So that's adding\nthings to lists.We can also delete\nthings from lists.We don't just want to\nkeep adding to our lists,because then they\nbecome very, very big.So let's see how we can delete\nsome items from our list.There's a few ways.First one being can\nuse this del function.And this says\ndelete from the listL the element at this index.So you give it\nthe index 0, 1, 2,or whatever you want\nto-- whatever indexyou want to delete\nthe element at.If you just want to\ndelete the elementat the end of the list,\nthat's the farthest right,you do L.pop.If you want to remove a\nspecific element-- so you knowthere's somewhere in your\nlist there's the number 5,and you want to delete it\nfrom the list-- then yousay L.remove and you say what\nelement you want to remove.And that only removes the\nvery first occurrence of it.So if there's two\nfives in your list,then it's only going to\nremove the very first one.So let's take a look at this\nsort of sequence of commands.", "start": 1320.0, "heat": 0.386}, {"text": "So we have first L is equl\nto this long list here.And I want to mention that\nall of these operationsare going to mutate\nour list, whichis why I wrote this comment here\nthat says assume that you'redoing these in order.So as you're doing\nthese in order,you're going to be\nmutating your list.And if you're\nmutating your list,you have to remember\nthat you're workingwith this new mutated list.So the first thing\nwe're doing iswe're removing 2 from our list.So when you remove\n2, this says lookfor an element with the value 2\nand take it away from the list.So that's the very\nfirst one here.So the list we're left with\nis just everything after it.Then I want to remove\n3 from the listand notice there's two of them.There's this 3 here and\nthere's this 3 here.So we're going to remove\nonly the first one, whichis this one here.So the list we're left\nwith is 1,6,3,7,0.Then we're going to\ndelete from the list Lthe element at position 1.So starting counting from\n0, the element at position 1is this one here.So we've removed that, and\nwe're left with 1, 3, 7, 0.And then when we\ndo L.pop, that'sgoing to delete the element\nfurthest to the right.So at the end of the\nlist, which is that 0.So then we're left\nwith only 1, 3, and 7.And L.pop is often useful,\nbecause it tells youthe return value from L.pop is\ngoing to be the value that itremoved.So in this case, it's\ngoing to return 0.I want to mention, though,\nthat some of the-- so thesefunctions all mutate the list.You have to be careful\nwith return values.So these are all-- you\ncan think of all of theseas functions that\noperate on the list.Except that what these functions\ndo is they take in the list,", "start": 1440.0, "heat": 0.389}, {"text": "and they modify it.But as functions, they\nobviously return somethingback to whoever called them.And oftentimes, they're going\nto return the value none.So for example, if you are\ngoing to do L.remove 2,and you print that out, that\nmight print out none for you.So you can't just assign the\nvalue of this to a variableand expect it to be\nthe mutated list.The list got mutated.The list that got\nmutated is the listthat was passed into to here.We're going look at one\nexample in a few slides that'sgoing to show this.OK.Another thing that we can do,\nand this is often useful whenyou're working with\ndata, is to convert liststo strings and then\nstrings to lists.Sometimes it might be useful\nto work with strings as opposedto a list and vice versa.So this first line here,\nlist s takes in a stringand casts it to a list.So much like when we cast\na float to an integer,for example.You're just casting a\nstring to a list here.And when you do\nthat up this line--so if this is your s\nhere-- when you do list s,this is going to\ngive you a list--looks like this-- where\nevery single character in sis going to be its own element.So that means every character\nis going to be a string,and it's going to be\nseparated by a comma,so including spaces.Sometimes you don't want\neach character in the listto be its own element.Sometimes you want, for example,\nif you're given a sentence,you might want to have\neverything in between spacesbeing its own element.So that will give you every word\nin the sentence, for example.In that case, you're\ngoing to use split.In this case, I've split\nover the less than sign.But again, if you're doing\nthe sentence example,you might want to\nsplit on the space.So this is going to take\neverything in between the signthat you're interested in-- in\nthis case, the less than sign--and it's going to set it as a\nseparate element in the list.", "start": 1560.0, "heat": 0.448}, {"text": "So that's how you\nconvert strings to lists.And sometimes\nyou're given a list,and you might want to\nconvert it to a string.So that's where this join\nmethod or function is useful.So this is an empty string.So it's just open\nclose quote right away.No space.So this just joins every one\nof the elements in the listtogether.So it'll return the string abc.And then you can join on any\ncharacter that you would want.So in this case, you can\njoin on the underscore.So it'll put whatever characters\nin here in between every oneof the elements in your list.So pretty useful functions.OK.Couple other operations\nwe can do on lists--and these are also pretty\nuseful-- is to sort listsand to reverse lists\nand many, many othersin the Python documentation.So sort and sorted both\nsort lists, but one of themmutates the list and\nthe other one does not.And sometimes it's\nuseful to use one,and sometimes it's\nuseful to use the other.So if I have this list\nL is equal to 9,6,0,3,sorted-- you can think\nof it as giving methe sorted version\nof L-- gives you backthe sorted version of L. So\nit returns a new list that'sthe sorted version of the input\nlist and does not mutate L.So it keeps L the\nexact same way.So this will be replaced\nby the sorted versionof the list, which you\ncan assign to a variable,and then do whatever\nyou want with it.Like L2 is equal to\nsorted L, for example.And it keeps L the same.On the other hand, if you\njust want to mutate L,and you don't care about getting\nanother copy that's sorted,", "start": 1680.0, "heat": 0.53}, {"text": "you just do L.sort.And that's going to\nautomatically sort L for you,and L now-- L is now the\nsorted version of L. Similarly,reverse is going to take L and\nreverse all the character--all the elements in it.So the last one is the first\none, the second to last oneis the second one, and so on.So lists are mutable.We've said that so many\ntimes this lecture.But what exactly does that mean?What implications\ndoes that have?Once again, this next part\nof the lecture, Python tutor.Just paste all the code\nin and go step by stepto see exactly what's happening.So lists are mutable.As you have variable\nnames-- so for example,L is equal to some\nlist-- that L isgoing to be pointing\nto the list in memory.And since it's a mutable\nobject, this list,you can have more\nthan one variablethat points to the exact\nsame object in memory.And if you have more\nthan one variable thatpoints to the same\nobject in memory,if that object in\nmemory is changed, thenwhen you access it through\nany one of these variables,they're all going to give\nyou the changed object value.So the key phrase\nto keep in mindwhen you're dealing\nwith lists iswhat side effects could happen?If you're mutating a list,\nif you're doing operationson lists, what side effects--\nwhat variables mightbe affected by this change?Let's come back down\nto earth for a second.This will wake a\nlot of people up.So let's do an\nanalogy with people.Let's say we have a person.A person-- this\ncase, Justin Bieber--", "start": 1800.0, "heat": 0.459}, {"text": "is going to be an object.I'm an object.I'm like the number three.Bieber's an object.He's like number five.Different objects.Were both of type people.OK.Let's say a person has\ndifferent attributes.Let's say we can--\nlet's say he getstwo attributes to begin with.He's a singer and he's rich.I can refer to this person\nobject by many different names.His full name, his stage\nname, all of the fan girlscall him by these\nnames, people whodislike him call\nhim by other namesthat they didn't put up here.But he's known by all\nthese different names.They're all aliases or nicknames\nthat point to this same personobject.OK.So originally, let's say\nI say Justin Bieber isa singer and rich.Those are the two\nattributes I've originallyassigned to him.And then let's say I want to\nassign a different attributeto him and say Justin\nBieber's a singer, rich,and a troublemaker.I'm being kind here.OK.So if I say Justin Bieber\nhas these three attributes--so it's the same person\nI'm referring to-- thenall of his nicknames\nare going to referto this exact same person.So all of his\nnicknames or aliaseswill refer to the\nsame person objectwith these changed attributes.Does that makes sense?OK.So that sort of idea\narises in lists.So a list is like\na person objectwhose value-- whose attributes\ncan change, for example.And as they change, all\nof the different aliasesfor this object will point\nto this changed object.So let's see a few examples.I apologize if this\nis a little small,but this I basically\ncopied and pastedfrom the Python\ntutor, which is justfrom the code from\ntoday's lecture.", "start": 1920.0, "heat": 0.33}, {"text": "So I have these\nlines of code here.The first couple of\nlines really justshow what happens\nwhen you're dealingwith non-mutable objects.So with non-mutable\nobjects, you havetwo separate objects that\nget their own values,and that's it.End of story.With lists, however,\nthere's something differentthat happens.So I have warm is a variable.And it's going to be\nequal to this list.So warm is going to\npoint to this list here.Red, yellow, orange.It contains three elements.Hot is equal to warm.It means I'm creating\nan alias for this list.And the alias is going to\nbe with this variable hot.So notice warm and hot point\nto the exact same object.So on line 8 when I append\nthis string pink to my object,since both of\nthese two variablespoint to the exact\nsame object, if I'mtrying to access this object\nthrough either variable,they're both going to\nprint out the same thing.And that's the side effect.That's the side effect\nof lists mutable.If you want to create an\nentirely new copy of the list,then you can clone it,\nwhich sounds really cool.But really, it's just\nmaking a copy of the list.And you clone it using\nthis little notation here,which is open close square\nbrackets with a colon.And we've sort of seen\nthis notation here.And this tells Python\nthis is 0-- sorry.This is 0 and this is length.Cool.But it basically says\ntake every element,create a new list with\nthose exact same elements,and assign it to\nthe variable chill.So here, if I\noriginally have coolis equal to blue,\ngreen, gray righthere, when I clone it on line\n2 with that funky notation,", "start": 2040.0, "heat": 0.422}, {"text": "I'm creating a new copy of it.And then on the\nnext line when I'mappending another\nelement to the copy,notice I'm just\naltering the copy.The original stayed the\nsame, because I've cloned it.So if you don't want to\nhave the side effects-- sideeffect issue, then\nyou should cloneyour variable-- your list.So let's see a slightly\nmore complicated examplewhere you're going to see\nthe difference between sortand sorted in the context\nof this mutability and sideeffects issue.OK.So once again, let's create this\nwarm is equal to red, yellow,orange.So that's what warm is going\nto point to, this list.And then sorted warm\nis equal to warm.sort.So .sort mutates.So as soon as I do\nthat, that list warmis now the sorted version of it.And notice that I've\nassigned the return of thisto sorted warm.And the return is none,\nbecause L.sort or .sort mutatedthe list.It didn't return a sorted\nversion of the list.It mutated the list itself.OK.So when I print warm\nand I print sorted warm,I'm printing the mutated\nversion and then this one here.Sorted, on the other\nhand, returns--it doesn't-- sorted does not\nsort the list that's givento it.And instead, it returns a\nsorted version of the list.So in this case, if cool is\nequal to these three colors--gray, green, blue--\nif I do sorted cool,", "start": 2160.0, "heat": 0.345}, {"text": "it's going to return the sorted\nversion of that list, whichis blue, green, gray.And it's assigned to the\nvariable sorted cool.So when I print them,\nit's going to showme the two separate lists.One being the\noriginal unsorted one,and one being the\nsorted version.Last ones a little\nbit more complicated,but it shows that even\nthough you have nested--even though you can have nested\nlists, you still-- you're not--you don't escape this\nidea of side effects.So first, I'm going to create\nwarm is equal to these twocolors, yellow, orange.So warm points to\nthese two colors.Hot is equal to this one\nlist-- a list with one element.Bright colors is\ngoing to be a list.And the element inside\nthe list is a list itself.So since it's a list--\nthis is your list,and the element inside here,\nwhich is a list itself,is actually just pointing\nto whatever warm is.That object.Then I do-- then I append\nhot to my bright colors.So the next element\nhere is goingto be another list, which\nmeans it's just pointingto this other list here.It's not creating a copy of it.So each one of\nthese elements hereis actually just pointing\nto these two lists here.So if I modified\neither one of these,then bright colors\nwould also be modified.So let's say I add pink\nhere to my hot list.We have red and pink.Then notice that bright\ncolors-- the first elementpoints to this list,\nand the second elementpoints to this list,\nwhich I've just modified.Last thing is-- I'll\nlet you try thisas an exercise in Python Tutor--\nbut the idea here being you", "start": 2280.0, "heat": 0.277}, {"text": "should be careful as you're\nwriting a for loop thatiterates over a list that you're\nmodifying inside the list.In this case, I'm trying\nto go through the list L1.And if I find an item\nthat's in L1 and L2,I want to delete it from L1.So 1 and 2 are also in L2.So I want to delete them from\nL1 and be left with 3, 4.However, the code on the\nleft here doesn't actuallydo what I think it's\ndoing, because here I'mmodifying a list as\nI'm iterating over it.And behind the\nscenes, Python keepsthis-- keeps track of the index\nand doesn't update the indexas you're changing the list.So it figures out the\nlength of the listto begin with and how\nmany indices it has.It doesn't update it as you're\nremoving items from the list.So the solution to that is\nto make a copy of the listfirst, iterate over the copy,\nwhich will remain intact,and modify the list that you\nwant to modify inside the loop.So please run both of\nthese in the Python Tutor,and you'll see that what ends\nup happening is on the left,you're going to skip\nover one element.So your code-- so that's\ngoing to be the wrong code.All right.", "start": 2400.0, "heat": 0.386}]