[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or to\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Welcome back.Over the last\ncouple of lectures,we've been looking at\noptimization models.And the idea was how do I find\na way to optimize an objectivefunction-- it could be\nminimize it or maximize it--relative to a set\nof constraints?And we saw, or\nProfessor Guttag showedyou, one of the ways\nthat naturally falls outis by looking at\ntrees, decision trees,where you pass your way through\na tree trying to figure outhow to optimize that model.So today, we're going to\ngeneralize those treesinto another whole broad\nclass of models called graphtheoretic or graph models.And we're going to use\nthose to again lookat how do we can do optimization\non those kinds of models.Just to remind you,\nthere is a great pieceof information in the text.There's the reading for today.And these will, of\ncourse, be in the slidesthat you can download.So let's take a second\njust to reset againwhat are we trying to do?Generally, we're trying to\nbuild computational models.So what does that mean?The same way we could do\na physical experiment,or a social experiment,\nor model, if you like,a physical system\nand a social system,to both try and gather\ndata and analyze itor to do predictions.We want to do the same\nthing computationally.We'd like to be able\nto build models in codethat we can then run to\npredict effects, which we thenmight test with an actual\nphysical experiment.And we've seen, for example,\nhow you could take just", "start": 0.0, "heat": 0.1}, {"text": "the informal problem of choosing\nwhat to eat and turning itinto an optimization\nproblem-- in this case,it was a version of something\nwe called a knapsack problem--and how you could then use\nthat to find code to solve it.And you've already seen two\ndifferent general methods.You've seen greedy algorithms\nthat just try and dothe best thing at each stage.And you saw dynamic programming\nas an elegant solutionto finding better\nways to optimize this.We're going to now look at\nbroadening the class of modelsto talk about graphs.So, obvious question\nis, what's a graph?And a graph has two\nelements, two components.It has a set of nodes,\nsometimes called vertices.Those nodes probably are\ngoing to have some informationassociated with them.It could be as simple\nas it's a name.It could be more complicated.A node might represent\na student record--the grades.And a graph might talk\nabout putting togetherall of the grades for a class.Associated with that,\nwe can't just-- well,I should say, we\ncould just have nodes,but that's kind of boring.We want to know what\nare the connectionsbetween the elements\nin my system?And so the second thing\nwe're going to haveis what we call edges,\nsometimes called arcs.And an edge will\nconnect a pair of nodes.We're going to see two\ndifferent ways in which wecould build graphs using edges.The first one, the\nsimple one, is an edgeis going to be undirected.And actually, I should\nshow this to you.So there is the\nidea of just nodes.Those nodes, as I said,\nmight have informationin them, just labels or names.They might have other\ninformation in them.When I want to connect\nthem up, the connectionscould be undirected.If you want to think of it\nthis way, it goes both ways.An edge connects\ntwo nodes together,and that allows\nsharing of informationbetween both of them.In some cases, we're going\nto see that we actuallywant to use what we call a\ndirected graph, sometimescalled a digraph, in\nwhich case the edge hasa direction from a\nsource to a destination,or sometimes from a\nparent to a child.", "start": 120.0, "heat": 0.302}, {"text": "And in this case,\nthe informationcan only flow from the\nsource to the child.Now in the case\nI've drawn here, itlooks like there's only\never a single directed edgebetween nodes.I could, in fact, have\nthem going both directions,from source to destination and\na separate directed edge comingfrom the destination\nback to the source.And we'll see some\nexamples of that.But I'm going to have edges.Final thing is, those edges\ncould just be connections.But in some cases, we're\ngoing to put informationon the edges, for\nexample, weights.The weight might\ntell me how mucheffort is it going to take\nme to go from a sourceto a destination.And one of the\nthings you're goingto see as I want to\nthink about how do Ipass through this graph,\nfinding a path from oneplace to another, for example,\nminimizing the cost associatedwith passing through the edges?Or how do I simply find\na connection between twonodes in this graph?So graphs, composed\nof vertices or nodes,they're composed\nof edges or arcs.So why might we want them?Well, we're going to see--and you can probably\nalready guess--there are lots of really useful\nrelationships between entities.I might want to take\na European vacation.After November 8,\nI might really wantto take a European vacation.So I'd like to know, what are\nthe possible ways by rail Ican get from Paris to London?Well, I could pull out the\nschedule and look at it.But you could imagine, I hope,\nthinking about this as a graph.The nodes would be cities.The links would be rail\nlinks between them.And then, one of the\nthings I might like to knowis, first of all, can I\nget from Paris to London?And then secondly,\nwhat's the fastestway to do it or the\ncheapest way to do it?So I'd like to explore that.Second example, as you can see\non the list, drug discovery,modeling of complex\nmolecule in termsof the relationships between\nthe pieces inside of it and thenasking questions like,\nwhat kind of energywould it take to\nconvert this molecule", "start": 240.0, "heat": 0.154}, {"text": "into a different molecule?And how might I think about\nthat as a graph problem?Third and obvious one, ancestral\nrelationships, family trees.In most families,\nalmost all families,they really are\ntrees not graphs.Hopefully you don't\ncome from a familythat has strange loops in them.But family trees are--I know, I'm in\ntrouble here today.Aren't I?Family trees-- stay with me--are a great demonstration of\nrelationships because thereits directional edges.Right?Parents have children.Those children have children.And like I say, it\ncomes in a natural wayof thinking about traversing\nthings in that tree.And in fact, trees are a\nspecial case of a graph.You've already seen decision\ntrees in the last lecture.But basically, a special kind\nof directed graph is a tree.And the property of\nthe tree is, as itsays there, any pair\nof nodes are connected,if they are connected,\nby only a single path.There are no loops.There are no ways\nto go from one node,find a set of things that\nbrings you back to that node.You can only have a single\npath to those points.And Professor Guttag\nused this, for example,to talk about solving\nthe knapsack problem.A decision trees is\na really nice wayof finding that solution.Now, I drew it this way.In computer science, we\nmostly use Australian trees.They're upside down.The roots are at the top.The leaves are at the\nbottom, because wewant to think about starting\nat the beginning of the tree,which is typically\nsomething we call the rootand traversing it.But however you\nuse it, trees aregoing to be a useful\nway of actuallythinking about representing\nparticular kinds of graphs.OK.So, when I talk in a second\nabout how to build graphs,well let's spend just\na second about saying,so why are they useful?And if you think\nabout it, the worldis full of lots of networks that\nare based on relationships thatcould be captured by a graph.", "start": 360.0, "heat": 0.153}, {"text": "We use them all the time.Some of you are using\nthem right now--computer networks.You want to send an email\nmessage from your machineto your friend at Stanford.That's going to get routed\nthrough a set of linksto get there.So the network set up by a\nseries of routers that pass italong, sending something\nrequires an algorithmthat figures out the best way\nto actually move that around.There's a great\nlocal company startedby an MIT professor\ncalled Akamaithat thinks about how do\nyou move web content aroundon the web?Again, it's a nice\ncomputer network problem.I've already talked about this.We're going to do\nsome other examples.Transportation networks--\nhere, if you think about it,obvious thing is make\nthe nodes cities.Make the edges\nroads between them.And now questions are,\ncan I get to San Jose,if you like old songs?And what's the best\nway to get to San Jose,even if you don't\nlike old songs?A network problem--\nhow do I analyze it?Financial networks--\nmoving money around--easily modeled by a graph.Traditional networks--\nsewer, water, electrical,anything that distributes\ncontent, if you like,and the different kind of\ncontent in this way around.You want to model that\nin terms of how you thinkabout flows in those networks.How do I maximize distribution\nof water in an appropriate way,given I've got certain\ncapacities on different pipes,which would mean those\nedges in the graphwould have different weights?And you get the idea--political networks, criminal\nnetworks, social networks.One of the things we're\ngoing to see with graphsis that they can capture\ninteresting relationships.So here's an example.It's from that little web\nsite you can see there.You're welcome to go look at it.And this is a graph\nanalyzing The Wizard of Oz.And what's been done\nhere is the sizeof the node reflects the number\nof scenes in which a charactershares dialog.So you can see, obviously\nDorothy is the biggest nodethere.", "start": 480.0, "heat": 0.172}, {"text": "The edges represent\nshared dialog,so you can see who talks\nto whom in this graph.And then, this group\nhas done another thing,which I'm going to mention.We're not going to solve\ntoday, which is you can alsodo analysis on the graphs.And in fact, the color\nhere has done somethingcalled a min-flow\nor max-cut problem,which is it's tried to identify\nwhich clusters in the graphtend to have a lot\nof interactionswithin that cluster but not\nvery many with other clusters.And you can kind of see.There's some nice things here,\nright, if you can read it.This is all the\npeople in Kansas.This is Glenda and the\nMunchkins in that part of Oz.There's another little cluster\nover here that I can't readand a little cluster over there.And then the big\ncluster down here.But you can analyze the graph\nto pull out pieces on it.You can also notice, by the way,\nthe book is probably misnamed.It's called The Wizard of Oz.But notice, there's\nthe wizard, whoactually doesn't have\na lot of interactionwith the other\npeople in this story.It's OK, literary choice.But the graph is\nrepresenting interactions.And I could imagine\nsearching that graphto try and figure\nout things about whatgoes on in The Wizard of Oz.OK.So why are they useful?We're going to see that not only\ndo graphs capture relationshipsin these connected\nnetworks, but they'regoing to support inference.They're going to be able\nto reason about them.And I want to set that up.And then we'll actually look\nat how might we build a graph.And so here are\nsome ways in whichI might want to do inference.Given a graph, I\nmight say, is therea sequence of edges, of\nlinks, between two elements?Is there a way to\nget from A to B?What are the sequence of edges\nI would use to get there?A more interesting\nquestion is, can Ifind the least expensive\npath, also knownas the shortest path?If I want to get\nfrom Paris to London,I might like to do it in\nthe least amount of time.What are the set of choices\nI want to make to get there?A third graph problem used a lot\nis called the graph partition", "start": 600.0, "heat": 0.249}, {"text": "problem.Everything I've shown so\nfar-- actually not quite.The first example\ndidn't have it.You might think of all the\nnodes having some connectionto every other node.But that may not be true.There may actually\nbe graphs whereI've got a set of connected\nelements and another componentwith no connections\nbetween them.Can I find those?That's called the graph\npartition problem.How do I separate the graph\nout into connected setsof elements?And then the one\nthat we just showedcalled the min-cut\nmax-flow problem, isis there an efficient\nway to separate outthe highly connected elements,\nthe things that interacta lot, and separate out how many\nof those kinds of subgraphs,if you like, are there\ninside of my graph?All right, let me show you\na motivation for graphs.And then we'll build them.I use graph theory everyday.I'm a math nut.It's OK, but I use\ngraph theory everyday.You may as well, if you commute.Because I use it\nto figure out howto get from my home in Lexington\ndown here to Cambridge.And I use a nice\nlittle system calledWaze It's a great way\nof doing this, whichdoes graph theory inside of it.So how do I get to my office?Well, I'm going to model\nthe road system usinga directed graph, a digraph.Directed graph because\nstreets can be one way.And so I may only have a\nsingle direction there.And the idea is, I'm\ngoing to simply letmy nodes or my\nvertices be pointswhere I have intersections.They're places where I can\nmake a choice or places whereI have terminals, things\nI'm going to end up in.The edges would just be the\nconnections between points,the roads on which I can drive.Some Boston drivers have a\ndifferent kind of digraphin which they don't care whether\nthat road is drivable or not.They just go on it.You may have seen some of these.But I want to keep my graphs as\nreal roads that I can drive on.And I'm not going to go\nagainst the \"One Way\" sign.Each edge will have a weight.Here I actually\nhave some choices.All right, the obvious one, the\none that Waze probably uses,", "start": 720.0, "heat": 0.155}, {"text": "is something like what's the\nexpected time between a sourceand a destination node?How long do I expect it to\ntake me to get from this pointto that?And then, as you\ncan see, I'm goingto try and find overall what's\nthe best way to get around it.You could pick just distance.What's the distance\nbetween the two?And while there there's\na relationship here,it's not direct because it\nwill depend on traffic on it.Or you could take something\neven funkier like what'sthe average speed of\ntravel between the sourceand destination node?And once I've got\nthe graph, then I'mgoing to solve an\noptimization problem.What's the shortest weight\nbetween my house and my officethat gets me into work?You can make a choice here.As I said, a commercial system\nlike Waze uses this one.My wife and I actually\nhave argumentsabout commuting\nbecause she's a firmbeliever in the second one,\njust shortest distance.I actually like the third\none because I get anxiouswhen I'm driving.And so as long as I feel like\nI'm making progress, I like it.So even though I may be\nserpentining all the waythrough the back roads of\nCambridge, if I'm driving fast,I feel like I'm getting there.So I like optimizing this\nbottom one down there.And if you see me on the road,\nyou'll know why I say that,and then get out of the way.Thinking about navigation\nthrough systemsactually gives us a\nlittle bit of historybecause, in fact, the very first\nreported use of graph theorywas exactly this problem.Early 1700s, it's called\nthe Bridges of Koenigsberg.Koenigsberg is a\ncity that has a setof islands and rivers in it.There are seven bridges that\nconnect up those islands.And the question that\nwas posed is, is itpossible to take a walk that\ntraverses each of the sevenbridges exactly once?So could you take a walk\nwhere you go over each bridgeexactly once?I'm showing you\nthis because it letsus think about how to in fact\ncapture things in a model.This problem was solved by\na great Swiss mathematician,", "start": 840.0, "heat": 0.165}, {"text": "Leonhard Euler.And here's what he said.Make each island a node.Each bridge is just\nan undirected edge.And notice in doing\nthat, he's abstractedaway irrelevant details.You don't care what the\nsize of the island is.You don't care how\nlong the bridges are.You simply want to think about\nwhat are the connections here?And then you can ask a question.In this graph, is it\npossible to find a wayto walk through it so that\nyou go through each edgeexactly once?And as Euler showed,\nthe answer is no.And if you're curious, go\nlook it up on Wikipedia.There's a nice, elegant\nsolution to why that's the case.But here's what\nwe're going to do.We're going to use\nthose graphs to thinkabout these kinds of problems.And in fact, the example\nI'm going to show youare going to be\nshortest path problems.So with that, let's turn to\nactually building a graphand then thinking about\nhow we're going to use it.So we're going to start\nby constructing graphs.And then what we're\ngoing to do isshow how we can build\nsearch algorithmson top of those graphs.And I hope that that flicker\nis going to go away here soon.Here we go.So to build a graph--actually, I shouldn't have\nput this slide up so fast.I've got lots of choices here.If I'm thinking about maps,\none way to build a graphwould really to just be\nbuild something with latitudeand longitude on it.But as we've already seen, we'd\nlike to extract things awayfrom the graphs.And so a natural\nchoice is to say,let's represent the nodes in\nthe graph just as objects.I'm going to use\nclasses for these.So here's my\ndefinition of a node.It's pretty straightforward.I'm going to assume that\nthe only information for nowI store in a node is just a\nname, which I'm going to assumeis a string.So I've got a class\ndefinition for node.It inherits from the\nbase Python object class.I need ways to create\ninstances of nodes,so I've got an init function.And I'm simply going to\nstore inside each instance,in other words, inside of\nself, under the variable name,", "start": 960.0, "heat": 0.134}, {"text": "whatever I passed in as\nthe name of that node.Of course, if I've got ways\nto create things with a name,I need to get them back out.So I've got a way of\nselecting it back out.If I ask an instance of\na node, what's your name?By calling getName it\nwill return that value.And to print things\nout, I'm justgoing to print out the name.This is pretty straightforward.And this, of course, lets\nme now create as many nodesas I would like.Edges?Well, an edge\nconnects up two nodes.So again, I can do a fairly\nstraightforward constructionof a class.Again, it's going to inherit\nfrom the base Python object.To create an\ninstance of an edge,I'm going to make an assumption,\nan important one whichwe're going to come back to.And the assumption is that the\narguments passed in, sourceand destination, are nodes--not names-- the\nnodes themselves,the actual instances\nof the object class.And what will I do?Inside of the edge, I'm going\nto set internal variables.For each instance of the\nedge, source and destinationare going to point\nto those nodes,to those objects that I\ncreated out of the node class.Next two things are\nstraightforward.I can get those things back out.And then the final\npiece is, if whenI want to print out\nwhat an edge looks like,I'm going to ask\nthat it print outthe name of the source,\nand then an arrow,and then the name\nof the destination.So notice what I do there.Given an instance of an\nedge, I can print it.And it will get the source or\nthe node associated with sourceinside this instance, get\nfor that the getName method,and then call it.Notice the open-close paren\nthere to actually call it.What does that do?It says, inside the\nedge I've got somethingthat points to a node.I get that node.I take the method\nassociated with it.And I call it.That returns the string.And then I glue that\ntogether with the arrow.I do the same thing\non the destination.And I just print it out.", "start": 1080.0, "heat": 0.135}, {"text": "Pretty straightforward,\nhopefully.OK, now I have to make a\ndecision about the graph.I'm going to start with\ndigraphs, directed graphs.And I need to think about how\nI might represent the graph.I can create nodes.I can create edges, but I've\ngot to bring them all together.So I'll remind you, a\ndigraph is a directed graph.The edges pass in\nonly one direction.And here's one\nway I could do it.Given all the sources\nand all the destinations,I could just create a big matrix\ncalled an adjacency matrix.The rows would be\nall the sources.The columns would be\nall the destinations.And then in a particular\nspot in the matrix,if there is an edge between\na source and a destination,I'd just put a one.Otherwise I'd put a zero.Note, by the way, because\nit's a directed graph,it's not symmetric.There might be a one between S\nand D, but not between D and S,unless there are\nedges both ways.This would be a\nperfectly reasonable wayto represent a graph, but\nnot the most convenient one.I'd have to go into the\nmatrix to look things up.It may also not be\na very efficient wayof representing things.For example, if there are\nvery few edges in the graph,I could have a huge\nmatrix with mostly zeros.And that's not the most\neffective way to do it.So I'm going to use\nan alternative calledan adjacency list.And the idea here is, for\nevery node in the graph.I'm going to associate with\nit a list of destinations.That is, for a node,\nwhat are the placesI can reach with a single edge?OK, so let's see what that\ndoes if we want to build it.And yes, there's a\nlot of code here,but it's pretty easy\nto look through I hope.Here's the choice\nI'm going to make.Again, what's a graph?It's a set of nodes.It's a set of edges.I'm going to have a way of\nputting nodes into the graph.And I'm going to choose to, when\nI put a node into the graph,", "start": 1200.0, "heat": 0.1}, {"text": "to store it as a\nkey in a dictionary.OK?When I initialize\nthe graph, I'm justgoing to set this\ninternal variable, edges,to be an empty dictionary.And the second\npart of it is, whenI add an edge to the\ngraph between twonodes from a source\nto a destination,I'm going to take that point\nin the dictionary associatedwith the source.It's a key.And associated\nwith it, I'm goingto just have a list of\nthe nodes I can reachfrom edges from that source.So notice what happens here.If I want to add\na node, remember,it's a node not an edge--I'll first check to make\nsure that it's not alreadyin the dictionary.That little loop is\nbasic, or that if issaying, if it's in this set\nof keys, it will return true.And I'm going to complain.I'm trying to copy a\nnode or duplicate a node.Otherwise, notice what I do.When I put a node\ninto the dictionary,I go into that\ndictionary, edges.I create an entry with\nthe key that is the node.And the value I put in there\nis initially an empty list.I'm going to say one\nmore piece carefully.It's a node not a name.And that's OK in Python.It is literally the\nkey is the node itself.It's an object, which\nis what I'd like.All right, what if I\nwant to add an edge?Well, an edge is going\nto go from a sourceto a destination node.So, I'm going to get out from\nthe edge the source piece.I'm going to get\nout from the edgethe destination piece by\ncalling those methods.Again, notice the open-close\nparen, which takes the methodand actually calls it.Because remember, an edge\nwas an object itself.Given those, I'll check\nto make sure that theyare both in the dictionary.That is, I've already\nadded them to the graph.I can't make a\nconnection between thingsthat aren't in the graph.And then notice the\nnice little thing I do.Presuming I have both of\nthem in the dictionary,I take the dictionary, I index\ninto it with the source node.", "start": 1320.0, "heat": 0.111}, {"text": "That gives me a key\ninto the dictionary.I pull out the entry at\nthat point, which is a list,because I created them up here.And I add the destination node\nwith append into the list,stick it back in.So this now captures what\nI said I wanted to do.The nodes are represented\nas keys in the dictionary.And the edges are\nrepresented by destinationsas values in the list\nassociated with the key.So you can see, if I\nwant to see is therean edge between a source\nand a destination,I would look at our\nsource in the dictionary,and then check in\nthe list to seeif the destination is there.OK, the rest of\nthis then followspretty straightforwardly.If I want to get all the\nchildren of a particular node,I just go into the\ndictionary, edges,and look up the value\nassociated with that node.It gives me back the list.I've got all the\nthings I can reachfrom that particular node.If I want to know if a\nnode is in the graph,I just search over the\nkeys of the dictionary.They'll either\nreturn true or false.If I want to get a\nnode by its name, whichis going to be probably more\nconvenient than trying to keeptrack of all the\nnodes, well I couldpass in a name as a string.And what will I do?I'll just search over all\nthe keys in the dictionary,using the getName method\nassociated with it--there's the call-- then\nchecking to see if it'sthe thing I'm looking for.And if it is, I'll return M.\nI'll return the node itself.What about this thing here?It might bother\nyou a little bit.Wait a minute.That raise, isn't it always\ngoing to throw an error?No, because I'm going to\ngo through this loop first.And if I actually find\na node, that returnis going to pop me out of\nthe call and return the node.So I'll only ever get\nto this if in fact Icouldn't find anything here.And so it's an appropriate\nway to simply raise the errorto say, if I get to this\npoint, couldn't findit, raise an error to\nsay the node's not there.", "start": 1440.0, "heat": 0.433}, {"text": "The last piece looks\na little funky,Although you may have seen this.I like to print out\ninformation about a graph.And I made a choice, which\nis, I'm going to print outall of the links in the graph.So I'm going to set up a string\ninitially here that's empty.And then I'm going to loop over\nevery key in the dictionary,every node in the graph.And for each one, I'm going to\nlook at all the destinations.So notice, I take\nthe dictionary,I look up the things\nat that point.That's a list.I loop over that.And I'm just going\nto add in to result,the name of the source,\nan arrow, and the nameof the destination followed\nby a carriage return.I'll show you an\nexample in a second.But I'm simply walking down the\ngraph, saying for each source,what can it reach?I'll print them all out.And then I'll return everything\nbut the last element.I'm going to throw away\nthe last carriage returnbecause I don't really need it.So let me show you\nan example here,trusting that my Python has\ncome up the way I wanted it to.So I'm going to load that in,\nignore that for the moment.And I'm going to set g to--I've got something we're going\nto come back to in a secondthat actually creates a graph.And if I print out\ng, it prints out,in this case, all of the links\nfrom source to destination,each one on a new line.OK.So I can create the graphs.That was digraphs.Suppose I actually\nwant to get a graph.Well, I'm going to make it\nas a subclass of digraph.And in particular, the\nonly thing I'm going to dois I'm going to shadow the\naddEdge method of digraphs.So if you think about it,\nit's so I make a graph.If I ask it to add\nedges, it's goingto use this version of addEdge.And what am I going to do?I know in a graph, I could\nhave both directions work.", "start": 1560.0, "heat": 0.26}, {"text": "So, given an edge that I\nwant to add into this graph,I'll use the method\nfrom the digraph class.And I'll add an edge going\nfrom source to destination.And then I'll just create\nan edge the other direction.Destination becomes source.Source becomes destination.And I'll add that\ninto the graph.Nice and easy,\nstraightforward to do.And this is kind of nice\nbecause, in a graph,I don't have any directionality\nassociated with the edge.I can go in either direction.I just created\nsomething like that.And you might say,\nwell, wait a minute.Why did I pick graph to\nbe a subclass of digraph?Why not the other way around?Reasonable question, and you\nactually know the answer.You've seen this before.One of the things\nI'd like to haveis the property that if the\nclient code works correctlyusing an instance\nof the bigger type,it should also\nwork correctly whenit is using an instance of the\nsubtype substituted in, whichis another way of\nsaying anything thatworks for a digraph will\nalso work for a graph,but not vice versa.And as a consequence,\nit's easierto make the graph a\nsubclass of digraph.Notice the other thing\nthat's nice here.One little piece of\ncode, just changewhat it means to make an edge.Everything else still holds.And also notice-- you've seen\nthis before-- how we nicelyinherit the method\nfrom the subclassby explicitly calling it.It says, from the digraph class,\nget out the addEdge methodand apply it.OK.So we can build graphs.We're going to do\nthat in a second.Let's turn now to thinking about\nI'd like to search on a graph.And I'm going to start with\nthe classic graph optimizationproblem.I'd like to find\nthe best path home.So, what's the shortest path\nfrom one node to another?And that shortest path\ninitially will justbe the shortest\nsequence of steps.", "start": 1680.0, "heat": 0.215}, {"text": "I hope I'm not having\na little attack here.You just saw that\nscreen blank out, right?The shortest path of\nsteps with the propertythat the source of the first\nedge is the starting point.The destination of\nthe last edge isthe thing I'm trying to get to.And for any edge\nin between, if Igo in my first edge from\nsource to say node one,the next edge has that\ndestination as its source.So there's simply a chain that\nsays can go from here to hereto here to here to get\nall the way through.And I'd like to find what's\nthe shortest number of steps?Edges like that that will get\nme from source to destination.Ultimately, if those edges\nhave weights on them,the optimization problem\nI'd like to solveis, what's the shortest\nweighted path, the shortestamount of work I have to\ndo to get to those places?And if we can solve\none, we'll seethat we can solve the other\none pretty straightforwardly.And we've already seen examples\nof shortest path problems.Clearly, finding a\nroute navigation is one.Designing communication networks\nis another great exampleof a shortest path problem.You'd like your message\nto get to your friendas quickly as possible\nand not go as many timesaround the world\nbefore it gets there.So what's the shortest amount\nof time or the fewest linksI have to use to get there?Lots of nice biological problems\nthat also captured this piece.So here is an example.And we're going to\nuse this to lookat two different\nkinds of algorithmsto solve this problem.This is a little navigation\nproblem from a set of cities.Think of it as flight paths.If you're from\nArizona, my apologies.But once you get to Phoenix,\nyou can't get out of thereunless you grow from\nthe ashes, I guess.[LAUGHTER]But you know, it's a\nway of dealing with howto get around in places.And to think about this,\nhere's the representationthat we'd have in the graph.The adjacency graph\nhere-- or adjacency listhere is, from Boston, I\ncan get to Providence.I can get to New York.From Providence, I\ncan get to Boston.I can get to New York.From New York, I can\nonly get to Chicago.", "start": 1800.0, "heat": 0.1}, {"text": "Chicago, I can go to\nDenver or Phoenix.Denver, I can go to\nPhoenix or New York.And from L.A., you can\nonly come back to Boston.And Phoenix has no\nexits out of it.So there is that representation.I just want to let you see that.Right?There are the keys\nin the dictionary.They're all the nodes.And there, each\none of those listsis a set of edges from the\nsource to the destination.OK.How would I build this?Well this is the\ncode I just ran.I just want to show it to you.I notice, by the way, in the\nslides I distributed earlier,the return g is missing there.If you want to correct it,\nI'll repost it later on.I'm going to create a\nlittle function that'sgoing to build a city graph.I'm going to pass in a type\nof graph, which I will thencall to create it.So I could make\nthis as a digraph.I could make it as a graph.I'm going to start off\nwith it as a digraph.And then notice what I do here.I just run over a little\nloop with a set of names,creating a node with\nthat name and thenadding it into the graph.All right, so node\nis a class instance.It creates-- or a\nclass definition--it creates an instance.And once I've got that, addNode\nas a method on the graph.It will simply add it in.And then this set here, is\nsimply adding in the edges.And I can do that.I'm capturing what I had\non that previous slide.And on a given\nname to getNode, itwill get out the actual node.And I use that coming\nout of the graph g.I do the same thing\nwith the getNodefrom graph g for Providence.And then I make an\nedge out of that.And then I use the method from\nthe graph to add the edge.If this looks like\na lot of code,yeah, it's a lot of words.But it's pretty straightforward.I'm literally creating\nnodes with the names,using the appropriate\nmethods, creating an edge,adding it into the graph.And when I'm done, I'm just\ngoing to return the graph g.OK.Now I want to find\nthe shortest path.", "start": 1920.0, "heat": 0.1}, {"text": "I'm going to show you two\ntechniques for doing this.The first one is called\ndepth first search.It's similar to something\nProfessor Guttag showed youwhen you sort of took the\nleft most depth first methodin terms of a search tree.The one trick here is, because\nI've got graphs not trees,there are the\npotential for loops.So I'm simply going to keep\ntrack of what's in the path.And I'm never going to\ngo back to a node that'salready in the path.So I don't just run in circles\ngoing from New York to Bostonto New York to\nBoston constantly.All right.So, the second thing\nI'm going to do hereis I'm going to take\nadvantage of a problem you'veseen before, which is this is\nliterally a version of divideand conquer.What does that mean?If I want to find a\npath from a source nodeto destination\nnode, if I can finda path to some intermediate\nnode from source intermediate,and then I find a path from\nintermediate to destination,the combination is obviously\na path the entire way.So recursively, I can\njust break this downinto simpler and simpler\nversions of that searchproblem.So here's the idea behind\ndepth first search.Start off with that source\nnode, that initial node.I'm going to look\nat all the edgesthat leave that\nnode in some order,however order it was\nput into the system.And I'm going to\nfollow the first edge.I'll check to see if I'm\nat the right location.If I am, I'm done.If I'm not, I'm going to\nfollow the first edge outof that node.So I'm actually creating\na little loop here.And I'm going to keep doing that\nuntil I either find the goalnode or I run out of options.So let me show you an example.I've got a little search\ntree here, a very simple one.Here's my source.There is my destination.In depth first, I'm going\nto start at the sourceand go down the first path.See if I'm at the right place.I'm not.So I'm going to take\nthe first path outof here, which\nmight be that one.See if I'm in the right place.", "start": 2040.0, "heat": 0.1}, {"text": "Actually, let me\nnot do it that way.Let me do it this way.Am I in the right place?I'm not.So I'm going to take\nthe first path outof this one, which\ngets me there.I'm still not in\nthe right place,so I'm going to take the\nfirst path out of that one.And you can see why\nit's called depth first.I'm going as deep, if you\nlike, in this graph as I can,from here, to there, to\nthere, to there, to there.At this stage, I'm stuck.There is no place\nto go to, so I'mgoing to go back to this node\nand say, is there another edge?In this case there isn't,\nso I'll go back to here.There's not another edge.Go back to here.There is another edge.So I'm going to\ngo this direction.And from here, I'll\nlook down there.OK, notice I'm now going depth\nfirst down the next chain.There's nothing from here.I backtrack.There's nothing from there.I backtrack over to here.There's no additional\nchoices there,so go all the way back to\nhere to follow that one.And then we'll go down this one\nagain, backtrack, backtrack,and eventually I find the\nthing I'm looking for.Depth first-- following\nmy way down this path.So let's write the\ncode for-- yes ma'am?AUDIENCE: Pardon me.Is the choice of\ndepth first nodewe go down, is that random?PROFESSOR: The question\nis, which node do I,or which edge do I choose?It's however I stored\nit in the system.So since it's a list, I'm\ngoing to just make that choice.I could have other\nways of deciding it.But think of it as,\nyeah, essentially random,which one I would pick.OK, let's look at the code.Don't panic.It's not as bad as it looks.It actually just\ncaptures that idea.Ignore for the moment\nthis down here.It's just going to set it up.Depth first search, I'm going\nto give it a graph, a startnode, an end node, and a path\nthat got me to that startnode, which initially\nis just goingto be an empty list,\nsomething that tells me what'sthe shortest path\nI've found so far,", "start": 2160.0, "heat": 0.1}, {"text": "which would be my best solution?And then just a little flag\nhere if I want to print outthings along the way.What do I do?I set up path to add\nin the start node.So if path initially\nis an empty list,the first time around is\njust, here's the node I'm at.I print out some stuff and\nthen I say, see if I'm done.I'm just going to stay at home.I'm not going to go anywhere.Unlikely to happen, but\nyou'll see recursivelywhy this is going to be nice.If I'm not done,\nthen notice the loop.I'm going to loop over all the\nchildren of the start node.Those are the edges I can reach.Then those I can reach\nwith a single edge.I pick the first one.And in answer to the\nquestion, in this case,it would be the order in\nwhich I started in the list.I just pick that one up.I then say, let's make sure\nit's not already in the pathbecause I want to avoid loops.And assuming it\nisn't, and assumingI don't yet have a solution,\nor the best solution I haveis smaller than what\nI've done so far,oh, cool, just do\nthe same search.So notice, there's\nthat nice recursion.Right?I'm going to explore.I just picked the first\noption out of that first node.And the first thing\nI do is try and seeif there's a path from that\nnode using the same thing.So it's literally like\nI picked this one.I don't care about\nthose other edges.I'm going to try and\ntake this search down.When it comes back\nwith a solution,as long as there\nis a solution, I'llsay that's my best\nsolution so far.And then I go back around.Now this last little\npiece here is just,if in fact the node's\nalready in the path,I'm just going to\nprint somethingthat says don't keep\ndoing it because youdon't need to keep going on.And I'm going to do that loop,\ntaking all the paths downuntil it comes back.And only at that stage do\nI go to the next portionaround this loop.The piece down here\njust sets this up,calling it with an initial\nempty list for path", "start": 2280.0, "heat": 0.153}, {"text": "and no solution for shortest.So it's just a nice way of\nputting a wrap around it thatgets things started up.This may look a little funky.It may look a\nlittle bit twisted.So let's see if it actually\ndoes what we'd expect it to.And to do that I'm just going\nto be a little test function.I'm going to build that\ncity graph I'm justgoing to call \"Shortest Path.\"I'm going to print it out.And I'd like to\nsee, is there a wayto get from Boston to Chicago?So let's go back over to\nmy Python and try that out.And I've got a call for that.Oh, and it prints out.I start off-- oh, so I\ndid it the wrong way.It's from Chicago to Boston.Yes, Chicago to Denver\nto Phoenix, from Denverto New York, it comes back and\nsays, I've already visited.Basically concludes I can't\nget from Chicago to Boston.It's just printing\nout each stage.Let's actually look\nat that a little morecarefully to see\nhow it got there.So there's my example.There is the adjacency list.And here's what happens.I start off in Chicago.So that's my first node.From Chicago, the first\nedge goes to Denver.Denver is not what\nI'm looking for.But since I am in\nDenver, recursively I'mgoing to call it again.So the first edge out\nof there is to Phoenix.Again, sorry if you're\nfrom Arizona and Phoenix.There's nowhere to go.So I'm going to\nhave to backtrack.And that will take\nme back up to Denver.And I look at the next edge.It takes me to New York.From New York I'd\nlike to go to Chicago.But oh, that's nice\nbecause, remember,that first check it says, is\nChicago already in the path?It is.I don't want to loop,\nbecause otherwise I'msimply going to go around\nand around and around here.And it may be good for\nfrequent flyer miles,but it's not a great way to get\nto where you're trying to go.So I break out of it.And now, what else\ndo I have left?Chicago to Denver I've explored.I'll look at Chicago to Phoenix.From Phoenix there's\nnowhere to go.", "start": 2400.0, "heat": 0.155}, {"text": "I go back up to Chicago.There are no more paths.I'm done.OK.Now, it turns out\nyou can actuallyget somewhere in this graph.So here's just another example.I'm simply going\nto show you, if Iwant to go from\nBoston to Phoenix,notice the set of stages.And you can see, notice\nhow at each stageit tends to be growing.That's that depth first.I'm exploring the edges.I find a path.That's great.But is it the shortest path?I don't know.So having found that path, I\ntry and take the next branch,which finds a loop.And I keep moving through\nthis, finding pathsuntil I look at all\nthe possible pathsand I actually return\nthe shortest path.You can try running\nthe code on it.But what I want you to\nsee is, again, this ideathat I can explore it.But in fact, I'm going\nto have to explore itin a particular order.But there is depth first search.It will find a solution for me.Alternative, it's what's\ncalled breadth first search.Sounds almost the same.Again, I'm going to start\noff with initial load.I'm going to look at\nall the edges thatleave that node, in some order.I'm going to follow the\nfirst edge as beforeand see if I'm at\nthe right place.If I'm not, I'm going\nto follow the next edgeand do the same thing.So whereas this went\ndown through the treeas deeply as it could of\nthe graph, in breadth first,I'm going to start off\ntaking that edge as before.I'm not done.I'm going to keep\ntrack of that in case Iwant to explore more of it.But I'm going to go back over\nhere and follow that edge.I'm not done.Again, I'll keep track of that,\nbut I'll come back up hereand explore that one.And oh, cool, I found a\nsolution in three steps.I've reached the destination.And notice, because\nI'm exploringall the paths of\nlength one before Iget to paths of length two.Once I find a solution,\nI can stop because I", "start": 2520.0, "heat": 0.1}, {"text": "know it's the shortest path.Any other path through\nhere would be longerthan that particular solution.So the loop here is\na little different.I'm looking over all\nthe paths of length one.There are all the\npaths of length two.And the one thing I'm\ngoing to have to dois I'm going to have to keep\ntrack of the remaining optionshere in case I have\nto come down to them.Because if I didn't find\nit at the first level,then I come down here and\nlook at things of length two.OK?So let's build that code.Breadth first search, or\nBFS, again, a graph, a start,and an end node, something that\nwould just print things outas I go along.My initial path is\njust the start point.But now I've got to keep track\nof what are the paths that Ihave yet to explore?And so for that,\nI'm going to createsomething called a queue.And a queue is going\nto be a list of paths.Remember, a path\nis a list of nodes.A queue is going to\nbe a list of paths.So the initial queue is\njust where I've started.And then, as long as I've got\nsomething still to exploreand I haven't found\na solution, I'mgoing to pop off the\nqueue the oldest element,the thing at the beginning.That's my temporary path.I'll print out some\ninformation about it.And then I'll grab the\nlast element of that path.That's the last\npoint in that path.And I'll now explore.Is it the thing I'm looking for?In which case I'm done.I'll return the path.Otherwise, for each node that\nyou can reach from that point,create a new path by adding\nthat on the end of this pathand add it into the queue\nat the end of the queue.So I'm going to\nkeep looping aroundhere until I either\nfind a solution here,which I'll return.And if I get through all of\nit, I'm going to return none.And right there, there\nis that nice thing whereonce I find a solution, I\nknow it's the shortest thing,I can stop.OK, let's look at\nan example of this.", "start": 2640.0, "heat": 0.169}, {"text": "So I'm going to go back\nover to Python, whereI've got a version of this.I'm going to comment that out.And down here in\nbreadth first search,I've actually added a\nlittle piece of codethat I don't have in\nthe handout that'sgoing to print out the\nqueue as well so we can seewhat happens when we call this.So let's take a look at it.My initial call, there's\none thing in the queue.It's just Boston.I started in Boston.So the current path\nis to start in Boston.I take that element\noff the queue,and I say what are the things\nI can reach from Boston?Oh, nice, I put two things in.I can get from\nBoston to Providence.I can get from\nBoston to New York.The top thing is\ngone off the queue.I popped it.I've replaced it\nwith two things.Or I take this, and\nsay, OK, from Bostonto Providence, where can\nI get from Providence?Oh, I can get to New York.So I put that in the queue.This has gone off.That one is still there.And I do that\nbecause I haven't yetreached the thing I'm looking\nfor, which was, I think,Phoenix I was trying to get to.And you could see\nat each stage, I'mtaking the top\nthing off the queue,and asking for all the\nthings that I can get to,and adding them to it.And notice, in some cases,\nit may be more than one.For example, which\none do I want here?Right here, if I take\nBoston, New York to Chicago,from Chicago I\ncan get to Denver.So there's one new path.I can also get to Phoenix.There's a second new path.Also notice how they\nare only growing slowlyas I build them out.And in fact, if we go back,\nwe can see that nicelyby looking at what happens if\nwe were to actually trace thisalong.So Boston to Phoenix,\nI start at Boston.Then I look at\nthat and then that.Those are all the\npaths of length one.Having exhausted\nthose, oh nice, I'mlooking at paths of length two,\nand then paths of length three,", "start": 2760.0, "heat": 0.236}, {"text": "and then paths the\nlength four, until Ifound the one that I wanted.And here's one other\nway of looking at it.Breadth first says, I'll look\nat each path of length one.And then, oh yes,\nI avoid the loop.I look at each\npath of length two,then paths of length\nthree, until I actuallyfind the solution.Subtle difference,\ndifferent performance.Depth first, I'm\nalways followingthe next available edge until\nI get stuck and I backtrack.Breadth first, I'm always\nexploring the next equal lengthoption.And I just have to keep\ntrack in that queueof the things I have left to\ndo as I walk my way through.What about weighted\nshortest path?Well, as the\nmathematicians say, weleave this is an easy\nexercise for the reader.It's a little unfair.The idea would be, imagine on\nmy edges, it's not just a step,but I have a weight.Flying to L.A. Is a\nlittle longer than flyingfrom Boston to New York.What I'd like to do is do the\nsame kind of optimization,but now just minimizing the sum\nof the weights on the edges,not the number of edges.As you might guess,\ndepth first searchis easily modified to do this.The cost now would\nsimply be what'sthe sum of those weights?And again, I would have to\nsearch all possible optionstill I find a solution.Unfortunately,\nbreadth first searchcan't easily be modified because\nthe short weighted path mayhave many more than the\nminimum number of loops.And I'd have to think\nabout how to adjustit to make that happen.But to pull it together,\nhere's a new model--graphs.Great way of\nrepresenting networks,collections of entities with\nrelationships between them.There are lots of nice\ngraph optimization problems.And we've just shown you\ntwo examples of that.But we'll come back to more\nexamples as we go along.", "start": 2880.0, "heat": 0.279}, {"text": "And with that, we'll\nsee you next time.", "start": 3000.0, "heat": 0.159}]