[{"text": "The following\ncontent is providedunder a Creative\nCommons license.Your support will help MIT\nOpenCourseWare continueto offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Hi.I'm Srini Devadas.I'm a professor of electrical\nengineering and computerscience.I'm going to be co-lecturing\n6.006-- Introductionto Algorithms-- this term\nwith professor Erik Domane.Eric, say hi.ERIK DOMANE: Hi.[LAUGHTER]PROFESSOR: And we\nhope you're goingto have a fun time\nin 6.006 learninga variety of algorithms.What I want to do today is\nspend literally a minute or soon administrative\ndetails, maybe even less.What I'd like to\ndo is to tell youto go to the website that's\nlisted up there and read it.And you'll get all\ninformation youneed about what this class\nis about from a standpointof syllabus; what's expected\nof you; the problem setschedule; the quiz schedule;\nand so on and so forth.I want to dive right in and tell\nyou about interesting things,like algorithms and\ncomplexity of algorithms.I want to spend\nsome time giving youan overview of the\ncourse content.And then we're\ngoing to dive rightin and look at a\nparticular problem of peakfinding-- both the one\ndimensional version and a twodimensional version-- and\ntalk about algorithms to solvethis peak finding problem--\nboth varieties of it.And you'll find\nthat there's reallya difference between\nthese various algorithmsthat we'll look at in\nterms of their complexity.And what I mean\nby that is you'regoing to have different run\ntimes of these algorithms", "start": 0.0, "heat": 0.115}, {"text": "depending on input\nsize, based on howefficient these algorithms are.And a prerequisite for\nthis class is 6.042.And in 6.042 you learned\nabout asymptotic complexity.And you'll see that\nin this lecturewe'll analyze relatively\nsimple algorithms todayin terms of their\nasymptotic complexity.And you'll be able\nto compare and saythat this algorithm is fasten\nthis other one-- assumingthat you have large\ninputs-- because it'sasymptotically less complex.So let's dive right in\nand talk about the class.So the one sentence\nsummary of this classis that this is about\nefficient proceduresfor solving problems\non large inputs.And when I say large\ninputs, I mean thingslike the US highway\nsystem, a mapof all of the highways\nin the United States;the human genome, which\nhas a billion lettersin its alphabet; a social\nnetwork responding to Facebook,that I guess has 500\nmillion nodes or so.So these are large inputs.Now our definition of large has\nreally changed with the times.And so really the 21st\ncentury definition of largeis, I guess, a trillion.Right?Back when I was your age\nlarge was like 1,000.[LAUGHTER]I guess I'm dating myself here.Back when Eric was your\nage, it was a million.Right?[LAUGHTER]But what's happening really\nthe world is moving faster,things are getting bigger.We have the capability of\ncomputing on large inputs,", "start": 120.0, "heat": 0.158}, {"text": "but that doesn't\nmean that efficiencyisn't of paramount concern.The fact of matter is\nthat you can, maybe,scan a billion elements\nin a matter of seconds.But if you had an algorithm\nthat required cubic complexity,suddenly you're not talking\nabout 10 raised to 9,you're talking about\n10 raised to 27.And even current\ncomputers can't reallyhandle those kinds of numbers,\nso efficiency is a concern.And as inputs get larger, it\nbecomes more of a concern.All right?So we're concerned about----efficient procedures-- for\nsolving large scale problemsin this class.And we're concerned\nabout scalability,because-- just as,\nyou know, 1,000was a big number a\ncouple of decades ago,and now it's kind of\na small number-- it'squite possible that by the\ntime you guys are professorsteaching this class\nin some universitythat a trillion is going\nto be a small number.And we're going to be talking\nabout-- I don't know--10 raised to 18\nas being somethingthat we're concerned with from\na standpoint of a common caseinput for an algorithm.So scalability is important.And we want to be able to track\nhow our algorithms are goingto do as inputs get\nlarger and larger.You going to learn a bunch\nof different data structures.We'll call them classic\ndata structures,like binary search\ntrees, hash tables-- that", "start": 240.0, "heat": 0.1}, {"text": "are called dictionaries\nin Python-- and datastructures-- such as balanced\nbinary search trees-- thatare more efficient than just\nthe regular binary search trees.And these are all\ndata structuresthat were invented\nmany decades ago.But they've stood\nthe test of time,and they continue to be useful.We're going to augment these\ndata structures in various waysto make them more efficient\nfor certain kinds of problems.And while you're not going to be\ndoing a whole lot of algorithmdesign in this\nclass, you will bedoing some design and a\nwhole lot of analysis.The class following this\none, 6.046 Designing Analysisof Algorithms, is\na class that youshould take if\nyou like this one.And you can do a whole lot more\ndesign of algorithms in 6.046.But you will look at\nclassic data structuresand classical algorithms\nfor these data structures,including things like sorting\nand matching, and so on.And one of the nice\nthings about this classis that you'll be doing real\nimplementations of these datastructures and\nalgorithms in Python.And in particular are\neach of the problemsets in this class are\ngoing to have both a theorypart to them, and a\nprogramming part to them.So hopefully it'll\nall tie together.The kinds of things we're going\nto be talking about in lecturesand recitations are going\nto be directly connectedto the theory parts\nof the problem sets.And you'll be programming the\nalgorithms that we talk aboutin lecture, or augmenting\nthem, running them.Figuring out whether they work\nwell on large inputs or not.", "start": 360.0, "heat": 0.1}, {"text": "So let me talk a little\nbit about the modulesin this class and\nthe problem sets.And we hope that\nthese problem setsare going to be fun for you.And by fun I don't mean easy.I mean challenging and\nworthwhile, so at the end of ityou feel like you've\nlearned something,and you had some\nfun along the way.All right?So content wise----we have eight\nmodules in the class.Each of which,\nroughly speaking, hasa problem set\nassociated with it.The first of these is what\nwe call algorithmic thinking.And we'll kick start\nthat one today.We'll look at a particular\nproblem, as I mentioned,of peak finding.And as part of\nthis, you're goingto have a problem set that's\ngoing to go out today as well.And you'll find that\nin this problem setsome of these algorithms\nI talk about today willbe coded in Python and given to.A couple of them are going\nto have bugs in them.You'll have to analyze the\ncomplexity of these algorithms;figure out which ones are\ncorrect and efficient;and write a proof\nfor one of them.All right?So that's sort of an\nexample problem set.And you can expect that\nmost of the problem setsare going to follow\nthat sort of template.All right.So you'll get a\nbetter sense of thisby the end of the\nday today for sure.Or a concrete sense\nof this, because we'llbe done with lecture and you'll\nsee your first problem set.We're going to be doing a\nmodule on sorting and trees.Sorting you now about,\nsorting a bunch of numbers.", "start": 480.0, "heat": 0.1}, {"text": "Imagine if you had\na trillion numbersand you wanted to sort them.What kind of algorithm\ncould use for that?Trees are a wonderful\ndata structure.There's different varieties, the\nmost common being binary trees.And there's ways of doing\nall sorts of things,like scheduling, and sorting,\nusing various kinds of trees,including binary trees.And we have a problem set on\nsimulating a logic networkusing a particular kind of\nsorting algorithm in a datastructure.That is going to be\nyour second problem set.And more quickly, we're going\nto have modules on hashing,where we do things\nlike genome comparison.In past terms we compared a\nhuman genome to a rat genome,and discovered they\nwere pretty similar.99% similar, which\nis kind of amazing.But again, these things\nare so large that youhave to have efficiency\nin the comparison methodsthat you use.And you'll find that if you\ndon't get the complexity lowenough, you just won't\nbe able to complete--your program won't be able to\nfinish running within the timethat your problem set is do.Right?Which is a bit of a problem.So that's something to keep\nin mind as you test your code.The fact is that you will get\nlarge inputs to run your code.And you want to keep\ncomplexity in mindas you're coding and thinking\nabout the pseudocode,if you will, of your\nalgorithm itself.We will talk about numerics.A lot of the time we talk\nabout such large numbersthat 32 bits isn't enough.Or 64 bits isn't enough to\nrepresent these numbers.These numbers have\nthousands of bits.A good example is\nRSA encryption,", "start": 600.0, "heat": 0.1}, {"text": "that is used in\nSSL, for example.And when you go-- use\nhttps on websites,RSA is used at the back end.And typically you work\nwith prime numbersthat are thousands\nof bits long in RSA.So how do you handle that?How does Python handle that?How do you write\nalgorithms that candeal with what are called\ninfinite precision numbers?So we have a module on numerics\nin the middle of the term thattalks about that.Graphs, really a\nfundamental data structurein all of computer science.You might have heard of the\nfamous Rubik's cube assignmentfrom .006 a 2 by 2 by 2 Rubik's cube.What's the minimum\nnumber of movesnecessary to go from a\ngiven starting configurationto the final end configuration,\nwhere all of the faces-- eachof the faces has uniform color?And that can be posed\nas a graph problem.We'll probably do\nthat one this term.In previous terms\nwe've done other thingslike the 15 puzzle.And so some of\nthese are tentative.We definitely know what the\nfirst problem set is like,but the rest of them are,\nat this moment, tentative.And to finish up shortest paths.Again in terms past\nwe've asked youto write code using a\nparticular algorithm thatfinds the shortest path\nfrom Caltech to MIT.This time we may do things\na little bit differently.We were thinking maybe we'll\ngive you a street map of Bostonand go figure out\nif Paul Revere usedthe shortest path to get\nto where he was going,or things like that.We'll try and make it fun.Dynamic programming is an\nimportant algorithm designtechnique that's used\nin many, many problems.", "start": 720.0, "heat": 0.1}, {"text": "And it can be used to do a\nvariety of things, includingimage compression.How do you compress an image\nso the number of pixelsreduces, but it still\nlooks like the imagethat you started out with,\nthat had many more pixels?All right?So you could use dynamic\nprogramming for that.And finally, advanced topics,\ncomplexity theory, researchand algorithms.Hopefully by now-- by\nthis time in the course,you have been sold\non algorithms.And most, if not\nall of you, wouldwant to pursue a\ncarrier in algorithms.And we'll give you a sense\nof what else is there.We're just scratching the\nsurface in this class,and there's many, many\nclasses that you can possiblytake if you want to continue\nin-- to learn about algorithms,or to pursue a\ncareer in algorithms.All right?So that's the\nstory of the class,or the synopsis of the class.And I encourage you to go spend\na few minutes on the website.In particular please read the\ncollaboration policy, and geta sense of what is\nexpected of you.What the rules are in terms\nof doing the problem sets.And the course\ngrading break down,the grading policies are all\nlisted on the website as well.All right.OK.So let's get started.I want to talk about\na specific problem.And talk about algorithms\nfor a specific problem.We picked this problem, because\nit's so easy to understand.And they're fairly\nstraightforward algorithmsthat are not particularly\nefficient to solvethis problem.And so this is a, kind\nof, a toy problem.But like a lot of\ntoy problems, it'svery evocative in that it\npoints out the issues involvedin designing\nefficient algorithms.So we'll start with\na one dimensionalversion of what we\ncall peak finding.", "start": 840.0, "heat": 0.1}, {"text": "And a peak finder is something\nin the one dimensional case.Runs on an array of numbers.And I'm just putting----symbols for each of\nthese numbers here.And the numbers are\npositive, negative.We'll just assume\nthey're all positive,it doesn't really matter.The algorithms we\ndescribe will work.And so we have this\none dimensional arraythat has nine\ndifferent positions.And a through i are numbers.And we want to find a peak.And so we have to define\nwhat we mean by a peak.And so, in particular,\nas an example,position 2 is a\npeak if, and onlyif, b greater than or equal to\na, and b greater than or equalto c.So it's really a very local\nproperty correspondingto a peak.In the one dimensional\ncase, it's trivial.Look to your left.Look to your right.If you are equal or greater\nthan both of the elementsthat you see on the left and\nthe right, you're a peak.OK?And in the case of\nthe edges, you onlyhave to look to one side.So position 9 is a peak if i\ngreater than or equal to h.So you just have to\nlook to your left there,because you're all the way\non the right hand side.All right?So that's it.", "start": 960.0, "heat": 0.1}, {"text": "And the statement of the\nproblem, the one dimensionalversion, is find the\npeak if it exists.All right?That's all there is to it.I'm going to give you a\nstraightforward algorithm.And then we'll see\nif we can improve it.All right?You can imagine that the\nstraightforward algorithm issomething that just, you\nknow, walks across the array.But we need that as a starting\npoint for building somethingmore sophisticated.So let's say we start\nfrom left and allwe have is one\ntraversal, really.So let's say we have\n1, 2, and then wehave n over 2 over\nhere correspondingto the middle of\nthis n element array.And then we have\nn minus 1, and n.What I'm interested\nin doing is, not onlycoming up with a\nstraightforward algorithm,but also precisely\ncharacterizingwhat its complexity\nis in relationto n, which is the\nnumber of inputs.Yeah?Question?AUDIENCE: Why do\nyou say if it existswhen the criteria\nin the [INAUDIBLE]guarantees [INAUDIBLE]?PROFESSOR: That's exactly right.I was going to get to that.So if you look at the\ndefinition of the peak,then what I have here is\ngreater than or equal to.OK?And so this-- That's a great\nquestion that was asked.Why is there \"if it\nexists\" in this problem?", "start": 1080.0, "heat": 0.0}, {"text": "Now in the case where I have\ngreater than or equal to,then-- this is a homework\nquestion for you,and for the rest of you-- argue\nthat any array will alwayshave a peak.OK?Now if you didn't have the\ngreater than or equal to,and you had a greater than,\nthen can you make that argument?No, you can't.Right?So great question.In this case it's\njust a question--You would want to\nmodify this problemstatement to find the peak.But if I had a different\ndefinition of a peak-- and thisis part of algorithmic thinking.You want to be able to create\nalgorithms that are general,so if the problem\ndefinition changes on you,you still have a starting\npoint to go attackthe second version\nof the problem.OK?So you could eliminate\nthis in the caseof the greater than or\nequal to definition.The \"if it exists\", because\na peak will always exist.But you probably want\nto argue that whenyou want to show the\ncorrectness of your algorithm.And if in fact you had\na different definition,well you would have to create\nan algorithm that tells youfor sure that a peak\ndoesn't exist, or finda peak if it exists.All right?So that's really\nthe general case.Many a time it's possible that\nyou're asked to do something,and you can't actually give\nan answer to the question,or find something that satisfies\nall the constraints required.And in that case, you want to\nbe able to put up your handand say, you know what?I searched long and hard.I searched exhaustively.Here's my argument that\nI searched exhaustively,and I couldn't find it.Right?If you do that, you\nget to keep your job.Right?Otherwise there's\nalways the casethat you didn't\nsearch hard enough.So it's nice to\nhave that argument.", "start": 1200.0, "heat": 0.0}, {"text": "All right?Great.Thanks for the question.Feel free to interrupt.Raise your hand, and\nI'm watching you guys,and I'm happy to answer\nquestions at any time.So let's talk about the\nstraightforward algorithm.The straightforward\nalgorithm is somethingthat starts from the left\nand just walks across.And you might have something\nthat looks like that.All right?By that-- By this I mean\nthe numbers are increasingas you start from the\nleft, the peak is somewherein the middle, and then\nthings start decreasing.Right?So in this case, you know,\nthis might be the peak.You also may have\na situation wherethe peak is all the\nway on the right,you started from the left.And it's 1, 2, 3,\n4, 5, 6, literallyin terms of the numbers.And you're going to look at\nn elements going all the wayto the right in order\nto find the peak.So in the case of\nthe middle you'dlook at n over 2 elements.If it was right in the middle.And the complexity,\nworst case complexity----is what we call theta n.And it's theta n, because\nin the worst case,you may have to look\nat all n elements.And that would be the case\nwhere you started from the leftand you had to go all\nthe way to the right.Now remember theta n is\nessentially somethingthat's says of the order of n.So it gives you both the lower\nbound and an upper bound.Big [? O ?] of n is\njust upper bound.And what we're\nsaying here is, we'resaying this algorithm\nthat starts from the leftis going to, essentially,\nrequire in the worst case", "start": 1320.0, "heat": 0.0}, {"text": "something that's a\nconstant times n.OK?And you know that\nconstant could be 1.You could certainly\nset things up that way.Or if you had a different\nkind of algorithm,maybe you could work\non the constant.But bottom line, we're only\nconcerned, at this moment,about as asymptotic complexity.And the asymptotic complexity\nof this algorithm is linear.All right?That make sense?OK.So someone help me do better.How can we do better?How can we lower the\nasymptotic complexityof a one dimensional\npeak finder?Anybody want to\ntake a stab at that?Yeah?Back there.AUDIENCE: Do a\nbinary search subset.You look at the\nmiddle, and whateveris higher-- whichever side is\nhigher, then cut that in half,because you know there's a peak.PROFESSOR: On--AUDIENCE: For example\nif you're in the middleon the right side--\nthere's a higher numberon the right side--\nthen you would justlook at that, because you know\nthat your peak's somewherein there.And you continue\ncutting in half.PROFESSOR: Excellent!Excellent!That's exactly right.So you can-- You can do\nsomething different, whichis essentially try and\nbreak up this problem.Use a divide and conquer\nstrategy, and recursively breakup this one dimensional\narray into smaller arrays.And try and get this\ncomplexity down.Yeah?AUDIENCE: Are we assuming\nthat there's only one peak?PROFESSOR: No, we're not.AUDIENCE: OK.PROFESSOR: It's find\na peak if it exists.And in this case\nit's, \"find a peak\",because of the definition.We don't really need\nthis as it was discussed.All right?OK.So--So that was a great answer,\nand-- You know this classafter while is\ngoing to get boring.Right?Every class gets boring.So we, you know, try and\nbreak the monotony here a bit.", "start": 1440.0, "heat": 0.0}, {"text": "And so-- And then the other\nthing that we realizedwas that these seats\nyou're sitting on-- thisis a nice classroom-- but\nthe seats you're sitting onare kind of hard.Right?So what Eric and I\ndid was we decidedwe'll help you guys\nout, especially the oneswho are-- who are\ninteracting with us.And we have these--[LAUGHTER]--cushions that\nare 6.006 cushions.And, you know, that's a 2\nby 2 by 2 Rubik's cube here.And since you answered the first\nquestion, you get a cushion.This is kind of like a\nFrisbee, but not really.So--[LAUGHTER]I'm not sure-- I'm not sure\nI'm going to get it to you.But the other\nthing I want to sayis this is not a baseball game.Right?Where you just grab the\nball as it comes by.This is meant for him, my\nfriend in the red shirt.So here you go.Ah, too bad.All right.It is soft.So, you know, it won't-- it\nwon't hurt you if hits you.[LAUGHTER]All right.So we got a bunch of these.And raise your hands,\nyou know, goingto ask-- There's going\nto be-- I think-- There'ssome trivial questions that\nwe're going to ask justto make sure you're awake.So an answer to that\ndoesn't get you a cushion.But an answer like--\nWhat's your name?AUDIENCE: Chase.PROFESSOR: Chase.An answer like\nChase just gave is--that's a good answer to\na nontrivial question.That gets you a cushion.OK?All right, great.So let's put up by\nChase's algorithm up here.I'm going to write it\nout for the 1D version.So what we have here is\na recursive algorithm.", "start": 1560.0, "heat": 0.0}, {"text": "So the picture you want\nto keep in your headis this picture\nthat I put up there.And this is a divide\nand conquer algorithm.You're going to see this over\nand over-- this paradigm--over and over in 6.006.We're going to look at\nthe n over 2 position.And we're going to\nlook to the left,and we're going to\nlook to the right.And we're going to\ndo that in sequence.So----if a n over 2 is less than\na n over 2 minus 1, then----only look at the left half.1 through n over 2 minus 1 to\nlook for peak-- for a peak.All right?So that's step one.And you know I could\nput it on the right handside or the left hand side,\ndoesn't really matter.I chose to do the left hand\nside first, the left half.And so what I've done is,\nthrough that one step,if in fact you have that\ncondition-- a n over 2is less than a n over 2 minus\n1-- then you move to your leftand you work on one\nhalf of the problem.But if that's not the case,\nthen if n over-- n over 2is less than a over n\nover-- n by 2 plus 1,then only look at n over 2\nplus 1 through n for a peak.So I haven't bothered\nwriting out all the words.They're exactly the same\nas the left hand side.", "start": 1680.0, "heat": 0.0}, {"text": "You just look to\nthe right hand side.Otherwise if both of these\nconditions don't fire,you're actually done.OK?That's actually the best case\nin terms of finishing early,at least in this recursive step.Because now the n over\n2 position is a peak.Because what you found is\nthat the n over 2 positionis greater than or equal to\nboth of its adjacent positions,and that's exactly the\ndefinition of a peak.So you're done.OK?So all of this is good.You want to write an argument\nthat this algorithm is correct.And I'm not going\nto bother with that.I just wave my hands a\nbit, and you all nodded,so we're done with that.But the point being you\nwill see in your problem seta precise argument for a more\ncomplicated algorithm, the 2Dversion of this.And that should be a template\nfor you to go write a proof,or an argument, a\nformal argument,that a particular\nalgorithm is correct.That it does what\nit claims to do.And in this case it's two,\nthree lines of careful reasoningthat essentially say, given\nthe definition of the peak,that this is going to\nfind a peak in the arraythat you're given.All right?So we all believe that\nthis algorithm is correct.Let's talk now about the\ncomplexity of this algorithm.Because the whole\npoint of this algorithmwas because we didn't\nlike this thetan complexity corresponding to\nthe straightforward algorithm.So it'd like to do better.", "start": 1800.0, "heat": 0.0}, {"text": "So what I'd like to\ndo is ask one of youto give me a recurrence relation\nof the kind, you know, T of nequals blah, blah, blah.That would correspond to\nthis recursive algorithm,this divide and\nconquer algorithm.And then using that, I'd like\nto get to the actual complexityin terms of what the theta\nof complexity corresponds to.Yeah?Back there?AUDIENCE: So the worst\ncase scenario if T of nis going to be some\nconstant amount of time--PROFESSOR: Yep.AUDIENCE: --it takes to\ninvestigate whether a certainelement is [INAUDIBLE], plus--[COUGH]--T of n over 2?PROFESSOR: Great.Exactly right.That's exactly right.So if you look at this\nalgorithm and you say,from a computation\nstandpoint, can Iwrite an equation\ncorresponding to the executionof this algorithm?And you say, T of n is the work\nthat this algorithm does on--as input of size n.OK?Then I can write this equation.And this theta 1 corresponds\nto the two comparisonsthat you do looking at--\npotentially the two comparisonsthat you do-- looking\nat the left handside and the right hand side.So that's-- 2 is a constant,\nso that's why we put theta 1.All right?So you get a cushion, too.Watch out guys.Whoa!Oh actually that wasn't so bad.Good.Veers left, Eric.Veers left.So if you take this and\nyou start expanding it,", "start": 1920.0, "heat": 0.0}, {"text": "eventually you're going\nto get to the basecase, which is T\nof 1 is theta 1.Right?Because you have a one element\narray you just for that arrayit's just going to\nreturn that as a peak.And so if you do that, and\nyou expand it all the way out,then you can write T of n\nequals theta 1 plus theta 1.And you're going to do this\nlog to the base 2 of n times.And adding these\nall up, gives youa complexity theta log 2 of n.Right?So now you compare\nthis with that.And there's really\na huge difference.There's an exponential\ndifference.If you coded up this\nalgorithm in Python--and I did-- both these\nalgorithms for the 1D version--and if you run it on n\nbeing 10 million or so,then this algorithm\ntakes 13 seconds.OK?The-- The theta 10\nalgorithm takes 13 seconds.And this one takes\n0.001 seconds.OK?Huge difference.So there is a big difference\nbetween theta n and theta logn.It's literally the difference\nbetween 2 raised to n, and n.It makes sense to try\nand reduce complexityas you can see,\nespecially if you'retalking about large inputs.All right?And you'll see that\nmore clearly as wego to a 2D version\nof this problem.All right?So you can't really\ndo better for the 1D.The 1D is a\nstraightforward problem.It gets a little\nmore interesting--the problems get a\nlittle-- excuse me,", "start": 2040.0, "heat": 0.0}, {"text": "the algorithms get a\nlittle more sophisticatedwhen we look at a 2D\nversion of peak finding.So let's talk about\nthe 2D version.So as you can imagine\nin the 2D versionyou have a matrix, or a\ntwo dimensional array.And we'll say this thing\nhas n rows and m columns.And now we have to\ndefine what a peak is.And it's a hill.It's the obvious\ndefinition of a peak.So if you had a in\nhere, c, b, d, e.Then as you can guess, a is\na 2D peak if, and only if,a greater than or equal to b;\na greater than or equal to d, cand e.All right?So it's a little hill up there.All right?And again I've used the\ngreater than or equal to here,so that's similar to\nthe 1D in the casethat you'll always find\na peak in any 2D matrix.Now again I'll give you the\nstraightforward algorithm,and we'll call it the\nGreedy Ascent algorithm.And the Greedy Ascent algorithm\nessentially picks a directionand, you know, tries to\nfollow that direction in orderto find a peak.So for example, if I\nhad this particular--", "start": 2160.0, "heat": 0.0}, {"text": "--matrix; 14, 13,\n12, 15, 9, 11, 17--Then what might happen is if\nI started at some arbitrarymidpoint-- So the\nGreedy Ascent algorithmhas to make choices\nas to where to start.Just like we had\ndifferent cases here,you have to make a choice\nas to where to start.You might want to\nstart in the middle,and you might want to\nwork your way left first.Or you're going to all--\nYou just keep going left,our keep going right.And if you hit an\nedge, you go down.So you make some choices as\nto what the default traversaldirections are.And so if you say you\nwant to start with 12,you are going to go look\nfor something to left.And if it's greater than, you're\ngoing to follow that direction.If it's not, if it's\nless, then you'regoing to go in the other\ndirection, in this case,for example.So in this case you'll go to\n12, 13 , 14, 15, 16, 17, 19,and 20.And you'd find-- You\n'd find this peak.Now I haven't given you\nthe specific detailsof a Greedy Ascent algorithm.But I think if you look at\nthe worst case possibilitieshere, with respect\nto a given matrix,and for any given\nstarting point,and for any given strategy-- in\nterms of choosing left first,versus right first, or down\nfirst versus up first--you will have a\nsituation where-- justlike we had in the 1D\ncase-- you may end uptouching a large fraction of\nthe elements in this 2D array.", "start": 2280.0, "heat": 0.0}, {"text": "OK?So in this case, we\nended up, you know,touching a bunch of\ndifferent elements.And it's quite possible that\nyou could end up touching--starting from the midpoint--\nyou could up touching halfthe elements, and in some cases,\ntouching all the elements.So if you do a worst case\nanalysis of this algorithm--a particular algorithm with\nparticular choices in termsof the starting point and\nthe direction of search--a Greedy Ascent algorithm would\nhave theta n m complexity.All right?And in the case where n\nequals m, or m equals n,you'd have theta n\nsquared complexity.OK?I won't spend very\nmuch time on this,because I want to talk\nto you about the divideand conquer versions of this\nalgorithm for the 2D peak.But hopefully you're\nall with me with respectto what the worst\ncase complexity is.All right?People buy that?Yeah.Question back there.AUDIENCE: Can you-- Is\nthat an approximation?Or can you actually get\nto n times m traversals?PROFESSOR: So there are specific\nGreedy Ascent algorithms,and specific matrices\nwhere, if I give youthe code for the algorithm, and\nI give you a specific matrix,that I could make you touch\nall of these elements.That's correct.So we're talking\nabout worst case.You're being very\nparanoid when youtalk about worst\ncase complexity.And so I'm-- hand\nwaving a bit here,simply because I haven't\ngiven you the specificsof the algorithm yet.Right?This is really a\nset of algorithms,because I haven't\ngiven you the code,I haven't told you\nwhere it starts,and which direction it goes.But you go, do\nthat, fix it, and Iwould be the person who tries to\nfind the worst case complexity.Suddenly it's very\neasy to get to theta nm in terms of having some\nconstant multiplying n times m.", "start": 2400.0, "heat": 0.0}, {"text": "But you can definitely\nget to that constantbeing very close to 1.OK?If not 1.All right.So let's talk about\ndivide and conquer.And let's say that\nI did somethinglike this, where I just tried\nto jam the binary searchalgorithm into the 2D version.All right?So what I'm going to do is----I'm going to pick the middle\ncolumn, j equals m over 2.And I'm going to\nfind a 1D peak usingwhatever algorithm I want.And I'll probably end up using\nthe more efficient algorithm,the binary search\nversion that's goneall the way to the left\nof the board there.And let's say I find a\nbinary peak at (i, j).Because I've picked a column,\nand I'm just finding a 1D peak.So this is j equals m over 2.That's i.Now I use (i,j).In particular row i as a start----to find a 1D peak on row i.And I stand up here,\nI'm really happy.OK?Because I say, wow.I picked a middle column,\nI found a 1D peak,that is theta m complexity to\nfind a 1D peak as we argued.", "start": 2520.0, "heat": 0.0}, {"text": "And one side-- the theta m--AUDIENCE: Log n.PROFESSOR: Oh, I'm sorry.You're right.The log n complexity,\nthat's what this was.So I do have that here.Yeah.Log n complexity.Thanks, Eric.And then once I do that, I\ncan find a 1D peak on row i.In this case row\ni would be m wide,so it would be log m complexity.If n equals m, then I have\na couple of steps of log n,and I'm done.All right?Am I done?No.Can someone tell me\nwhy I'm not done?Precisely?Yep.AUDIENCE: Because when\nyou do the second partto find the peak in\nrow i, you might nothave that column\npeak-- There might notbe a peak on the column anymore.PROFESSOR: That's\nexactly correct.So this algorithm is incorrect.OK?It doesn't work.It's efficient, but incorrect.OK?It's-- You want to be correct.You know being correcting\nand inefficientis definitely better than\nbeing inefficient-- I'm sorry.Being incorrect and efficient.So this is an\nefficient algorithm,in the sense that it will\nonly take log n time,but it doesn't work.And I'll give you\na simple examplehere where it doesn't work.The problem is----a 2D peak----may not exist----on row i.And here's an example of that.Actually this is-- This is\nexactly the example of that.Let's say that I\nstarted with this row.", "start": 2640.0, "heat": 0.0}, {"text": "Since it's-- I'm starting\nwith the middle row,and I could start with\nthis one or that one.Let's say I started\nwith that one.I end up finding a peak.And if this were 10 up here,\nI'd choose 12 as a peak.And it's quite possible\nthat I return 12 as a peak.Even though 19 is\nbigger, because 12is a peak given\n10 and 11 up here.And then when I choose\nthis particular row,and I find a peak on\nthis row, it would be 14.That is a 1D peak on this row.But 14 is not a 2D peak.OK?So this particular example,\n14 would return 14.And 14 is not a 2D peak.All right?You can collect your\ncushion after the class.So not so good.Look like an efficient\nalgorithm, but doesn't work.All right?So how can we get to\nsomething that actually works?So the last algorithm that\nI'm going to show you--And you'll see four different\nalgorithms in your problemset----that you'll have to analyze\nthe complexity for and decideif they're efficient,\nand if they're correct.But here's a-- a\nrecursive versionthat is better than,\nin terms of complexity,than the Greedy\nAscent algorithm.And this one works.So what I'm going to do\nis pick a middle column.j equals m over 2 as before.I'm going to find the\nglobal maximum on column j.", "start": 2760.0, "heat": 0.0}, {"text": "And that's going\nto be at (i, j).I'm going to compare (i comma\nj minus 1), (i comma j),and (i,j plus 1).Which means that once I've\nfound the maximum in this row,all I'm going to look to\nthe left and the right,and compare.I'm going to pick\nthe left columns.If (i comma j minus 1) is\ngreater than (i comma j)--and similarly for the right.And if in fact I-- either\nof these two conditionsdon't fire, and what\nI have is (i comma j)is greater than or equal\nto (i comma j minus 1)and (i comma j plus\n1), then I'm done.Just like I had\nfor the 1D version.If (i comma j) is greater\nthan or equal to (i commaj minus 1), and (i comma j\nplus 1), that implies (i, j)is a 2D peak.OK?And the reason that\nis the case, isbecause (i comma j) was the\nmaximum element in that column.So you know that\nyou've compared itto all of the adjacent elements,\nlooking up and looking down,that's the maximum element.Now you've look at the\nleft and the right,and in fact it's greater\nthan or equal to the elementson the left and the right.And so therefore it's a 2D peak.OK?So in this case, when you pick\nthe left or the right columns--you'll pick one of\nthem-- you're goingto solve the new problem with\nhalf the number of columns.", "start": 2880.0, "heat": 0.0}, {"text": "All right?And again, you have to\ngo through an analysis,or an argument, to make sure\nthat this algorithm is correct.But its intuitively correct,\nsimply because it matchesthe 1D version\nmuch more closely.And you also have your condition\nwhere you break away righthere, where you have a 2D\npeak, just like the 1D version.And what you've done\nis break this matrix upinto half the size.And that's essentially\nwhy this algorithm works.When you have a single column----find the global\nmaximum and you're done.All right?So that's the base case.So let me end with\njust writing outwhat the recurrence relation\nfor the complexity of thisis, and argue what the overall\ncomplexity of this algorithmis.And then I'll give\nyou the bad news.All right.So overall what you have is, you\nhave something like T of (n, m)equals T of (n, m\nover 2) plus theta n.Why is that?Well n is the number of rows,\nm is the number of columns.In one case you'll be\nbreaking things downinto half the number of\ncolumns, which is m over 2.And in order to find\nthe global maximum,you'll be doing theta\nn work, because you're", "start": 3000.0, "heat": 0.0}, {"text": "finding the global maximum.Right?You just have to\nscan it-- this--That's the way-- That's\nwhat it's going to take.And so if you do that, and\nyou go run it through--and you know that T of\n(n, 1) is theta n-- whichis this last part over\nhere-- that's your base case.You get T of (n, m) is theta\nof n added to theta of n,log of m times--\nlog 2 of m times.Which is theta of\nn-- log 2 of m.All right?So you're not done\nwith peak finding.What you'll see is at four\nalgorithms coded in Python--I'm not going to give away\nwhat those algorithms are,but you'll have\nto recognize them.You will have seen versions\nof those algorithmsalready in lecture.And your job is going to be to\nanalyze the algorithms, as Isaid before, prove that\none of them is correct,and find counter-examples for\nthe ones that aren't correct.The course staff\nwill stick aroundhere to answer questions--\nlogistical questions--or questions about lecture.And I owe that\ngentleman a cushion.", "start": 3120.0, "heat": 0.0}]