[{"text": "The following\ncontent is providedunder a Creative\nCommons license.Your support will help MIT\nOpenCourseWare continueto offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Hey, everybody.You ready to learn\nsome algorithms?Yeah!Let's do it.I'm Eric Domain.You can call me Eric.And the last class, we\nsort of jumped into things.We studied peak\nfinding and lookedat a bunch of algorithms\nfor peak findingon your problem set.You've already\nseen a bunch more.And in this class, we're going\nto do some more algorithms.Don't worry.That will be at the end.We're going to talk about\nanother problem, documentdistance, which will be a\nrunning example for a bunchof topics that we\ncover in this class.But before we go there, I wanted\nto take a step back and talkabout, what actually\nis an algorithm?What is an algorithm\nallowed to do?And also deep philosophical\nquestions like, what is time?What is the running\ntime of an algorithm?How do we measure it?And what are the rules the game?For fun, I thought I\nwould first mentionwhere the word comes\nfrom, the word algorithm.It comes from this guy,\na little hard to spell.Al-Khwarizmi, who is sort\nof the father of algebra.He wrote this book called \"The\nCompendious Book on Calculationby Completion and\nBalancing\" back in the day.And it was in\nparticular about howto solve linear and\nquadratic equations.So the beginning of algebra.I don't think he invented\nthose techniques.But he was sort of\nthe textbook writerwho wrote sort of how\npeople solved them.And you can think\nof how to solvethose equations as\nearly algorithms.First, you take this number.You multiply by this.You add it or you reduce\nto squares, whatever.", "start": 0.0, "heat": 0.327}, {"text": "So that's where the word\nalgebra comes from and alsowhere the word\nalgorithm comes from.There aren't very many\nwords with these roots.So there you go.Some fun history.What's an algorithm?I'll start with sort of\nsome informal definitionsand then the point\nof this lecture.And the idea of a\nmodel of computationis to formally specify\nwhat an algorithm is.I don't want to get super\ntechnical and formal here,but I want to give\nyou some groundingso when we write Python code,\nwhen we write pseudocode,we have some idea what\nthings actually cost.This is a new lecture.We've never done\nthis before in 006.But I think it's important.So at a high level,\nyou can thinkof an algorithm is just\na-- I'm sure you'veseen the definition before.It's a way to define computation\nor computational procedurefor solving some problem.So whereas computer\ncode, I mean,it could just be running\nin the backgroundall the time doing whatever.An algorithm we think\nof as having some inputand generating some output.Usually, it's to\nsolve some problem.You want to know is this\nnumber prime, whatever.Question?AUDIENCE: Can you turn up\nthe volume for your mic?PROFESSOR: This microphone does\nnot feed into the AV system.So I shall just talk louder, OK?And quiet the set, please.OK, so that's an algorithm.You take some input.You run it through.You compute some output.Of course, computer\ncode can do this too.An algorithm is basically\nthe mathematical analogof a computer program.So if you want to reason about\nwhat computer programs do,you translate it into\nthe world algorithms.And vice versa, you want to\nsolve some problem-- first,you usually develop an\nalgorithm using mathematics,", "start": 120.0, "heat": 0.421}, {"text": "using this class.And then you convert\nit into computer code.And this class is about\nthat transition from oneto the other.You can draw a picture\nof sort of analogs.So an algorithm is a\nmathematical analogof a computer program.A computer program is built on\ntop of a programming language.And it's written in a\nprogramming language.The mathematical analog\nof a programming language,what we write algorithms\nin, usually wewrite them in pseudocode,\nwhich is basicallyanother fancy word for\nstructured English,good English, whatever\nyou want to say.Of course, you could use\nanother natural language.But the idea is, you need to\nexpress that algorithm in a waythat people can understand\nand reason about formally.So that's the structured part.Pseudocode means lots\nof different things.It's just sort of an abstract\nhow you would write downformal specification\nwithout necessarily beingable to actually run\nit on a computer.Though there's a particular\npseudocode in your textbookwhich you probably\ncould run on a computer.A lot of it, anyway.But you don't have\nto use that version.It just makes sense to humans\nwho do the mathematics.OK, and then ultimately, this\nprogram runs on a computer.You all have computers,\nprobably in your pockets.There's an analog of a computer\nin the mathematical world.And that is the\nmodel of computation.And that's sort of the focus of\nthe first part of this lecture.Model of computation says what\nyour computer is allowed to do,what it can do in\nconstant time, basically?And that's what I want\nto talk about here.So the model of computation\nspecifies basically", "start": 240.0, "heat": 0.236}, {"text": "what operations you\ncan do in an algorithmand how much they cost.This is the what is time.So for each\noperation, we're goingto specify how\nmuch time it costs.Then the algorithm does\na bunch of operations.They're combined together\nwith control flow,for loops, if statements,\nstuff like that which we're notgoing to worry about too much.But obviously, we'll\nuse them a lot.And what we count is how much\ndo each of the operations cost.You add them up.That is the total cost\nof your algorithm.So in particular, we\ncare mostly in this classabout running time.Each operation has a time cost.You add those up.That's running time\nof the algorithm.OK, so let's-- I'm going to\ncover two models of computationwhich you can just think of\nas different ways of thinking.You've probably seen\nthem in some senseas-- what you call them?Styles of programming.Object oriented style of\nprogramming, more assemblystyle of programming.There's lots of different\nstyles of programming languageswhich I'm not going\nto talk about here.But you've see analogs if\nyou've seen those before.And these models\nreally give you a wayof structuring your\nthinking about howyou write an algorithm.So they are the random access\nmachine and the pointermachine.So we'll start with random\naccess machine, also known", "start": 360.0, "heat": 0.336}, {"text": "as the RAM.Can someone tell me what\nelse RAM stands for?AUDIENCE: Random Access Memory?PROFESSOR: Random Access Memory.So this is both confusing\nbut also convenience.Because RAM simultaneously\nstands for two thingsand they mean almost the\nsame thing, but not quite.So I guess that's more\nconfusing than useful.But there you go.So we have random access memory.Oh, look at that.Fits perfectly.And so we're thinking,\nthis is a real--this is-- random access memory\nis over here in real computerland.That's like, D-RAM\nSD-RAM, whatever--the things you buy and stick\ninto your motherboard, your GP,or whatever.And over here, the mathematical\nanalog of-- so here's,it's a RAM.Here, it's also a RAM.Here, it's a random\naccess machine.Here, it's a random\naccess memory.It's technical detail.But the idea is, if you look\nat RAM that's in your computer,it's basically a\ngiant array, right?You can go from zero\nto, I don't know.A typical chip these days is\nlike four gigs in one thing.So you can go from\nzero to four gigs.You can access anything in the\nmiddle there in constant time.To access something, you\nneed to know where it is.That's random access memory.So that's an array.So I'll just draw a big picture.Here's an array.Now, RAM is usually\norganized by words.So these are a\nmachine word, whichwe're going to\nput in this model.And then there's address zero,\naddress one, address two.This is the fifth word.And just keeps going.You can think of\nthis as infinite.Or the amount that\nyou use, that'sthe space of your algorithm, if\nyou care about storage space.", "start": 480.0, "heat": 0.137}, {"text": "So that's basically it.OK, now how do we-- this is\nthe memory side of things.How do we actually\ncompute with it?It's very simple.We just say, in constant time,\nan algorithm can basicallyread in or load a constant\nnumber of words from memory,do a constant number of\ncomputations on them,and then write them out.It's usually called store.OK, it needs to know\nwhere these words are.It accesses them by address.And so I guess I\nshould write hereyou have a constant number of\nregisters just hanging around.So you load some\nwords into registers.You can do some computations\non those registers.And then you can\nwrite them back,storing them in\nlocations that arespecified by your registers.So you've ever done\nassembly programming,this is what assembly\nprogramming is like.And it can be rather annoying to\nwrite algorithms in this model.But in some sense,\nit is reality.This is how we think\nabout computers.If you ignore\nthings like caches,this is an accurate\nmodel of computationthat loading,\ncomputing, and storingall take roughly the\nsame amount of time.They all take constant time.You can manipulate a\nwhole word at a time.Now, what exactly is a word?You know, computers these days,\nit's like 32 bits or 64 bits.But we like to be a\nlittle bit more abstract.A word is w bits.It's slightly annoying.And most of this class, we won't\nreally worry about what w is.We'll assume that\nwe're given as inputa bunch of things\nwhich are words.So for example, peak finding.", "start": 600.0, "heat": 0.102}, {"text": "We're given a matrix of numbers.We didn't really say whether\nthey're integers or floatsor what.We don't worry about that.We just think of\nthem as words and weassume that we can\nmanipulate those words.In particular, given two\nnumbers, we can compare them.Which is bigger?And so we can determine,\nis this cell in the matrixa peak by comparing it with\nits neighbors in constant time.We didn't say why it was\nconstant time to do that.But now you kind of know.If those things are\nall words and youcan manipulate a constant number\nof words in constant time,you can tell whether a number\nis a peak in constant time.Some things like w should be at\nleast log the size of memory.Because my word should\nbe able to specifyan index into this array.And we might use that someday.But basically, don't\nworry about it.Words are words.Words come in as inputs.You can manipulate\nthem and you don'thave to worry about\nit for the most part.In unit four of\nthis class, we'regoing to talk about, what if we\nhave really giant integers thatdon't fit in a word?How do we manipulate them?How do we add them,\nmultiply them?So that's another topic.But most of this\nclass, we'll justassume everything we're\ngiven is one word.And it's easy to compute on.So this is a realistic\nmodel, more or less.And it's a powerful one.But a lot of the\ntime, a lot of codejust doesn't use\narrays-- doesn't need it.Sometimes we need arrays,\nsometimes we don't.Sometimes you feel like a\nnut, sometimes you don't.So it's useful to think about\nsomewhat more abstract modelsthat are not quite as\npowerful but offer a simplerway of thinking about things.For example, in\nthis model there'sno dynamic memory allocation.You probably know you could\nimplement dynamic memoryallocation because\nreal computers do it.But it's nice to\nthink about a modelwhere that's taken\ncare of for you.It's kind of like a higher\nlevel programming abstraction.", "start": 720.0, "heat": 0.415}, {"text": "So the one is useful in this\nclass is the pointer machine.This basically corresponds to\nobject oriented programmingin a simple, very\nsimple version.So we have dynamically\nallocated objects.And an object has a\nconstant number of fields.And a field is going to\nbe either a word-- so youcan think of this\nas, for example,storing an integer, one\nof the input objectsor something you computed on it\nor a counter, all these sortsof things-- or a pointer.And that's where pointer\nmachine gets its name.A pointer is something that\npoints to another objector has a special value\nnull, also known as nil,also known as none in Python.OK, how many people have\nheard about pointers before?Who hasn't?Willing to admit it?OK, only a few.That's good.You should have seen pointers.You may have heard\nthem called references.Modern languages these days\ndon't call them pointersbecause pointers are scary.But there's a very subtle\ndifference between them.And this model actually\nreally is references.But for whatever reason, it's\ncalled a pointer machine.It doesn't matter.The point is, you've\nseem linked lists I hope.And linked lists have a\nbunch of fields in each node.Maybe you've got a pointer\nto the previous element,a pointer to the next\nelement, and some value.", "start": 840.0, "heat": 0.736}, {"text": "So here's a very\nsimple linked list.This is what you'd call a\ndoubly linked list because ithas previous and next pointers.So the next pointer\npoints to this node.The previous pointer\npoints to this node.Next pointer points to null.The previous pointer\npoints to null, let's say.So that's a two node\ndoubly linked list.You presume we have a pointer\nto the head of the list,maybe a pointer to the\ntail of list, whatever.So this is a structure\nin the pointer machine.It's a data structure.In Python, you might\ncall this a named tuple,or it's just an object\nwith three attributes,I guess, they're\ncalled in Python.So here we have the value.That's a word like an integer.And then some things\ncan be pointersthat point to other nodes.And you can create a new node.You can destroy a node.That's the dynamic\nmemory allocation.In this model, yeah,\npointers are pointers.You can't touch them.Now, you can implement this\nmodel in a random accessmachine.A pointer becomes an index\ninto this giant table.And that's more like\nthe pointers in Cif you've ever\nwritten C programs.Because then you\ncan take a pointerand you can add one to it and\ngo to the next thing after that.In this model, you can\njust follow a pointer.That's all you can do.OK, following a pointer\ncosts constant time.Changing one of these\nfields costs constant time.All the usual things you might\nimagine doing to these objectstake constant time.So it's actually a weaker\nmodel than this one.Because you could\nimplement a pointer machinewith a random access machine.But it offers a different\nway of thinking.A lot of data structures\nare built this way.Cool.So that's the theory side.What I'd like to talk about\nnext is actually in Python,what's a reasonable\nmodel of what's going on?So these are old models.This goes back to the '80s.This one probably '80s or '70s.So they've been\naround a long time.", "start": 960.0, "heat": 0.382}, {"text": "People have used them forever.Python is obviously much\nmore recent, at leastmodern versions of Python.And it's the model of\ncomputation in some sensethat we use in this class.Because we're implementing\neverything in Python.And Python offers both a random\naccess machine perspectivebecause it has arrays, and\nit offers a pointer machineperspective because\nit has references,because it has pointers.So you can do either one.But it also has a\nlot of operations.It doesn't just have load\nand store and follow pointer.It's got things\nlike sort and appendand concatenation of two\nlists and lots of things.And each of those has a\ncost associated with them.So whereas the random access\nmachine and pointer machine,they're theoretical models.They're designed\nto be super simple.So it's clear that everything\nyou do takes constant time.In Python, some of the\noperations you can dotake a lot of time.Some of the operations in Python\ntake exponential time to do.And you've got to know when\nyou're writing your algorithmsdown either thinking in a Python\nmodel or your implementingyour algorithms\nin actual Python,which operations are\nfast and which are slow.And that's what I'd like to\nspend the next few minutes on.There's a lot of operations.I'm not going to\ncover all of them.But we'll cover\nmore in recitation.And there's a whole\nbunch in my notes.I won't get to all of them.So in Python, you can do\nrandom access style things.In Python, arrays\nare called lists,which is super confusing.But there you go.A list in Python is an\narray in real world.It's a super cool\narray, of course?And you can think\nof it as a list.But in terms implementation,\nit's implemented as an array.Question?AUDIENCE: I thought\nthat [INAUDIBLE].PROFESSOR: You thought Python\nlinks lists were linked lists.", "start": 1080.0, "heat": 0.158}, {"text": "That's why it's so confusing.In fact, they are not.In, say, scheme, back in the\ndays when we taught scheme,lists are linked lists.And it's very different.So when you do-- I'll\ngive an operation here.You have a list L, and you\ndo something like this.L is a list object.This takes constant time.In a linked list, it\nwould take linear time.Because we've got a scan to\nposition I, scan to position J,add 5, and store.But conveniently in Python,\nthis takes constant time.And that's important to know.I know that the terminology\nis super confusing.But blame the benevolent\ndictator for life.On the other hand, you can do\nstyle two, pointer machine,using object oriented\nprogramming, obviously.I'll just mention\nthat I'm not reallyworrying about methods here.Because methods are just sort of\na way of thinking about things,not super important\nfrom a cost standpoint.If your object has a constant\nnumber of attributes--it can't have like\na million attributesor can't have n\nexecutes-- then itfits into this\npointer machine model.So if you have an\nobject that onlyhas like three things or\n10 things or whatever,that's a pointer machine.You can think of\nmanipulating that objectas taking constant time.If you are screwing around\nthe object's dictionaryand doing lots of\ncrazy things, then youhave to be careful about\nwhether this remains true.But as long as you only\nhave a reasonable numberof attributes, this\nis all fair game.And so if you do something like,\nif you're implementing a linkedlist, Python I\nchecked still does nothave built-in linked lists.They're pretty easy\nto build, though.You have a pointer.And you just say\nx equals x.next.That takes constant time\nbecause accessing this fieldin an object of constant\nsize takes constant time.", "start": 1200.0, "heat": 0.184}, {"text": "And we don't care what\nthese constants are.That's the beauty of algorithms.Because we only care\nabout scalability with n.There's no n here.This takes constant time.This takes constant time.No matter how big\nyour linked listis or no matter how\nmany objects you have,these are constant time.OK, let's do some\nharder ones, though.In general, the\nidea is, if you takean operation like L.append--\nso you have a list.And you want to append\nsome item to the list.It's an array, though.So think about it.The way to figure out\nhow much does this costis to think about\nhow it's implementedin terms of these\nbasic operations.So these are your sort of\nthe core concept time things.Most everything can be reduced\nto thinking about this.But sometimes,\nit's less obvious.L.apend is a little\ntricky to think about.Because basically, you\nhave an array of some size.And now you want to make\nan array one larger.And the obvious way to do that\nis to allocate a new arrayand copy all the elements.That would take linear time.Python doesn't do that.What does it do?Stay tuned for lecture eight.It does something\ncalled table doubling.It's a very simple idea.You can almost get\nguess it from the title.And if you go to lecture--\nis it eight or nine?Nine, sorry.You'll see how\nthis can basicallybe done in constant time.There's a slight catch,\nbut basically, think of itas a constant time operation.Once we have that,\nand so this iswhy you should take\nthis class so you'llunderstand how Python works.This is using an algorithmic\nconcept that was invented,I don't know, decades\nago, but is a simple thingthat we need to do to solve\nlots of other problems.So it's cool.There's a lot of features in\nPython that use algorithms.And that's kind of\nwhy I'm telling you.All right, so let's\ndo another one.A little easier.What if I want to\nconcatenate two lists?", "start": 1320.0, "heat": 0.318}, {"text": "You should know in Python this\nis a non-destructive operation.You basically take a copy of\nL1 and L2 and concatenate them.Of course, they're arrays.The way to think about\nthis is to re-implement itas Python code.This is the same\nthing as saying, well,L is initially empty.And then for every item\nx and L1, L.append(x).And a lot of the times in\ndocumentation for Python,you see this sort of here's\nwhat it means, especiallyin the fancier features.They give sort of an equivalent\nsimple Python, if you will.This doesn't use\nany fancy operationsthat we haven't seen already.So now we know this\ntakes constant time.The append, this append,\ntakes constant time.And so the amount of\ntime here is basicallyorder the length of L1.And the time here is\norder the length of L2.And so in total,\nit's order-- I'mgoing to be careful and\nsay 1 plus length of L1plus length of L2.The 1 plus is just in\ncase these are both 0.It still takes constant time\nto build an initial list.OK, so there are a\nbunch of operationsthat are written in these notes.I'm not going to go\nthrough all of thembecause they're tedious.But a lot of you, could just\nexpand out code like this.And it's very easy to analyze.Whereas you just\nlook at plus, youthink, oh, plus\nis constant time.And plus is constant\ntime if this is a wordand this is a word.But these are entire\ndata structures.And so it's not constant time.All right.There are more subtle\nfun ones to think about.Like, if I want to know is x in\nthe list, how does that happen?Any guesses?There's an operator\nin Python calledin-- x in L. How long\ndo you think this takes?Altogether?Linear, yeah.Linear time.In the worst case,\nyou're going to have", "start": 1440.0, "heat": 0.368}, {"text": "to scan through the whole list.Lists aren't necessarily sorted.We don't know\nanything about them.So you've got to just\nscan through and testfor every item.Is x equal to that item?And it's even worse if\nequal equals costs a lot.So if x is some really\ncomplicated thing,you have to take\nthat into account.OK, blah, blah, blah.OK, another fun one.This is like a pop quiz.How long's it take to\ncompute the length of a list?Constant.Yeah, luckily, if you\ndidn't know anything,you'd have to scan through\nthe list and count the items.But in Python, lists\nare implementedwith a counter built in.It always stores the\nlist at the beginning--stores the length of the\nlist at the beginning.So you just look it up.This is instantaneous.It's important, though.That can matter.All right.Let's do some more.What if I want to sort a list?How long does that take?N log n where n is the\nlength of the list.Technically times the time\nto compare two items, whichusually we're just\nsorting words.And so this is constant time.If you look at Python\nsorting algorithm,it uses a comparison sort.This is the topic of lectures\nthree and four and seven.But in particular,\nthe very next lecture,we will see how this is\ndone in n log n time.And that is using algorithms.All right, let's\ngo to dictionaries.Python called dicts.And these let you do things.They're a generalization\nof lists in some sense.Instead of putting just an\nindex here, an integer between 0", "start": 1560.0, "heat": 0.467}, {"text": "and the length minus 1, you\ncan put an arbitrary keyand store a value, for example.How long does this take?I'm not going to ask you\nbecause, it's not obvious.In fact, this is one of the\nmost important data structuresin all of computer science.It's called a hash table.And it is the topic of\nlectures eight through 10.So stay tuned for how to\ndo this in constant time,how to be able to\nstore an arbitrary key,get it back out\nin constant time.This is assuming the\nkey is a single word.Yeah.AUDIENCE: Does it first check to\nsee whether the key is alreadyin the dictionary?PROFESSOR: Yeah, it will\nclobber any existing key.There's also, you\nknow, you can testwhether a key is\nin the dictionary.That also takes constant time.You can delete something\nfrom the dictionary.All the usual-- dealing with\na single key in dictionaries,obviously dictionary.update,\nthat involves a lot of keys.That doesn't take some time.How long does it take?Well, you write out a\nfor loop and count them.AUDIENCE: But how can you\nsee whether [INAUDIBLE]dictionary in constant time?PROFESSOR: How do you do\nthis in constant time?Come to lecture\neight through 10.I should say a\nslight catch, whichis this is constant time\nwith high probability.It's a randomized algorithm.It doesn't always\ntake constant time.It's always correct.But sometimes, very rarely,\nit takes a little morethan constant time.And I'm going to\nabbreviate this WHP.And we'll see more what\nthat means mostly, actually,in 6046.But we'll see a fair amount\nin 6006 on how this worksand how it's possible.It's a big area of research.A lot of people work on hashing.It's very cool and\nit's super useful.If you write any code these\ndays, you use a dictionary.It's the way to solve problems.I'm basically using\nPython is a platformto advertise the rest of the\nclass you may have noticed.Not every topic we cover in\nthis class is already in Python,but a lot of them are.So we've got table doubling.We've got dictionaries.", "start": 1680.0, "heat": 0.582}, {"text": "We've got sorting.Another one is longs, which\nare long integers in Pythonthrough version two.And this is the\ntopic of lecture 11.And so for fun, if I have\ntwo integers x and y,and let's say one of them\nis this many words longand the other one is\nthis many words long,how long do you think\nit takes to add them?Guesses?AUDIENCE: [INAUDIBLE].PROFESSOR: Plus?Times?Plus is the answer.You can do it in that much time.If you think about the\ngrade school algorithmfor adding really big\nmulti-digit numbers,it'll only take that much time.Multiplication is a\nlittle bit harder, though.If you look at the\ngrade school algorithm,it's going to be x times y--\nit's quadratic time not sogood.The algorithm that's\nimplemented in Pythonis x plus y to the\nlog base 2 of 3.By the way, I always write\nLG to mean log base 2.Because it only has two\nletters, so OK, this is 2.Log base 2 of 3 is about 1.6.So while the straightforward\nalgorithm is basicallyx plus y squared, this one\nis x plus y to the 1.6 power,a little better than quadratic.And the Python developers\nfound that was fasterthan grade school\nmultiplication.And so that's what\nthey implemented.And that is something we\nwill cover in lecture 11,how to do that.It's pretty cool.There are faster\nalgorithms, but thisis one that works\nquite practically.One more.Heap queue, this is in the\nPython standard libraryand implements something\ncalled the heap, whichwill be in lecture four.So, coming soon to a\nclassroom near you.", "start": 1800.0, "heat": 0.704}, {"text": "All right, enough advertisement.That gives you some idea of\nthe model of computation.There's a whole bunch more in\nthese notes which are online.Go check them out.And some of them, we'll\ncover in recitation tomorrow.I'd like to-- now that we are\nsort of comfortable for whatcosts what in Python, I\nwant to do a real example.So last time, we\ndid peak finding.We're going to have\nanother example whichis called document distance.So let's do that.Any questions before we go on?All right.So document distance problem\nis, I give you two documents.I'll call them D1 D2.And I want to compute the\ndistance between them.And the first question\nis, what does that mean?What is this distance function?Let me first tell\nyou some motivationsfor computing document distance.Let's say you're\nGoogle and you'recataloging the entire web.You'd like to know when two web\npages are basically identical.Because then you store less\nand because you present itdifferently to the user.You say, well,\nthere's this page.And there's lots\nof extra copies.But you just need--\nhere's the canonical one.Or you're Wikipedia.And I don't know if you've\never looked at Wikipedia.There's a list of all\nmirrors of Wikipedia.There's like millions of them.And they find them by hand.", "start": 1920.0, "heat": 0.563}, {"text": "But you could do that\nusing document distance.Say, are these\nbasically identicalother than like some\nstuff at the-- junkat the beginning or the end?Or if you're teaching this\nclass and you want to detect,are two problem sets cheating?Are they identical?We do this a lot.I'm not going to tell you\nwhat distance function we use.Because that would\ndefeat the point.It's not the one\nwe cover in class.But we use automated tests\nfor whether you're cheating.I've got some more.Web search.Let's say you're Google again.And you want to\nimplement searching.Like, I give you three words.I'm searching for\nintroduction to algorithms.You can think of\nintroduction to algorithmsas a very short document.And you want to test\nwhether that document issimilar to all the other\ndocuments on the web.And the one that's most\nsimilar, the one thathas the small\ndistance, that's maybewhat you want to put at the top.That's obviously not\nwhat Google does.But it's part of what it does.So that's why you might care.It's partly also\njust a toy problem.It lets us illustrate\na lot of the techniquesthat we develop in this class.All right, I'm going\nto think of a documentas a sequence of words.Just to be a little\nbit more formal,what do I mean by document?And a word is just\ngoing to be a stringof alphanumeric\ncharacters-- A through Zand zero through nine.OK, so if I have a\ndocument which you alsothink of as a string\nand you basicallydelete all the white space and\npunctuation all the other junkthat's in there.This Everything in between\nthose, those are the words.That's a simple definition\nof decomposing documentsinto words.And now we can think\nof about what--I want to know whether\nD1 and D2 are similar.And I've thought\nabout my documentas a collection of words.Maybe they're similar if they\nshare a lot of words in common.", "start": 2040.0, "heat": 0.272}, {"text": "So that's the idea.Look at shared words\nand use that to definedocument distance.This is obviously only one\nway to define distance.It'll be the way we\ndo it in this class.But there are lots of\nother possibilities.So I'm going to\nthink of a document.It's a sequence of words.But I could also think\nof it as a vector.So if I have a document D and\nI have a word W, this D of Wis going to be the\nnumber of timesthat word occurs\nin the document.So, number of recurrences\nW in the document D.So it's a number.It's an integer.Non-negative integer.Could be 0.Could be one.Could be a million.I think of this\nas a giant vector.A vector is indexed\nby all words.And for each of them,\nthere's some frequency.Of lot of them are zero.And then some of them have some\npositive number occurrences.You could think\nof every documentis as being one of these\nplots in this common axis.There's infinitely\nmany words down here.So it's kind of a big axis.But it's one way to\ndraw the picture.OK, so for example, take two\nvery important documents.Everybody likes cats and dogs.So these are two word documents.And so we can draw them.Because there's only three\ndifferent words here,we can draw them in\nthree dimensional space.Beyond that, it's a\nlittle hard to draw.So we have, let's say,\nwhich one's the-- let's saythis one's the-- makes\nit easier to draw.So there's going to be\njust zero here and one.", "start": 2160.0, "heat": 0.393}, {"text": "For each of the axes, let's say\nthis is dog and this is cat.OK, so the cat has won the--\nit has one cat and no dog.So it's here.It's a vector\npointing out there.The dog you've got\nbasically pointing there.OK, so these are two vectors.So how do I measure how\ndifferent two vectors are?Any suggestions from\nvector calculus?AUDIENCE: Inner product?PROFESSOR: Inner product?Yeah, that's good suggestion.Any others.OK, we'll go with inner product.I like inner product,\nalso known as dot product.Just define that quickly.So we could-- I'm going\nto call this D primebecause it's not what\nwe're going to end up with.We could think of this as\nthe dot product of D1 and D2,also known as the sum over all\nwords of D1 of W times D2 of W.So for example, you take the\ndot product of these two guys.Those match.So you get one point there,\ncat and dog multiplied by zero.So you don't get much there.So this is some\nmeasure of distance.But it's a measure of,\nactually, of commonality.So it would be sort of\ninverse distance, sorry.If you have a high\ndot product, youhave a lot of things in common.Because a lot of these\nthings didn't be--wasn't zero times something.It's actually a positive number\ntimes some positive number.If you have a lot of shared\nwords, than that looks good.The trouble of this is if\nI have a long document--say, a million words--\nand it's 99% in commonwith another document\nthat's a million words long,", "start": 2280.0, "heat": 0.641}, {"text": "it's still-- it\nlooks super similar.Actually, I need to do\nit the other way around.Let's say it's a million words\nlong and half of the wordsare in common.So not that many,\nbut a fair number.Then I have a score\nof like 500,000.And then I have two documents\nwhich are, say, 100 words long.And they're identical.Their score is maybe only 100.So even though\nthey're identical,it's not quite scale invariant.So it's not quite\na perfect measure.Any suggestions for\nhow to fix this?This, I think, is\na little trickier.Yeah?AUDIENCE: Divide by the\nlength of the vectors?PROFESSOR: Divide by the\nlength of the vectors.I think that's worth a pillow.Haven't done any pillows yet.Sorry about that.So, divide by the\nlength of vector.That's good.I'm going to call\nthis D double prime.Still not quite\nthe right answer.Or not-- no, it's pretty good.It's pretty good.So here, the length\nof the vectorsis the number of\nwords that occurin them This is pretty cool.But does anyone\nrecognize this formula?Angle, yeah.It's a lot like the angle\nbetween the two vectors.It's just off by an arc cos.This is the cosine of the\nangle between the two vectors.And I'm a geometer.I like geometry.So if you take arc\ncos of that thing,that's a well established\ndistance metric.This goes back to '75,\nif you can believe it,back when people-- early\ndays of document, informationretrieval, way before\nthe web, peoplewere still working\non this stuff.So it's a natural measure of the\nangle between the two vectors.If it's 0, they're\nbasically identical.If it's 90 degrees, they're\nreally, really different.And so that gives you a nice way\nto compute document distance.The question is, how do we\nactually compute that measure?Now that we've come up with\nsomething that's reasonable,how do I actually\nfind this value?", "start": 2400.0, "heat": 0.908}, {"text": "I need to compute these\nvectors-- the numberof recurrences of each\nword in the document.And I need you compute\nthe dot product.And then I need to divide.That's really easy.So, dot product--\nand I also needto decompose a document\nto a list of words.So there are three\nthings I need to do.Let me write them down.So a sort of algorithm.There's one, split a\ndocument into words.Second is compute\nword frequencies,how many times\neach word appears.This is the document vectors .And then the third step is\nto compute the dot product.Let me tell you a little\nbit about how each of thoseis done.Some of these will be covered\nmore in future lectures.I want to give you an overview.There's a lot of ways to\ndo each of these steps.If you look at the--\nnext to the lecturenotes for this lecture two,\nthere's a bunch of codeand a bunch of data\nexamples of documents--big corpuses of text.And you can run,\nI think, there areeight different\nalgorithms for it.And let me give you--\nactually, why don't Icut to the chase a\nlittle bit and tell youabout the run times of these\ndifferent implementationsof this same algorithms.There are lots of sort of\nversions of this algorithm.We implement it a whole bunch.Every semester I teach this, I\nchange them a little bit more,add a few more variants.So version one, on\na particular pairof documents which is like a\nmegabyte-- not very much text--", "start": 2520.0, "heat": 0.972}, {"text": "it takes 228.1\nseconds-- super slow.Pathetic.Then we do a little bit\nof algorithmic tweaking.We get down to 164 seconds.Then we get to 123 seconds.Then we get down to 71 seconds.Then we get down\nto 18.3 seconds.And then we get to 11.5 seconds.Then we get to 1.8 seconds.Then we get to 0.2 seconds.So factor of 1,000.This is just in Python.2/10 of a second to\nprocess a megabytes.It's all right.It's getting reasonable.This is not so reasonable.Some of these improvements\nare algorithmic.Some of them are\njust better coding.So there's improving\nthe constant factors.But if you look at\nlarger and larger texts,this will become\neven more dramatic.Because a lot of these\nwere improvementsfrom quadratic time algorithms\nto linear and log n algorithms.And so for a megabyte, yeah,\nit's a reasonable improvement.But if you look at a gigabyte,\nit'll be a huge improvement.There will be no comparison.In fact, there will\nbe no comparison.Because this one\nwill never finish.So the reason I ran\nsuch a small exampleso I could have patience\nto wait for this one.But this one you could run\non the bigger examples.All right, so where do\nI want to go from here?Five minutes.I want to tell you about\nsome of those improvementsand some of the algorithms here.Let's start with\nthis very simple one.How would you split a\ndocument into words in Python?Yeah?AUDIENCE: [INAUDIBLE].Iterate through the document,\n[INAUDIBLE] the dictionary?PROFESSOR: Iterate\nthrough the-- that'sactually how we do number two.OK, we can talk about that one.Iterate through the\nwords in the documentand put it in a dictionary.Let's say, count of\nword plus equals 1.This would work if count\nis something called a count", "start": 2640.0, "heat": 0.92}, {"text": "dictionary if you're\nsuper Pythonista.Otherwise, you have to check,\nis the word in the dictionary?If not, set it to one.If it is there, add one to it.But I think you know\nwhat this means.This will count the\nnumber of words--this will count the frequency\nof each word in the dictionary.And becomes dictionaries\nrun in constant timewith high probability--\nwith high probability--this will take order--\nwell, cheating a little bit.Because words can\nbe really long.And so to reduce a word\ndown to a machine wordcould take order the\nlength of the word time.To a little more\nprecise, this isgoing to be the\nsum of the lengthsof the words in the\ndocument, which is alsoknown as a length of\nthe document, basically.So this is good.This is linear time\nwith high probability.OK, that's a good algorithm.That is introduced\nin algorithm four.So we got a significant boost.There are other ways to do this.For example, you\ncould sort the wordsand then run through\nthe sorted listand count, how many do you\nget in a row for each one?If it's sorted, you\ncan count-- I mean,all the identical words are\nput right next to each other.So it's easy to count them.And that'll run almost as fast.That was one of\nthese algorithms.OK, so that's a couple\ndifferent ways to do that.Let's go back to\nthis first step.How would you split a document\ninto words in the first place?Yeah?AUDIENCE: Search circulated\nspaces and then [INAUDIBLE].PROFESSOR: Run through\nthough the string.And every time you see anything\nthat's not alphanumeric,start a new word.OK, that would run\nin linear time.That's a good answer.So it's not hard.If you're a fancy Pythonista,\nyou might do it like this.", "start": 2760.0, "heat": 0.729}, {"text": "Remember my Reg Exes.This will find all the\nwords in a document.Trouble is, in general,\nre takes exponential time.So if you think about\nalgorithms, be very careful.Unless you know how\nre is implemented,this probably will\nrun in linear time.But it's not obvious at all.Do anything fancy with\nregular expressions.If you don't know what this\nmeans, don't worry about it.Don't use it.If you know about it, be\nvery careful in this classwhen you use re.Because it's not\nalways linear time.But there is an easy\nalgorithm for this,which is just scan through\nand look for alpha numerics.String them together.It's good.There's a few other\nalgorithms here in the notes.You should check them out.And for fun, look at this code\nand see how small differencesmake dramatic difference\nin performance.Next class will\nbe about sorting.", "start": 2880.0, "heat": 0.606}]