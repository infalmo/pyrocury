[{"text": "The following\ncontent is providedunder a Creative\nCommons license.Your support will help MIT\nOpenCourseWare continueto offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Good\nmorning, everyone.So lecture three of four in the\nshortest path module and todaywe'll finally\nconfront our nemesis,which are negative cycles\nand negative edges.And we will describe\nan algorithmthat is due to two\ndifferent people.They didn't collaborate\nto produce this algorithm.Bellman and Ford.This computes shortest paths\nin a graph with negative edges.And not only that,\neven in the graphhas negative cycles\nin it, the algorithmwill be correct in\nthe sense that itwill report the existence\nof a negative cycleand, essentially, abort the\ncomputation of shortest pathsthat are undefined.And for the few\nvertices that do nothave negative cycles in\nbetween them and the source,the algorithm will report\ncorrect shortest paths.So it is a polynomial\ntime algorithm.It's fairly easy to describe.And what we'll do is describe\nit, analyze its complexityand, for once, we'll do a\nformal proof of its correctnessto show that it reports the\nexistence of negative cyclesif they do exist.And if they don't\nexist, it correctlycomputes shortest path weights.So recall that when we\nlook at the general caseof the shortest path problem.", "start": 0.0, "heat": 0.1}, {"text": "We're going to have, let's say,\na vertex u that, in this case,happens to be our source.And let's say for\nargument's sakethat we have a negative\nweight cycle like so.So let me to draw this in bold.And this happens to be\na negative rate cycle.Let's assume that all of these\nedges have positive weights.Then, if you have\nan algorithm thatneeds to work on this type\nof graph, what you wantto be able to do is to detect\nthat this negative cycleexists.And you're going\nto, essentially,say if this vertex\nis v1, for example,you want to be able to say delta\nu v1 is undefined and similarlyfor v2, v3, et cetera.For all of these things,\nthe shortest path lengthsare undefined because\nyou can essentiallyrun through this negative\ncycle any number of timesand get whatever shortest\npath weight you want.For this node, let's call\nthat v0, we have delta u v0equals 2.And there's a simple\npath of length 1in this case that\ngets you from u to v0.You don't encounter a cycle\nor negative cycle in between.So that's cool.All right?And of course, if you have\na vertex over here, z,that can't be reached\nfrom u then we'regoing to have delta\nuz being infinity.And you can assume at the\nbeginning of these algorithmsthat the source-- in this\ncase, I call the source u--but the shortest\npath to u would be 0.", "start": 120.0, "heat": 0.299}, {"text": "And all of the other\nones are infinity.And some of them\nmay stay infinity.Some of them may obtain\nfinite shortest path weights.And some of them\nwill be undefinedif you have a graph with\nnegative cycles in it.So that's sort of the\nspecification, if you will,of the requirements on the\nBellman-Ford algorithm.We want it to be able to do all\nof the things I just described.OK?So let's take a second look\nat our generic shortest pathalgorithm that I put up,\nI think, about a week ago.And this is a good\nreview of our notation.But there are a\ncouple more thingsI want to say about\nthis algorithmthat I didn't get to last time.So you're given a graph and\nyou set all of the verticesin the graph to have\ninfinite shortest pathweights, initially.Set the predecessors to be null.And then we'll set\nd of s to be 0.That's your source.And the main loop would\nbe something like repeat,select, and edge.And we have a particular\nway of selecting this edge.And we have positive\nedge weightsthat corresponds to\nthe minimum priority.And we talked about\nDijkstra but we have, maybe,different ways of doing that.We have to select\nan edge somehow.And then, we relaxed that edge.u, v, w.And you know about\nthe relaxation step.", "start": 240.0, "heat": 0.33}, {"text": "I won't bother writing\nit out right now.But it's basically\nsomething whereyou look at the value\nof d v. And if d vis greater than d u plus the\nweight, you relax the edge.And you keep doing this.The other thing that\nyou do in the relaxationis to set the predecessor\npointers to be correct.And that's part of\nthe relax routine.And you keep doing this until\nyou can't relax anymore.All right?So that's our generic\nshortest path algorithm.There are two problems\nwith this algorithm.The first, which we talked\nabout and both of thesehave to do with the\ncomplexity but the first oneis that the complexity\ncould be exponential time,even for positive edge weights.And the particular\nexample we talked aboutwas something where you had an\nexponential number of paths.And if you had a graph\nthat looks like this,then it's possible that a\npathological selection of edgesis going to make you relax edges\nan exponential number of times.And in particular, if you\nhave n nodes in this graph,it's plausible that\nyou'd end up gettingthe complexity of order\n2 raised to n over 2.OK?So that's one problem.The second problem,\nwhich is actuallya more obvious problem, is that\nthis algorithm might not eventerminate if this--\nactually will not", "start": 360.0, "heat": 0.245}, {"text": "terminate the way it's written\nif there's a negative weightcycle reachable from the source.All right, so\nthere's two problems.We fixed the first one.In the case of positive\nedges are non-negative edges.We have a neat algorithm that\nis an efficient algorithm calledDijkstra that we talked\nabout last time that fixedthe first part.But we don't know\nyet how we're goingto handle negative cycles\nin the general case.We know how to\nhandle negative edgesin the case of a DAG-- a\ndirected acyclic graph--but not in the general case.OK?So there's this great little\nskit from Saturday Night Livefrom the 1980s-- so way before\nyour time-- called The FiveMinute University.Anybody seen this?All right.Look it up on YouTube.Don't look it up during\nlecture but afterwards.So the character\nhere is a personby the name of-- I\nforget his real namebut his fake name is\nFather Guido Sarducci.All right?So what's this Five\nMinute University about?Five Minute University,\nhe's selling this notionand he says, look, five\nyears after you graduateyou, essentially, are\ngoing to remember nothing.OK?I mean, you're not going\nto remember anythingabout all the courses\nyou took, et cetera.So why waste your time on a\ncollege education or wastemoney-- $100,000-- on\na college education?You know, for $20 I'll teach\nyou in five minutes what you're", "start": 480.0, "heat": 0.225}, {"text": "going to remember five\nyears after you graduate.All right?So let's take it to an extreme.Here's a 30 second\nversion up 6006.And this is what I want you to\nremember five years or 10 yearsor whatever after you graduate.All right?And maybe the 10 second version\nas polynomial time is great.OK?Exponential time is bad.And infinite time\ngets you fired.OK?So that's all you\nneed to remember.No, that's all you need\nto remember for the final.This happens, you know, five\nyears after you graduate.So you need to remember\na lot more if youwant to take your quiz next\nweek and the final exam.But I think that\nsummarized over here.You have a generic\nshortest path algorithm.And you realize that\nif you do this wrongyou could very easily\nget into a situationwhere a polynomial\ntime algorithm, and weknow one for Dijkstra,\nturns into exponential timein the worst case, you\nknow, for a graph like thatbecause you're\nselecting edges wrongly.And in particular, that's\nproblem number one.And problem number\ntwo is if you havea graph that isn't\nwhat you expect.In this case, let's say\nyou expected that a graphwith no negative cycles or maybe\nnot even negative edges in it.You could easily\nget into a situationwhere your termination\ncondition is suchthat your algorithm\nnever completes.So we need to fix\nproblem number two todayusing this algorithm\ncalled Bellman-Ford.And as it turns\nout, this algorithmis incredibly straightforward.I mean, its complexity\nwe'll have to look at.But from a description\nstandpoint,it's four lines of code.And let me put that up.So Bellman-Ford takes a graph,\nweights, and a source s.", "start": 600.0, "heat": 0.293}, {"text": "And you can assume an adjacency\nlist specification of the graphor the representation\nof the graph.And we do some initialization.It's exactly the same\nas in the generic caseexcept the d values will still\nbe looking at the d valuesand talking about the\nrelaxation operation.So we do an initialization.And then, this algorithm\nhas multiple passesbecause for I equals\n1 to v minus 1.So it does v minus 1 passes\nroughly order v passeswhere v is the\nnumber of vertices.And in each of these passes for\neach edge u v belonging to erelaxes every edge.And just so everyone remembers,\nrelax u, v, w is if d of vis greater than d of u plus w\nu v then we'll set d v to be--and we also set pi v to be u.OK.That's relax\noperation over here.So that's the algorithm.And if you know\nmagically that they'reno negative cycles in the graph.", "start": 720.0, "heat": 0.364}, {"text": "So if they're no negative\ncycles in the graph,then after these-- we'll\nhave to prove this.But after these v\nminus 1 passes you'regoing to get the correct\nshortest pathways.OK?You want to do a\nlittle bit more, right?I motivated what we\nwant Bellman-Ford to doearlier in the lecture.So you can also do a check.So you may not know if they're\nnegative weight cycles or not.But at this point,\nyou can say I'mgoing to do one more pass\nso the v path-- the vis the number of\nvertices-- over the graph.So for each edge in the graph,\nif you do one more relaxationand you see that d v is\ngreater than d u plus w u v. Soyou're not doing a relaxation.You're doing a check to see\nif you can relax the edge.Then report minus v\nnegative cycle exists.So this is the check.And the first part\nis the computation.So that's kind of neat.I mean, it fit's on a board.We talk about the correctness.The functionality,\nI hope everyone got.Do people understand\nwhat's happening herewith respect to functionality?Any questions?Not about correctness\nbut functionality?Yeah?AUDIENCE: Where\ndoes the [INAUDIBLE]get used in the formula?PROFESSOR: Oh, it doesn't.It's just a counter\nthat makes surethat you do v minus 1 passes.So what's that complexity\nof this algorithmusing the best data structure\nthat we can think of?", "start": 840.0, "heat": 0.529}, {"text": "Anyone?Yeah, go ahead.AUDIENCE: [INAUDIBLE] v plus e\nif you're using a [INAUDIBLE]to access [INAUDIBLE]?PROFESSOR: v plus e?AUDIENCE: Or v e plus e.PROFESSOR: So that would be?AUDIENCE: That's\nusing a dictionary?PROFESSOR: Yeah, I know.\nv e plus e would be?That's correct but.AUDIENCE: [INAUDIBLE].PROFESSOR: Right.But I mean when do v e plus\ne you can ignore the e.So say you have just v times e.All right.Good.Here you go.So this part here is v times e.And it doesn't really matter.I mean, you can use an array\nstructure adjacency list.It's not like Dijkstra where\nwe have this neat requirementfor a priority queue and\nthere's different waysof implementing\nthe priority queue.This part would be order of v e.And that gives you the\noverall complexity.This part here is only one\npass through the edges.So that's order\ne, like you said.So the complexities order v e.And this could be large, as\nI said before in, I think,the first lecture.e is order of v square\nin a simple graph.So you might end up with\na v cubed complexityif you run Bellman-Ford.So there's no question\nthat Bellman-Fordis, from a practical\nstandpoint, substantially slowerthan Dijkstra.You can get Dijkstra down\nto linear complexity.But this would potentially,\nat least in terms of vertices,be cubic complexity.So when you have a chance,\nyou want to use Dijkstra.And you're forced\nto use Bellman-Fordbecause you could potentially\nhave negative weightcycles while you're\nstuck with that.", "start": 960.0, "heat": 0.48}, {"text": "All right?OK, so why does this work?This looks a bit like magic.It turns out we can actually do\na fairly straightforward proofof correctness of Bellman-Ford.And we're going\nto do two things.We're going to not only\nshow that if negative weightcycles don't exist that\nthis will correctlycompute shorter stats.But we also have to show that\nit will detect negative weightcycles if they in fact exist.So there's two parts to this.And let's start.So what we have here\nfor this algorithmis that it can guarantee\nin a graph g equalsv E. If it contains no\nnegative weight cycles thenafter Bellman-Ford\nfinishes execution,d v equals delta s v for all\nv belonging to v. All right?And then there's that.That's the theorem\nyou want to prove.And the second piece\nof it is corollarythat we want to prove.And that has to\ndo with the check.And this says if\na value of d of vfails to converge\nafter v minus 1", "start": 1080.0, "heat": 0.355}, {"text": "passes there exists a negative\nweight cycle reachable from s.So those are the two things\nthat we need to show.I'll probably take a few\nminutes to do each of these.That theorem is a\nlittle more involved.So one of the first\nthings that wehave to do in order\nto prove this theoremis to think about exactly what\nthe shortest path correspondsto in a generic sense.So when we have source\nvertex s and you havea particular vertex\nv then there'sthe picture that we need\nto keep in mind as we tryand prove this theorem.So you have v0, v1, v2, et\ncetera all the way to vk.This is my vertex v. This is s.So s equals v0.V equals vk.All right?So I'm going to have a path p.That is v0, v1,\nall the way to vk.OK?How big is k in the worst case?How big is k?Anybody?How big is k?It's up on the black board.AUDIENCE: [INAUDIBLE].PROFESSOR: v minus 1, right?Why?", "start": 1200.0, "heat": 0.49}, {"text": "What would happen if k\nis larger than v minus 1?I'd have a cycle.I'd be visiting a\nvertex more than once.And it wouldn't\nbe a simple path.Right?So k is less than or equal to v\nminus 1 else I'd have a cycle.OK?I wouldn't have a simple path.And we're looking for the\nshortest, simple pathsbecause if you ever\nget to the pointwhere-- why are we looking\nfor shortest, simple paths?Well, in this\ncase, we're lookingfor shortest, simple paths.And if there's a\nnegative cycle, we'rein trouble because the\nshortest path is notnecessarily the simple\npath because youcould go around the\ncycle a bunch of times.I'll get back to that.But in the case where we're\ntrying to prove the theorem,we know that no\nnegative cycles exist.We can assume that\nno negative cyclesexist for the case\nof the theorem.And we want to show that\nBellman-Ford correctlycomputes each of the\nshortest path weights.And in that case, there's\nno negative weight cycles.We're guaranteed that k is less\nthan or equal to v minus 1.All right?Everybody buy that?Good.All right.So that's the picture I\nwant you keep in mind.Let's dive in and\nprove this theorem.And we prove it using induction.So let v be any vertex.And let's say that\nwe're looking at a path.v0, v1, v2, to vk.", "start": 1320.0, "heat": 0.613}, {"text": "And like I said, from\nv0 equals s to vkequals v. And in\nparticular, I'm notgoing to say that this\npath p is a shortestpath with the minimum\nnumber of edges.So there may be\nmany shortest paths.And I'm going to\npick the one thathas the minimum number of edges.If there's a unique shortest\npath, then that's a given.But it may be that I have\na path with four edges thathas the same weight as\nanother path with three edges.I'm going to pick the\none that has three edges.OK?So it may not be\nunique with respectthat they're not necessarily\nunique shortest paths.But I can certainly pick one.And no negative weight cycles\nimplies that p is simple.And that implies that k is less\nthan or equal to v minus 1,which is what I just argued.Now keep in mind that picture\nover there to the right.And basically, the argument\nis going to go as follows.Remember that I'm\ngoing to be relaxingevery edge in each\npass of the algorithm.OK?There's no choices here.I'm going be relaxing every edge\nin each pass of the algorithm.And essentially, the\nproof goes as follows.I'm going to be moving\ncloser and closer to vkand constructing this\nshortest path at every pass.", "start": 1440.0, "heat": 0.515}, {"text": "So at some point\nin the first pass,I'm going to relax\nthis edge v0, v1.OK?And at that point, thanks to the\noptimal substructure property,given that this is\nthe shortest path,this has to be a\nshortest path, as well.Any subset of the shortest\npath has to be a shortest path.I'm going to relax\nthis edge and I'mgoing to get the value\nof delta from s to v1.And it's going to be\nthis relaxation that'sgoing to get me that value.And after the first pass, I'm\ngoing to be able to get to v1.After the second\npass, I can get to v2.And after k passes, I'm going\nto be able to get to vk.So I'm just growing this\nfrontier one node every pass.And that's your induction.And you can write that out.And I'll write it out here.But that's basically it.So after one pass through all\nof the edges e, we have d of v1to be delta s v1.And the reason for this\nis because we'll relax.We're guaranteed to\nrelax all the edges.And we'll relax the edge\nv0, v1 during this pass.And we can't find a\nshorter path than this pathbecause, otherwise we'd violate\nthe optimum substructureproperty.And that means that\nit's a contradictionthat we selected a shortest\npath in the first place.So can argue that we have delta\ns v1 after the first pass.And this goes on.I'm going to write\nout this proofbecause I think it's\nimportant for you guys", "start": 1560.0, "heat": 0.422}, {"text": "to see the full proof.But you can probably guess\nthe rest at this point.After one pass,\nthat's what you get.After two passes\nthrough e we haved v2 equals delta s v2\nbecause in the second passwe're going to\nrelax edge v1, v2.So it' a different edge\nthat needs to be relaxed.But that's cool because\nI'm relaxing all the edges.And I'm going to be able\nto grow my frontier.I'm going to be able to\ncompute delta s v2 and the endof my second pass and\nso on and so forth.So after k passes, we have\nd vk equals delta s vk.And if I run through v\nminus 1 passes, whichis what I do in the algorithm,\nall reachable verticeshave delta values.All right?That's basically it.Any questions?It's actually a simpler proof\nthan the Dijkstra proof,which I just sketched last time.I'll just give\nyou some intuitionof the Dijkstra proof.It's probably a little too\npainful to do in a lecture.", "start": 1680.0, "heat": 0.416}, {"text": "But this one is, as you can\nsee, nice and clean and fitson two boards, which is kind\nof an important criterion here.So good.All right, so that takes\ncare of the theorem.Hopefully you're all on\nboard with the theorem.And one thing that we haven't\ndone is talk about the check.So the argument with\nrespect to the corollarybootstraps this particular\nargument for the theorem.But this requires the\ninsight that if after vminus 1 passes, if you can find\nan edge that can be relaxed,well what does that mean?So at this point, let's say that\nI've done my v minus 1 passesand we find an edge\nthat can be relaxed.Well, this means that the\ncurrent shortest path from sto some vertex that is\nobviously reachable vis not simple once I've\nrelaxed this edge because Ihave a repeated vertex.", "start": 1800.0, "heat": 0.441}, {"text": "So that means it's not simple\nto have a repeated vertex that'sthe same as I found a cycle.And it's a negative\nweight cycle because Iwas able to relax the edge\nand reduce the weight after Iadded a vertex\nthat cost a cycle.All right?So this cycle has to\nbe negative weight.Found a cycle that\nis negative weight.All right.That's pretty much it.So it's, I guess,\na painful algorithmfrom a standpoint of it's\nnot particularly smart.It's just relaxing\nall of the edgesa certain fixed number of times.And it just works out because\nyou will find these cycles.And if you keep going, it's\nlike this termination condition.What is neat is that I don't\nhave the generic shortest pathalgorithm up there anymore.But in effect,\nwhat you're sayingis after a certain\nnumber of passes,if you haven't\nfinished, you can quitbecause you have found\na negative cycle.So it's very similar to\nthe generic shortest pathalgorithm.You're not really\nselecting the edges.You're selecting all\nof them, in this case.And you're running through\na bunch of different passes.All right?So that's it with\nrespect to Bellman-Ford.I want to do a couple\nof special casesand revisit the\ndirected acyclic graph.But stop me here if you have any\nquestions about Bellman-Ford.You first and then back there.Yeah?AUDIENCE: Maybe\nI'm just confusedabout the definition of a cycle.But if you had, like, a tree,\nwhich had a negative weightedge, wouldn't it produce\nthe same situationwhere you relaxed that edge.", "start": 1920.0, "heat": 0.175}, {"text": "PROFESSOR: But you would have\nrelaxed that edge previously.AUDIENCE: But it wouldn't\nbe a cycle, right?PROFESSOR: Yeah, it\nwouldn't be a cycle.So let's look at that.That's a fine question.AUDIENCE: Doesn't\nthat make assumptionsabout this structure?PROFESSOR: Well if you\nhad a tree-- I mean,a tree is a really simple case.But if you had\nsomething like thisand if you did have\na minus 1 edge here,right-- we'll do a more\ncomplicated example.But let's say you had\nsomething like this.2 3 minus 1.And what will happen is if this\nhappens to be your s vertexand in the first step\nyou relax all the edges.And this one would get two.And then, depending on the\norder in which you relaxed,it's quite possible that if\nyou relax this edge first--let's say in the first pass\nthe ordering of the relaxationis 1, 2, and 3.So the edges are ordered\nin a certain way each time,and you're going to be\nrelaxing the edges in exactlythe same order each time.All right?It doesn't matter.The beauty of Bellman-Ford\nis that-- let's sayyou relax this edge.Initially, this is at infinity.So this is at 0.This is at infinity.This is at infinity.This is at infinity.If you relax this\nedge, nothing happens.All right?Then you relax, let's say, this\nedge because that's number two.This gets set to two.You relax this edge\nbecause that's 3.And this is infinity\nso nothing happens.Of course, this is already at\ntwo so nothing would happen.So the end of the first pass,\nwhat you have is this is 0.That's 2.This is still infinity.That's still infinity.OK?That's going to stay infinity\nbecause you can't reach itfrom s.So we can, sort of, ignore that.And then, of the second\npass, what you have isyou start with this edge again\nbecause that's the ordering.And this 2 minus 1\nwould give this a 1.", "start": 2040.0, "heat": 0.358}, {"text": "And then you relax this edge\nor try to relax this edge.Nothing happens.Try to relax this edge.Nothing happens.And at this point,\nyou have one more passto go because you\ngot 4 vertices.And in that past,\nnothing changes again.So that's what you end up with.You end up with 2 for\nthis and 1 for that.OK?That makes sense?So the important\nthing to understandis that you are\nactually relaxingall of the edges in every pass.And there's a slightly\nmore complicated examplethan this that is in the notes.And you can take a\nlook at that offline.There's another\nquestion in the back.Did you have a question?Someone raised their hand.Yeah?AUDIENCE: Yes,\nI'm just curious--is there a unknown\nbetter algorithm thatcan do the same thing?PROFESSOR: No, there's\nno known better algorithmfor solving the\ngeneral case like this.There are a couple of\nalgorithms that assume weightswithin a certain range.And then there complexities\ninclude both v and e, as wellas w where w is the dynamic\nrange of the weights.And depending on\nwhat w is, you couldargue that they have\nbetter complexity.But they're kind of\nincomparable in the sensethat they have this\nextra parameter, whichis the dynamic range of the w.OK?Now there's lots\nof special cases,like I said, and well take a\nlook at the DAG special casein a second where you\ncould imagine doing betterbut not for the case where you\nhave an arbitrary graph thatcould have negative cycles in it\nbecause it's got negative rateedges.Yeah?AUDIENCE: In the\ncorollary, does that assumeyou have a connected\ngraph because, you know,you could have a\nnegative weight edgein a separate part\nof the graph, whichisn't reachable from this.PROFESSOR: Yeah.So you're going to start when\nyou have an undefined weight.", "start": 2160.0, "heat": 0.583}, {"text": "Remember your\ninitialization condition.What is affected by s?Initialize is affected by s.The rest of it\nisn't affected by sbecause you're just\nrelaxing the edges.Initialize is affected\nby s because d of sstarts out being 0, like I put\nover here, and the rest of themare infinity.So there is an effect of the\nchoice of the starting vertex.And the rest of it\nfollows that youwill get an undefined\nvalue, or youwill find that\nnegative cycle existsbased on whether you can\nreach it from s or not.So if you happen to\nhave s over here,and it's just the\none node, and thenit has no edges going\nout of it, this algorithmwould just be trivial.But it wouldn't detect\nany negative cyclesthat aren't reachable from s.That make sense?AUDIENCE: Yeah.PROFESSOR: So there is this--\nit's kind of hidden over there.So I'm glad you\nasked that question.But initialize is\nsetting things up.And that is something\nthat affectsthe rest of the algorithm\nbecause d of s is 0and the rest of them\nare set to infinity.All right?So if there are no\nother questions,I'll move on to\nthe case of the DAGand talk a little bit about\nshortest paths versus longestpaths.And this is somewhat of\na preview of a lecturethat Eric is going to give a\nmonth from now on complexityand the difference between\npolynomial time and exponentialtime, though I'm not going\nto go into much depth here.But there's some\ninteresting relationshipsbetween the shortest path\nproblem and the longest pathproblem that I'd like to get to.But any other questions on this?OK, so let me ask a question.Suppose I wanted to find\nlongest paths in a graph", "start": 2280.0, "heat": 0.268}, {"text": "and let's say that this graph\nhad all positive edge weights.OK.What if I negated all\nof the edge weightsand ran a Bellman-Ford?Would I find the longest\npath in the graph?Do people understand\nthe question?I don't need this.So maybe we can talk about what\na longest path means first.So if this was s and this v1,\nv2, v3, fairly straightforward,you know how to compute\nshortest paths now.These are all positive.Even easier.The longest path\nto v3 is of length.Six because I go here, go\nthere, and go there, right?So that's my longest path.OK?And the shortest path\nto v3 is of length 4.So shortest path, longest\npaths, have these nice duality.What if I said,\nwell, you know, Ican solve the longest\npath problem, as well,given all of what I've\nlearned about shortest pathssimply by negating each of these\nedges and running Bellman-Ford.What would happen?Yeah?AUDIENCE: [INAUDIBLE] shortest\npath branch [INAUDIBLE]values, and if you\nswitched to absolute value,", "start": 2400.0, "heat": 0.285}, {"text": "it will give you\nthe longest path.PROFESSOR: So you\nthink it works?AUDIENCE: Yeah.It will also check the cycles.So the negative cycles will be\nthe longest path cycles that[INAUDIBLE].PROFESSOR: But I think\nthat's the key question.What will Bellman-Ford do\nwhen it is run on this?What would it return?AUDIENCE: [INAUDIBLE].PROFESSOR: No, what will\nBellman-Ford return?I'm asking.Someone else?What will Bellman-Ford\nreturn if I ran this?Undefined.Right?Undefined because you got this\nnegative weight cycle here.AUDIENCE: [INAUDIBLE].PROFESSOR: Sorry?Oh!Let's put another one in there.Oops, sorry.Now I see.You're right.You're right.I'm wrong.And why did you say undefined?AUDIENCE: I was wrong.PROFESSOR: OK, good.I got company.Thank you.Thank you.Good.Let's take it all over again.All over again.All right.All right, start over.s v1 v2 v3.Yeah, that is a cycle.All right, good.Cycle.So when you actually\nnegate each of these edges,you end up with a\nnegative weight cycle.So it's plausible that you\ncould have a graph like this onewhere this strategy won't\nwork because what would happenis Bellman-Ford would come back\nwith, essentially, an abortthat says I can't compute\nshortest paths because they'reundefined.All right?Now it turns out it's actually\nmore subtle than that.", "start": 2520.0, "heat": 0.843}, {"text": "What we're trying to do in\nBellman-Ford is, in the casewhere negative weight\ncycles don't exist,we report on the\nshortest simple path.That's the whole\nnotion of the proof.We say that the path has\na certain length, whichis, at most, v minus 1\nand so on and so forth.We get the shortest simple path.But if you actually have a\nproblem where you say-- letme start over again.Let's say I want to find\nthe shortest simple pathfor a different\ngraph and it happensto have a negative\nweight cycle in it.So I have something like this.2 3 minus 6, 3 over here,\n3 over here, and so on.Maybe 2 here.And I want to find the\nshortest simple path thatreaches v from s.OK?What is the shortest simple\npath that reaches v from s?It's this path that\ngoes horizontally,which has a weight\n3 plus 2, 5, 5plus 3, 8, 8 plus 3,\n11, 11 plus 2, 13.All right?So the shortest\nsimple path is 13.Will Bellman-Ford give you any\ninformation about this path?AUDIENCE: [INAUDIBLE].PROFESSOR: No because\nin [INAUDIBLE].After it does its v minus 1\npasses, v is reachable from s.", "start": 2640.0, "heat": 0.334}, {"text": "But you potentially go through\na negative weight cyclebefore you reach v. OK?So it turns out that if you have\na graph with negative weightcycles, finding the\nshortest simple pathis an NP-hard problem.It's a really hard problem.That's what NP means.No, it means something\nelse that Ericwill explain to you\nin a month or so.But it means that we don't\nknow any algorithm thatis better than exponential\ntime to solve this problem.OK?So amazingly, all you've done is\ntaken the shortest path problemand changed it ever so slightly.You said I want to look for\nthe shortest simple pathin the general case where\nI could, potentially,have negative weight\ncycles in my graph.And when you do that,\nall bets are off.You're not in the polynomial\ntime complexity domain anymore.At least, not that we know of.And the best that you can do is\nan exponential time algorithmto find shorter simple paths.And this problem,\nas it turns out,is equivalent to the longest\npath problem in the sensethat they're both NP-hard.If you can solve one, you\ncould solve the other.So to summarize, what\nhappens here simplyis that in the case\nof Bellman-Fordrunning on the original\nshortest path problem,you're allowed to abort when\nyou detect the fact that there'sa negative cycle.So given that you're allowed\nto abort when there'sa negative cycle, you have\na polynomial time solutionusing Bellman-Ford\nthat is not necessarilygoing to give you shortest\npath weights but will", "start": 2760.0, "heat": 0.288}, {"text": "in the case of no\nnegative cycles.All right?But if you ask for more-- a\nlittle bit more-- you said,you know, it'd be great\nif you could somehowprocess these negative\ncycles and tell methat if I had a simple path and\nI don't go through cycles whatwould the shortest\nweight be, it becomesa much more difficult problem.It goes from order\nof ve complexityto exponential time complexity\nto the best of our knowledge.So that's what I'd\nlike to leave you with.That there's much more to\nalgorithms than just the onesthat we're looking at.And we get a little\nbit of a previewof this-- so the difference\nbetween polynomial timean exponential time--\nlater on in the term.", "start": 2880.0, "heat": 0.384}]