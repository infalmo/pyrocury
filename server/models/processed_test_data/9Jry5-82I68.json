[{"text": "The following\ncontent is providedunder a Creative\nCommons license.Your support will help MIT\nOpenCourseWare continueto offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Today's lecture\nis about a brand new datastructure that you've\nprobably seen before,and we've mentioned\nearlier in double 06,called a binary search tree.We've talked about\nbinary search.It's a fundamental divide\nand conquer paradigm.There's a data structure\nassociated with it,called the BST, a\nbinary search tree.And what I want to do is\nmotivate this data structureusing a problem.It's a bit of a toy problem,\nbut certainly a problemthat you could imagine\nexists in all sortsof scheduling problems.It's a part of a runway\nreservation systemthat you can imagine building.And what I'll do is\ndefine this problemand talk about how we could\npossibly solve it with the datastructures you've already seen--\nso lists and arrays, heapsas well as, which\nwe saw last time--and hopefully motivate you into\nthe reason behind the existenceof binary search\ntrees, because theyare kind of the\nperfect data structurefor this particular problem.So let's dive into what the\nrunway reservation system lookslike.And it's your basic\nscheduling problem.We'll assume an airport\nwith a single runway.", "start": 0.0, "heat": 0.1}, {"text": "Now Logan has six runways.But the moment there's any sort\nof weather you're down to one.And of course, there's lots of\nairports with a single runway.And we can imagine that\nthis runway is pretty busy.There's obviously safety issues\nassociated with landing planes,and planes taking off.And so there are\nconstraints associatedwith the system, that\nhave to be obeyed.And you have to build these\nconstraints in-- and the checksfor these constraints--\ninto your data structure.That's sort of the\nsummary of the context.So reservations\nfor future landingsis really what this\nsystem is built for.There's a notion of time.We'll assume that\ntime is continuous.So it could be represented\nby a real variable,or a real quantity.And what we'd like to do is\nreserve requests for landings.And these are going to\nspecify landing time.Each of them is going to\nspecify a landing time.We call it t.And in particular,\nwe're going to add tto the set R of landing times if\nno other landings are scheduledwithin k minutes.And k is a parameter\nthat could vary.", "start": 120.0, "heat": 0.347}, {"text": "I mean, it could be statically\nset to 3 minutes, or maybe 4.You can imagine it\nvarying it dynamicallydepending on weather\nconditions, things like that.For the most of the examples\nwe'll talk about today,we'll assume k is 3 minutes,\nor something like that.So this is about adding\nto the data structure.And so an insert\noperation, if you will,that has a constraint associated\nwith it that you need to check.And so you wouldn't insert if\nthe constraint was violated.You would if the\nconstraint was satisfied.And time, as I\nsaid, is somethingthat is part of the system.It needs to be modeled.You have the current\nnotion of time.And every time you have a\nplane that's already landed,which means that\nyou can essentiallytake this particular\nlanding time awayfrom the set R. So this\nremoval, or delete-- we removefrom set R, which is\nthe set of landing timesafter the plane lands.So every once in awhile,\nas time increments,you're going to be checking\nthe data structure.And you can do this, maybe,\nevery minute, every 30 seconds.That isn't really important.But you have to be able\nto remove from this datastructure.So fairly straightforward\ndata structure.It's a set, R. We don't quite\nknow how to implement it yet.But we'd like to do all of these\noperations in order log n time,where n is the size of the set.", "start": 240.0, "heat": 0.236}, {"text": "All right?So any questions about that?Any questions about\nthe definitionof the problem\nbefore we move on?Are we good on?OK.So let's look at a real\nstraightforward example,and put this up here so you\nget a better sense of this.Let's say that, right\nnow, we are at time 37.And the set R has\n41.2, 49, and 53 in it.And that's time.Now you may get a request\nfor landing time 53.And-- I'm sorry.I want to call this\n56.3-- 41.2, 49, and 56.3.You may get a request\nfor landing time 53.And right now the time is 37.It's in the future, and\nyou say OK because you'vedone the check.And let's assume\nthat k equals 3.And 53 is four ahead of 49, and\n3.3 before 56.3, so you're OK.44 is not allowed.It's too close to 41.2.And 20, just for\ncompleteness, is notallowed because it's passed.Can't schedule in the past.I mean, it could\nbe the next day.But then you\nwouldn't call it 20.Let's assume that time is\na monotonically increasingfunction.You have a 64-bit number.It can go to the end\nof the world, or 2012,or wherever you want.So you can keep the\nnumber a bit smaller,", "start": 360.0, "heat": 0.303}, {"text": "and do a little constant\nfactor optimization, I guess.So that's sort of the set up.And hopefully you get a sense\nof what the requirements.And you guys know about a bunch\nof data structures already.And what I want to do is\nlist each one of them,and essentially shoot\nthem down with respectto not being able to make\nthis efficiency requirement.And I'd like you guys to\nhelp me shoot them down.So let's talk about\nan easy one first.Let's say you have an unsorted\nlist or an array correspondingto R. That's all you have.What's wrong with\nthis data structurefrom an efficiency standpoint?Yeah.AUDIENCE: Pretty much everything\nyou want to do to it is linear.PROFESSOR: That's exactly right.Pretty much everything you\nwant to do to it is linear.And so you want to check\nthe k minute check.You can certainly insert\ninto it, and just add to it.So that part is not linear,\nthat's constant time.But certainly,\nanything where youwant to go check against\nother elements of the array,it's unsorted.You have no idea of where\nto find these elements.You have to scan\nthrough the entire arrayto check to see whether\nthere's a landing time that'swithin k of the current time\nt that you're asking for.And that's going to\ntake order n time.So you can insert in\norder 1 without a check.But sadly, the check\ntakes order n time.", "start": 480.0, "heat": 0.359}, {"text": "All right?Let's do something that is\na little more plausible.Let's talk about a sorted array.So this is a little\nmore subtle question.Let's talk about a sorted array.What happens with\na sorted array?Someone?What can you do\nwith a sorted array?Yeah.AUDIENCE: Do a binary search\nto find the [INAUDIBLE].PROFESSOR: Binary search\nwould find a bad insert.OK, good.So that's good.So if you have a sorted array,\nand just for argument's sake,it looks like 4, 20, 32, 37, 45.And it's increasing order.And if you get a particular time\nt, you can use binary search.And let's say, in particular,\nthe time is, for example, 34.Then what you do is you go\nto the midpoint of the array,and maybe you just look at that.And you say oh, 34\nis greater than 32.So I'm going to go\ncheck and figure outif I need to move to\nthe left or the right.And since it's greater I'm\ngoing to move to the right.And within logarithmic\ntime, you'llfind what we call the insertion\npoint of the sorted array,where this 34 is\nsupposed to sit.And you don't necessarily\nget to insert there.You need to look, once you've\nfound the insertion point,to your left and to your right.And do the k minute check.So finish up the\nanswer to the question,tell me how long it's going to\ntake me to find the insertion", "start": 600.0, "heat": 0.327}, {"text": "point, how long it's going\nto take me to do the check,and how long it's going\nto take me to actually dothe insertion.AUDIENCE: Log n in the search--PROFESSOR: Log n for the\nsearch, to find the point.AUDIENCE: Constant\nfor the comparison?PROFESSOR: Constant\nto the comparison.And then the last step?AUDIENCE: Do the\nresearch [INAUDIBLE].PROFESSOR: Sorry, little louder.Sorry.AUDIENCE: The\ninsertion is constant.PROFESSOR: Insertion\nis constant?Is that right?Do you people agree with him,\nthat insertion is constant?AUDIENCE: You've got a\nmaximum size up there, right?There must be a maximum.[INAUDIBLE]PROFESSOR: No, the indices--\nso right now the arrayhas indices i.And if you start with 1, it's\n1, 2, 3, 4, 5, et cetera.So what do you\nmean by insertion?Someone explain to me\nwhat-- yeah, go ahead.AUDIENCE: When you\nput something in youhave to shift\nevery element over.PROFESSOR: That's exactly right.That's exactly right.Ok, good, that's great.I guess I should give\nyou half a cushion.But I'll do the full one, right?And you get one, too.So the point here is\nthis is pretty close.It's almost what we want.It's almost what we want.There's a little bit\nof a glitch here.We know about binary search.The binary search is\ngoing to allow us,if there's n elements\nhere, to find the place--it's going to be able\nto find-- and I'mgoing to precise here-- the\nsmallest i such that R of iis greater than or equal\nto t in order log n time.It's going to be\nable to do that.You're going to be able to\ncompare R of i and R of i", "start": 720.0, "heat": 0.462}, {"text": "minus 1-- so the left\nand the right-- against tin order 1 time.But sadly, the actual insertion\nis going to require shifting.And that could take order n\ntime, because it's an array.So that's the problem.Now you could imagine that\nyou had a sorted list.And you could say, hey\nif I have a sorted list,then the list looks\nlike this, and it'sgot a bunch of pointers in it.And if I've found\nthe insertion point,then-- the list is nice,\nbecause you can insert somethingby moving pointers\nin constant timeonce you've found\nthe insertion point.But what's the\nproblem with the list?Yeah.AUDIENCE: You can't do\nbinary search [INAUDIBLE].PROFESSOR: Well you can't\ndo binary search on a list.There's no notion of\ngoing to the n by 2 indexand doing random access on\na conventional list, right?So the list does\none thing right,but doesn't do the\nother thing right.The array does a\ncouple things right,but doesn't do the\nshifting right.And so you see why we've\nconstructed this toy problem.It's to motivate the\nbinary search tree datastructure, obviously.But you're close,\nbut not quite there.What about heaps?", "start": 840.0, "heat": 0.518}, {"text": "We talked about heaps last time.What's the basic problem with\nthe heap for this problem?The heaps are data\narrays, but youcan visualize them as trees.And obviously if we're talking\nabout min heaps and max heaps.So in particular, what goes\nwrong with a min heap or a maxheap for this problem?What takes a long time?Yeah.AUDIENCE: You have to scan every\nelement, which [INAUDIBLE].PROFESSOR: That's right.I mean, sadly, you know when\nwe talk about min heaps or maxheaps, they actually have\na fairly weak invariant.It turns out that-- I'm\npreviewing a bit here--binary search\ntrees are obviouslysimilar to heaps in the\nsense that you visualizean array as a tree,\nin the case of a heap.And binary search\ntrees are trees.But the invariant in a\nmin heap or a max heap,is this kind of\na week invariant.It essentially says,\nlook at the min element.And the min element\nhas to be the root,so you can do that one\noperation pretty quickly.But if you want to look\nfor a k minute check,you want to see if there's\nan element in the heap thatis less than or equal to k,\nor greater than or equal to kfrom t, this is going\nto take order n time.OK?Good.And finally, we haven't\ntalked about dictionaries,but we will next week.Eric will talk about hash\ntables and dictionaries.And they have the same problem.So it's not like dictionaries\nare going to solve the problem,for those of you who know about\nhash tables and dictionaries.", "start": 960.0, "heat": 0.458}, {"text": "But you'll hear about\nthem in some detail.They're very good\nat other things.So I don't want to say much more\nabout that, because you're notsupposed to know\nabout dictionaries.Or at least we\ndon't want to assumeyou do, though we\nhave talked about themand alluded to\ndictionaries earlier.And so that's a story here.Yeah, back there, question.AUDIENCE: Yeah, can you explain\nwhy it's [INAUDIBLE] time?PROFESSOR: So what\nis a heap, right?A heap essentially-- a\nmin heap, for example,or we talked about\nmax heaps last time,has the property that\nyou have an element k,and you're going to look\nat, let's say it's 21.Let's do min heaps, so this\nhas to be less than what'shere, 23, and what\nthere, maybe it's30, and so on and so forth.And you have a\nrecursive definition.And when you insert into a min\nheap, typically what happensis suppose you wanted to\ninsert, for argument's sake,I want to insert 25.I want to insert 25 into this.The insertion algorithm\nfor a min heaptypically adds to the\nend of the min heap.So what you do is you\nwould add 25 to this.And let's say that you\nhad something out here.So you'd add to it.And you'd start flipping things.And you could work with\njust this part of the arrayto insert 25 in here.And you'd be able to satisfy\nthe invariant of the min heap.And you'd get a\nlegitimate min heap.But you'd never check the\nleft part of it, which is 23.So it's quite possible--\nand this is a good example--", "start": 1080.0, "heat": 0.448}, {"text": "that your basic insertion\nalgorithm, which is essentiallya version of max heap\nof i, or min heap of i,would simply insert\nat the end, and keepflipping until you get\nthe min heap property,would be unable to check\nfor the k minute checkduring the insertion.But what you'd have to do\nis to go look elsewhere.That min heap of i\nwe'd never look at--or the insert algorithm we'd\nnever look at-- and thatwould require order n time.All right?AUDIENCE: Thank you.PROFESSOR: So that's the\nstory for the min heap.Thanks for the question.And it's similar for\ndictionaries, as I said.And so we're stuck.We have no data structure yet\nthat can do all of the thingsthat I put up on the board to\nthe left, in order log n time.And as you can see, the\nsorted array got pretty close.And so if you could\njust solve this problem,if you could do fast insertion--\nand by fast I mean order log ntime-- into a sorted\narray, we'd be in business.So that's what we'd like to\ndo with binary search trees.Binary search trees\nare, as you can imagine,enable binary search.But the sorted arrays\ndon't allow fast insertion,but BSTs do.So let me introduce BSTs.As with any data\nstructure, there'sa nice invariant\nassociated with BSTs.The invariant is stronger\nthan the heap invariant.And actually, that makes them\na different data structure, notnecessarily a better\ndata structure.And I'll say why, but different.For this problem they're better.", "start": 1200.0, "heat": 0.491}, {"text": "So one example of a binary\nsearch tree looks like this.And as a binary tree you have\na node, and we call it x.Each of the nodes\nhas a key of x.So 30 is the key for this node,\n17 for that one, et cetera.Unlike in a heap,\nyour data structureis a little more complicated.The heap is simply\nan array, and youhappen to visualize\nit as a tree.The binary search\ntree is actuallya tree that has\npointers, unlike a heap.So it's a more complicated\ndata structure.You need a few more bytes for\nevery node of the binary searchtree, as opposed\nto the heap, whichis simply an array element.And the pointers\nare parent of x.I haven't bothered\nshowing the arrows here,because you could be going\nupwards or backwards.And you could imagine\nthat you actuallyhave a parent pointer\nthat goes up this way,and you have a child\npointer that goes this way.So there's really,\npotentially, three pointersfor each node, the\nparent, the left child,and the right child.So pretty straightforward.That's the data\nstructure in termsof what it needs to have\nso you can operate on it.And there's an\ninvariant for a BST.What makes a BST\nis that you havean ordering of the\nkey values thatsatisfy the invariant that\nfor all nodes x if y is", "start": 1320.0, "heat": 0.458}, {"text": "in the left subtree\nof x, we have--if it's in the left\nsubtree then key of yis less than or\nequal to key of x.And if y is in the\nright subtree wehave key of y is greater\nthan or equal to key of x.So if we're talking\nabout trees here,subtrees here,\neverything underneath--and that's the stronger part\nof the invariant in the BST,versus in the heap we were just\ntalking about the children.And so you look at\nthis BST, it is a BSTbecause if I look to\nthe right, from the rootI only see values that\nare greater than 30.And if I look to the left,\nin the entire subtree,all the way down I only see\nvalues that are less than 30.And that has to be true for any\nintermediate node in the tree.And the only other\nnontrivial node here is 17.And you see that 14 is less than\n17, and 20 is greater than 17.OK?So that's the BST.That's the data structure.This is the invariant.So let's look at why BSTs\nare a possibility for solvingour runway reservation problem.And what I'll do is\nI'll do the insert.So let's start with the\nnil set of elements,or null set of elements, R.\nAnd let's start inserting.", "start": 1440.0, "heat": 0.367}, {"text": "So I insert 49.And all I do is make a node\nthat has a key value of 49.This one is easy.Next insert, 79.And what happens here\nis I have to look at 49,and I compare 79 to 49.And because 79 is greater\nthan 49 I go to the rightand I attach 79 to\nthe right child of 49.Then I want to insert 46.And when I want to\ninsert 46 I look at this,I compare 49 and 46.46 is less, so I go to the left\nside and I put 46 in there.Next, let's say I\nwant to insert 41.So far I haven't really talked\nabout the k minute checks.And you could imagine\nthat they're being done.I'll show you exactly, or\ntalk about exactly how they'redone in a second.It's not that hard.But let me go ahead\nand do one more.For 41, 41 is less\nthan 49, so I go left.41 is less than 46, so\nI go left and attach itto the left child.All right?So that's what I have right now.Now let's talk about\nthe k minute check.It's good to talk about\nthe K minute checkwhen there's\nactually a violation.And let's assume\nthe k equals 3 here.And so, same thing here.You're essentially doing\nbinary search here.And you're doing the checks as\nyou're doing the binary search.So what you're\ngoing to be doing isyou're going to check that--\nyou're going to compare 42with 49, with the\nk minute check.", "start": 1560.0, "heat": 0.517}, {"text": "And you realize they're 7 apart.So that's OK.And 42 is less than\n49, so you go left.And then you compare 42 with 46.And again, it's less than 46,\nbut it's k away, more than 3away from 46.So that's cool.And you go left.And then you get to 41.And you compare 42 with 41.In this case is greater.But it's not k more than it.And so that means that if\nyou didn't have the check,you would be putting 42 in here.But because you have\nthe check, you fail.And you say, look,\nI mean this violatesthe safety property, violates\nthe check I need to do.And therefore I'm\nnot going to insert--I'm not going to reserve\na request for you.All right?So what's happened here is\nit's basically a sorted array,except that you added\na bunch of pointersassociated with the tree.And so it's somewhere between a\nsorted list and a sorted array.And it does exactly\nthe right thingwith respect to\nbeing able to insert.Once you've found\nthe place to insert,it's merely attaching\nthis particular new nodewith it's appropriate\nkey to the pointer.All right?So what's happened\nhere is that if his the height of the\ntree then insertionwith or without the check\nis done in order h time.And that's what\nBSTs are good for.People buy that?Any questions about how they\nk minute check proceeded?Yeah, question.AUDIENCE: So, what's it called?The what check?PROFESSOR: The k minute check.", "start": 1680.0, "heat": 0.501}, {"text": "Sorry, the k was 3 minutes k.I had this thing over\nhere, add t to the set Rif no other landings are\nscheduled within k minutes.So k was just a number.I want it to be a\nparameter because itdoesn't matter what k is.As long as you know what it is\nwhen you do the binary search,you can add that in to an\nargument to your insert,and do the check.AUDIENCE: OK.PROFESSOR: So in this case,\nI set k to be 3 out here.And I was doing a check\nto see that the invariant,any elements in the BST\nalready, on any nodes thathad keys that were\nwithin 3 minutes--because I fixed k to be\n3-- to the actual timethat I was trying to insert.All right?AUDIENCE: So there's\nno way [INAUDIBLE].PROFESSOR: I'm sorry,\nthere's no way?AUDIENCE: There's\nno way you couldinsert the 42 into\nthe tree then?PROFESSOR: Well, if\nthe basic insertionmethod into a binary search tree\ndoesn't have any constraints.But you can certainly\naugment the insertion methodwithout changing the efficiency\nof the insertion method.So let's say that\nall you wanted to dowas insert into a\nbinary search tree,and it had nothing to do\nwith the runway reservation.Then you would just insert\nthe way I described to you.The beauty of the\nbinary search treeis that while you're\nfinding the place to insert,you can do these checks--\nthe k minute checks.Yeah, question back there.AUDIENCE: What about 45?PROFESSOR: What about 45?So this is after-- we\nhaven't inserted 42because it violated the check.So when you do 45,\nthen what happensis you see that\n45 is less than 49and you pass, because you're\nmore than 3 minutes away.We'll stick with that example.And then you get\nhere and then yousee that 45 is less than 46,\nand you'd fail right here.", "start": 1800.0, "heat": 0.387}, {"text": "You would fail right here\nif you were doing the check,because 45 is not\n3 away from 46.All right?So that's the story.And so if you have h being\nthe height of the tree,as you can see you're\njust following a path.And depending on\nwhat the height isyou're going to do\nthat many operations,times some constant factor.And so you can say that\nthis is order h time.All right?Any other questions?Yeah, question back there.AUDIENCE: In a normal\narray [INAUDIBLE].PROFESSOR: Well, it's up to you.In a conventional binary search\ntree, or the vanilla binarysearch tree, typically\nwhat you're doingis you're doing\neither find or insert.And so what that means\nis that you would justreturn the pointer\nassociated with that element.So if you're looking for find\n46, for example, on the treethat I have out there, typically\n46 is just the key value.And there may be a record\nassociated with it.And you would get a\npointer to that recordbecause it's already in there.At that point you can\nsay I want to override.Or if you want, you could\nhave duplicate values.You could have this,\nwhat's called a multiset.A multiset is a set that\nhas duplicate elements.In that case, you would need\na little more sophisticationto differentiate between\ntwo elements thathave the same key values.So you'd have to\ncall it 46a and 46b.And you'd have to have some\nway of differentiating.Any other questions?Yeah.AUDIENCE: Wouldn't\nit be a problemif the tree's not balanced?PROFESSOR: Ah, great question.Yes, stay tuned.So I was careful, right?", "start": 1920.0, "heat": 0.374}, {"text": "I guess I kind of\nalluded to the factthat we'd solved the\nrunway reservation system.Did I actually say that\nwe'd solved the problem?Did I say we had\nsolved the problem?OK, so I did not lie.I did not lie.I said that the height\nof the tree was h.And I said that this was\naccomplished in order h time,right?Which is not quite what I want,\nwhich is really your question.So we'll get to that.So we're not quite done yet.But before we do\nthat, it turns outthat today's lecture is\nreally part one of two.You'll get a really good\nsense of BST operationsin today's lecture.But there's going to be a few\nthings that-- we can't coverall of double 6 in\nthe lecture, right?We'd like to, and let you\noff for the entire fall,but that's not the way\nit works, all right?So it's a great question.I'll answer it towards the end.I just wanted you\nto say a little bitabout other operations.There's many operations that\nyou can do on a binary searchtree, that can be\ndone in order h time,and some even in constant time.And I'll put these in the notes.Some of these are\nfairly straightforward.Find min can be done\nin heap, in a min heap.If you want to find the minimum\nvalue, it's constant time.You just return the root.In the case of a binary search\ntree, how do you find the min?Someone?Worth a cushion.Yep.AUDIENCE: Keep\ngoing to the left?PROFESSOR: Keep\ngoing to the left.And how do you find the max?AUDIENCE: [INAUDIBLE].PROFESSOR: Keep\ngoing to the right.All right great, thank you.And finally, what\ncomplexity is that?I sort gave it away, but I\nwant to hear it from you.AUDIENCE: [INAUDIBLE].PROFESSOR: Hm?AUDIENCE: It's the heightPROFESSOR: It's the\nheight, order h.All right, it's\norder h complexity.Go to the left until\nyou hit a leaf,and until leaf\norder h complexity.", "start": 2040.0, "heat": 0.352}, {"text": "Same thing for max.And then you can do\na bunch of things.I'll put these in the notes.You can find things\nlike next largerx, which is the next\nlargest value beyond x.And you look at the key for\nx and you say, for example,if you put 46 in there, what's\nthe next thing that's largerand that?In this tree here, it's 49.But that's something which was\ntrivially done in this example.But in general you can do\nthis in order h time as well.And you can see the pseudocode.And we'll probably cover\nthat in section tomorrow.What I want to do today, for the\nrest of the time I have left,is actually talk about augmented\nbinary search trees, whichare things that can do more\nand have more data in themthan just these pointers.And that's actually\nsomething whichshould give you a sense of the\nrichness of the binary searchtree structure, this\nnotion of augmentation.And those of you, again,\nwho have taken double 05,you know about\ndesign amendments.And so specifications\nnever stay the same.I mean, you're\nworking for someone,and they never really\ntell you what they want.They might, but they\nchange their mind.So in this case, we're\ngoing to change our mind.And so we've done\nthis to the extentthat we can cover all of\nthese in order h time.And let's say that now\nthe problem specificationchanged on us.There's an additional\nrequirementthat we're asked to solve.And so you sort of\ncommitted to BST structures.But now we have an\nadditional requirement.And the new requirement is that\nwe be able to compute rank t.", "start": 2160.0, "heat": 0.344}, {"text": "And rank t is how\nmany planes arescheduled to land at times\nless than or equal to t.So perfectly\nreasonable question.It wasn't part of\nthe original spec.You now have built your\nBST data structure,you thought you were done.Sorry, you aren't.You've got to do\nthis extra stuff.So that's the notion\nof augmentation,which we're going to use this\nis an example of how we'regoing to augment\nthe BST structure.And oh, by the way,\nI don't want youto change the\ncomplexity from order h.And we eventually will\nget to order log n,but don't go change something\nthat was logarithmic to linear.That would be bad.So let's talk about\nhow you do this.And I don't think we\nneed this anymore.So the first thing we need to\ndo is add a little bit moreinformation to the\nnode structure.And what we're going to do\nis augment the BST structure.And we're going to add one\nlittle number associatedwith each node, that looks at\nthe number of nodes below it.So in particular,\nlet's say that Ihave 49, 46, let's just\nsay 49, 46 for now.And over here I\nhave 79, 64, and 83.", "start": 2280.0, "heat": 0.339}, {"text": "I'm going to modify--\nI'm going to havean extra number associated\nwith each of these nodes.And I'm just going\nto write that numberon the outside of the node.And you can just imagine\nthat now the key value hastwo numbers associated\nwith it-- the thingthat I write inside the node,\nand what I write outside of it.So in particular, when\nI do insert or deleteI'm going to be\nmodifying these numbers.And these are size numbers.And what do I mean by that?Well these numbers\ncorrespond to subtree sizes.So the subtree size\nhere is 1, 1, 1.So as I'm building\nthis tree up I'mgoing to create an\naugmented BST structure,and I've modified\ninsert and deleteso they do some extra work.So let's say, for\nargument's sake,that I've added this in\nsort of a bottom up fashion.And what I have are these\nparticular subtree sizes.All of these should make sense.This has just a single\nnode, same thing here.So this subtree sizes associated\nwith these nodes are all 1.The subtree size\nassociated with 79is 3, because you're\ncounting 79 and 64 and 83.And the subtree size\nassociated with 49is 5, because you're counting\neverything underneath it.How did we get these numbers?Well you want to\nthink about thisas you started\nwith an empty set,and you kept inserting into it.And you were doing a sequence\nof insert and delete operations.And if I explain to you how\nan insert operation modifiesthese numbers, that is\npretty much all you need.", "start": 2400.0, "heat": 0.1}, {"text": "And of course, analogously,\nfor a delete operation.So what would happen for, let's\nsay you wanted to insert 43?You would insert\n43 at this point.And what you'd do is you\nfollow the insertion pathjust like you did before.But when you're\nfollowing that pathyou're going to increment the\nnodes that you're seeing by 1.So you're going\nto add 43 to this.And you'd add 5 plus\n1, because you see 49.And then you would go\ndown and you'd see 46.And so you'd add 1 to that.And then finally,\nyou add 43 and youassign-- since\nit's a leaf-- you'dassign to value corresponding\nto the subtree sizeof this new node that you\nput in there, to be 1.It guess a little, teensy\nbit more complicatedwhen you want to do\nthe k minute check.But from a complexity\nstandpoint,if you're not worried\nabout constant factors,you can just say, you know what?I'm going to first run\nthe regular insert,ignoring the subtree sizes.And if it fails, I'm done.Because I'm not going to\nmodify the BST, and I'm done.I'm not going to have to\nmodify the subtree sizes.If it succeeds, then\nI'm going to go in,and I know now that I can\nincrement each of these nodes,because I know I'm\ngoing to be successful.So that's sort of a trivial\nway of solving this problem,that from an asymptotic\ncomplexity standpointgives you your order\nh augmented insert.That make sense?Now you could do something\nbetter than that.I mean, I would urge you,\nif you had wrote somethingthat-- we asked you to\nwrite something like this,to create a single procedure\nthat essentially usesa recursion appropriately to\ndo the right thing in one pass", "start": 2520.0, "heat": 0.1}, {"text": "through the BST.And we'll talk about\nthings like thatas we go along in sections,\nand possibly in lectures.So that's the subtree\ninsert delete.Everyone buy that?Yeah, question back there.AUDIENCE: If I wanted to delete\na number, like let's say 79--PROFESSOR: Yep?AUDIENCE: --would we\nhave to take it outand then rewrite the entire BST?PROFESSOR: What you'd have to\ndo is a bubble up pointers.So you'd have to actually\nhave 64 connected to-- whatwill happen is 83\nwould actually come up,and you would essentially\nhave some thing-- thisis not quite how it works--\nbut 83 would move upand you'd have 64 to the left.That's what would happened\nfor delete in this case.So you would have to move\npointers in the case of delete.And we're not done with\nbinary search tree operationsfrom a standpoint of\nteaching you about them.We'll talk about them not\njust in today's lecture,but later as well.So there's one\nthing missing here,though, which is I haven't\nquite figured out--I've told you how these\nsubtree sizes work.But it's not\ncompletely clear, thisis the last thing we have\nto do, is how are yougoing to compute rank t\nfrom the subtree sizes?So everyone understand\nsubtree sizes?It's just the number of nodes\nthat are underneath you.And you remember to count\nyourself, all right?Now what is rank t?Rank t is how many\nplanes are scheduledto land at times less\nthan or equal to t.So now I have a BST structure\nthat looks like the oneand I just ended up with.So I've added this 43.And so let me draw\nthat out here,and see if we can\nanswer this question.This is a subtle question.So I got 49, and that\nsubtree size is 6.I got 46, subtree size is 2.43, 79, 64.", "start": 2640.0, "heat": 0.1}, {"text": "and 83.So what I want is\nwhat lands before t?And how do I do that?Give me an algorithm\nthat would allowme to compute in order h time.I want to do this\nin order h time.What lands before t?Someone?Yeah.AUDIENCE: So first\nyou would haveto find where to insert\nit, like we did before.PROFESSOR: Right, right.AUDIENCE: And then because we\nhave the order of whatever itwas before-- not\nthe order, the--PROFESSOR: The sizes?The sizes?Yeah.AUDIENCE: And then we can\nlook what's more than iton the right, we can\nsubtract it and we get--PROFESSOR: What is more\nthan it on the right.Do you want to say--AUDIENCE: Because, like--PROFESSOR: OK.AUDIENCE: --on the right--PROFESSOR: Right.AUDIENCE: --and then we\ncan take this minus thisand we get what's left.PROFESSOR: That's\ngreat, that's excellent.Excellent.So I'm going to do it a little\nbit differently from whatyou described.I'm going to\nactually do it in a,sort of, a more positive\nway, no offense intended.What we're going to\ndo is we're goingto add up the things\nthat we want to add up.And what you have\nto do is walk--your first step was right on.I mean, your answer is correct.I'm just going to do it\na little bit differently.You walk down the tree\nto find the desired time.This is just your search.We know how to do that.As you walk down you\nadd in the nodes thatis the subtree sizes-- you're\njust adding in the notes here.So if you see-- depending\non the number of nodes", "start": 2760.0, "heat": 0.113}, {"text": "that you see as you're\ngoing deeper in,you want to add in the nodes.And you're going to add\none to that, correspondingto the nodes that are smaller.And we're going to add in the\nsubtree sizes to the left,as opposed to subtracting.That may not make\na lot of sense.But I guarantee you it\nwill once we do an example.So what's going on here?I want to find a\nplace to insert.I'm not actually going\nto do the insert.Think of it is doing a lookup.And along the way,\nI need to figure outthe less than operator.I want to find all\nof the things thatare less than this\nvalue I'm searching for.And so I have to do\na bit of arithmetic.So let's say that I'm\nlooking for what'sless than or equal to 79.So t equals 79.So I'm going to look at 49.I'm going to walk down,\nI'm going to look at 49.And because I say I'm\nlooking at 49-- and 49is clearly less than 79.So I'm going to add 1.And that's this check over here.I move on and what I need to\ndo now is move to the right,because 79 is greater than 49.That's how my search would work.But because I've\nmoved to the right,I'm going to add the subtree\nsizes that were to the left.Because I know that all\nof the things to the leftare clearly less than 79.", "start": 2880.0, "heat": 0.213}, {"text": "So I'm going to add 2,\ncorresponding to a subtree 46.So I'm not actually\nlooking there.But I'm going to add\nall of that stuff in.I'm going to move to the right,\nand now I'm going to see 79.At this point 79 is less\nthan or equal to 79.So I'm going to see 79\nand I'm going to add 1.And because I've added 79,\njust like I did with 49,I have to add the subtree\nsize to the left of 79.So the final addition\nis I add 1 correspondingto the subtree 64.And at this point\nI've discoveredwhere I have to insert, I've\nessentially found the location,it matches 79.And there was no modification\nrequired in this algorithm.So if that was 78 you'd\nessentially do the same things.But you're done because you\nfound the value, or the placethat you want to insert.And you've done a\nbunch of additions.And you go look at add 1, add\n2, add 1, add 1, and you have 5.And that's the\ncorrect answer, as youcan see from this example.So what's the bad news?The bad news was what\nthis lady said upfront, which was we haven't\nquite solved the problem.Because sadly, I could\neasily set thingsup such that the height h is\norder n, h could be order n.And if, for example, I\ngave you a sorted list,and I said insert into\nbinary search treethat's originally null 43,\nand you put 43 in there.", "start": 3000.0, "heat": 0.108}, {"text": "Then I say insert 46.And then I say instead of 48.And then I say\ninsert 49, et cetera.And, you know, these\ncould be any numbers.Then you see that what\ndoes this look like?Does it look like a tree?It looks like a list.That's the bad news.And I'll let Eric give\nyou good news next week.We need to have this notion of\nbalanced binary search trees.So everything I've said is true.I did not lie.But the one extra\nthing is we needto make sure these trees are\nbalanced so h is order log n.And then everything\nI said works.All right?See you next time.", "start": 3120.0, "heat": 0.224}]