[{"text": "[SQUEAKING][RUSTLING][CLICKING]JASON KU: Good\nmorning, everybody.STUDENT: Morning--JASON KU: My name's Jason Ku.I'm going to be teaching\nthis class in Introductionto Algorithms with two\nother instructors here--faculty in the department--Eric Demaine and Justin Solomon.They're excellent\npeople, and so theywill be working on teaching\nthis class with me.I will be teaching\nthe first lecture,and we'll have\neach of them teachone of the next two lectures,\nand then we'll go from there.This is Intro to Algorithms.OK, so we're going to start\ntalking about this coursecontent now.What is this course about?It's about algorithms--\nintroduction to algorithms.Really what the\ncourse is about isteaching you to solve\ncomputational problems.But it's more than that.It's not just about\nteaching you to solvecomputational problems.Goal 1-- solve\ncomputational problems.But it's more than that.It's also about communicating\nthose solutions to othersand being able to communicate\nthat your way of solvingthe problem is\ncorrect and efficient.So it's about two more things--prove correctness,\nargue efficiency,and in general, it's\nabout communication--", "start": 0.0, "heat": 0.746}, {"text": "I can't spell, by the way--communication of these ideas.And you'll find that, over\nthe course of this class,you'll be doing a lot\nmore writing than you doin a lot of your other courses.It really should maybe\nbe a CI kind of class,because you'll be doing a\nlot more writing than youwill be coding, for sure.Of course, solving the\ncomputational problemis important, but\nreally, the thingthat you're getting out of this\nclass and other theory classesthat you're not getting in\nother classes in this departmentis that we really\nconcentrate on beingable to prove that the\nthings you're doingare correct and better\nthan other things,and being able to communicate\nthose ideas to others, and notjust to a computer--to other people, convince\nthem that it's correct.OK, so that's what\nthis class is about.So what do I mean when I say\nsolve a computational problem?What is a problem?What is an algorithm?People make fun of me because\nI start with this question,but anyone want to\nanswer that question?No?What's a problem,\ncomputationally?No?OK, so it's not such\na stupid question.Yeah?STUDENT: [INAUDIBLE]JASON KU: Something\nyou want to compute--OK, yes, that's true.Right.But a little bit more\nabstractly, what I'm going tothink of a computational\nproblem being--and this is where\nyour prerequisitein discrete mathematics\nshould come in--a problem is-- you've\ngot a set of inputs.Maybe I have one, two, three,\nfour, five possible inputsI could have to my algorithm.", "start": 120.0, "heat": 0.1}, {"text": "Then I have a space of outputs.I don't know.Maybe I have more of\nthem than I do inputs,but these are the possible\noutputs to my problem.And what a problem is\nis a binary relationbetween these\ninputs and outputs.Essentially, for each input, I\nspecify which of these outputsis correct.It doesn't necessarily\nhave to be one.If I say, give me the index in\nan array containing the value5, there could be multiple\n5's in that array,and so any of those\nindices would be correct.So maybe this guy maps to that\noutput, and maybe this guy mapsto--I don't know-- two\nor three outputs.This input goes to one, two--I don't know.There's some kind\nof mapping here.These edges represent\na binary relation,and it's kind of a\ngraph, a bipartite graphbetween these\ninputs and outputs.And these are specifying\nwhich of these outputsare correct for these inputs.That's really the\nformal definitionof what a problem is.Now, generally, if\nI have a problem--a computational\nproblem, I'm not goingto specify the problem to you\nby saying, OK, for input 1,the correct answer is\n0, and for input 2,the correct answer's 3,\nand so on and so forth.That would take forever, right?Usually what we do\nwhen defining a problemis specify some kind of\npredicate, saying that,oh, we can check--if I give you an\ninput and an output,I can check whether that\noutput is correct or not.That's usually how we\ndefine a problem is,if I am checking for whether\nthis index contains a 5,I can just go to that array,\nlook at index 5, and--or the index you gave me,\nand see if it equals 5.So usually, we're putting\nit in terms of predicates", "start": 240.0, "heat": 0.1}, {"text": "because, in general,\nwe don't reallywant to talk about small\ninstances of problems.So let's say I had\nthe problem of,among the students in this\nclassroom, do any pair of youhave the same birthday?All right, well, probably, if\nthere's more than 365 of you,the answer is yes.Right?By what?Pigeonhole\nprinciple-- two of youmust have the same birthday.So let's generalize it\na little bit, say that--I don't know--I need a bigger space of\nbirthdays for this questionto be interesting.Maybe I tack on the year.Maybe I tack on the\nhour that you were born.And that's a bigger\nspace of inputs,and I wouldn't necessarily\nexpect that two of youwould be born in the\nsame year on the same dayin the same hour.That would be a\nlittle less likely.In fact, as long as that\nspace is larger than somethinglike the square of the\nnumber of you, thenI'm less likely than even\nto have a pair of you.That's a birthday problem\nyou may have seen in 042,potentially.But in general, I don't--I'm not going to mess with\nprobability so much here.I want a deterministic\nalgorithm, right awayof checking whether two of\nyou have the same birth time,let's say.OK, so in general,\nin this class,we're not going to\nconcentrate on inputs such as,is there a pair of\nyou in this classthat have the same birthday?That's kind of boring.I could do a lot of\ndifferent things,but what we do in\nthis class-- thisis for a fixed classroom of you.I want to make algorithms that\nare general to any classroom--", "start": 360.0, "heat": 0.1}, {"text": "to go to your recitation.I want an algorithm that will\napply to your recitation.I want an algorithm that not\nonly applies to this classroom,but also the machine\nlearning class before you.I want an algorithm\nthat can change its--it can accept an\narbitrarily sized input.Here we have a class of\nmaybe 300, 400 students,but I want my algorithm to\nwork for a billion students.Maybe I'm trying\nto check if there'sa match of something in\nthe Facebook databaseor something like that.So in general, we are looking\nfor general problems thathave arbitrarily sized inputs.So these inputs could\ngrow very large,but we want kind of a\nfixed size algorithmto solve those problems.So what is an algorithm, then?I really can't spell--told you.I didn't lie to you.So an algorithm is a little\ndifferent than a problem.A problem specification--I can tell you what\nthis graph looks like.An algorithm is really--I don't know what\nthe outputs are.I don't know what\nthese edges are.But I want a fixed size\nmachine or procedurethat, if I give it an input,\nit will generate an output.And if it generates\nan output, it betterbe one of these correct outputs.So if I have an algorithm\nthat takes in this input,I really want it to\noutput this output,", "start": 480.0, "heat": 0.162}, {"text": "or else it's not a\ncorrect algorithm.Similarly, for this one, it\ncould output any of these threeoutputs, but if it outputs\nthis guy for this input,that would not be a\ncorrect algorithm.And so generally, what we want\nis an algorithm is a function.It takes inputs to outputs.An algorithm is some\nkind of functionthat takes these inputs,\nmaps it to a single output,and that output better be\ncorrect based on our problem.So that's what our algorithm is.It solves the\nproblem if it returnsa correct output for\nevery problem inputthat is in our domain.Does anyone have a\npossible algorithmfor checking whether\nany two of youhave the same birth time,\nas specified before?I'm going to let\nsomeone else have a try.Sure.STUDENT: Just ask everyone\none by one, and every time[INAUDIBLE]JASON KU: Great-- so what\nyour colleague has saidis a great algorithm.Essentially, what\nit's going to dois I'm going to put\nyou guys in some order,I'm going to give\nyou each of youa number, one through however\nmany number of students thereare in this class.And I'm going to\ninterview you one by one.I'm going to say,\nwhat's your birthday?And I'm going to write it down.I'm going to put it in\nsome kind of record.And then, as I keep\ninterviewing you,I'm going to find\nout your birthday.I'm going to check the record.I'm going to look through all\nthe birthdays in the record.If I find a match,\nthen I return, yay--I found a pair-- and I can stop.Otherwise, if I get\nthrough the record list,I don't-- and I\ndon't find a match,I just stick you at\nthe end of the record--I add you to the\nrecord, and then Imove on to the next person.I keep doing this.OK, so that's a\nproposed algorithmfor this birthday problem.", "start": 600.0, "heat": 0.114}, {"text": "For birthday problem,\nwhat's the algorithm here?Maintain a record.Interview students\nin some order.And what does interviewing\na student mean?It means two things.It means check if\nbirthday in record.And if it is, return a pair.So return pair.Otherwise, add a new\nstudent to record.And then, at the very end,\nif I go through everybodyand I haven't found\na match yet, I'mgoing to return\nthat there is none.OK, so that's a statement\nof an algorithm.That's kind of the\nlevel of descriptionthat we'll be looking for you\nin the three parts of this--theory questions that we ask\nyou on your problem sets.It's a verbal description\nin words that--it's maybe not enough for a\ncomputer to know what to do,but if you said this algorithm\nto any of your friendsin this class, right they\nwould at least understandwhat it is that you're doing.Yeah?STUDENT: Does an algorithm\nhave to be a pure functionin a mathematical sense?JASON KU: Does an algorithm\nhave to be a pure functionin a mathematical sense?", "start": 720.0, "heat": 0.195}, {"text": "As in it needs to map\nto a single output?STUDENT: As in it can't\nmodify some external state.It can't take in state\nand it can't do I/O.JASON KU: So we're\ntalking about kindof a functional programming\ndefinition of a function.I am talking about\nthe mathematical--I have a binary\nrelation, and this thinghas an output for every\ninput, and there is exactlyone output to every input.That's the mathematical\ndefinition of functionthat I'm using for when\nI'm defining an algorithm.Yeah?STUDENT: Basically, is\nan algorithm like a plan?JASON KU: Yeah.An algorithm's a\nprocedure that somehow--I can do whatever\nI want, but I haveto take one of these inputs and\nI have to produce an output.And at the end, it\nbetter be correct.So it's just a procedure.You can think of it\nas like a recipe.It's just some\nkind of procedure.It's a sequence of things\nthat you should do,and then, at the end, you\nwill return an output.S here's a possible algorithm\nfor solving this birthdayproblem.Now, I've given you--what I argue to you, or\nI'm asserting to you,is a solution to this\nbirthday problem.And maybe you guys\nagree with me,and maybe some of you don't.So how do I convince you\nthat this is correct?If I was just running\nthis algorithm on, say,the four students in\nthe front row here,I could argue it\npretty well to you.I could assign these\nfor people birthdaysin various combinations\nof either their--none of them have the same\nbirthday, some two of them", "start": 840.0, "heat": 0.203}, {"text": "have the same birthday.I could try all\npossibilities, and Icould go through lots of\ndifferent possibilitiesand I need to check that\nthis algorithm returnsthe right answer\nin all such cases.But when I have--I don't know--\n300 of you, that'sgoing to be a little bit\nmore difficult to argue.And so if I want to argue\nsomething is correct in--I want to prove something to you\nfor some large value, what kindof technique do I use\nto prove such things?Yeah?Induction, right?And in general, what we do\nin this class, what we dois-- as a computer scientist is\nwe write a constant sized pieceof code that can take on any\narbitrarily large size input.If the input can be arbitrarily\nlarge, but our code is small,then that code needs\nto loop, or recurse,or repeat some of\nthese lines of codein order to just\nread that output.And so that's another way you\ncan arrive at this conclusion,that we're going\nto probably needto use recursion, induction.And that's part\nof the reason whywe ask you to take\na course on proofs,and inductive reasoning,\nand discrete mathematicsbefore this class.OK, so how do we prove\nthat this thing is correct?We got to use induction.So how can we set\nup this induction?What do I need for\nan inductive proof?Sure.STUDENT: [INAUDIBLE]JASON KU: Base case--\nwe need a base case.We need some kind\nof a predicate.Yeah, but we need\nsome kind of statementof a hypothesis of something\nthat should be maintained.And then we need to have an\ninductive step, which basicallysays I take a small\nvalue of this thing,", "start": 960.0, "heat": 0.143}, {"text": "I use the inductive\nhypothesis, and I argue itfor a larger value of\nmy well-ordered setthat I'm inducting over.For this algorithm,\nif we're goingto try to prove correctness,\nwhat I'm going to dois I'm going to--what do I want to\nprove for this thing?That, at the end of\ninterviewing all of you,that my algorithm has\neither already-- ithas returned with\na pair that match,or if we're in a\ncase where therewasn't a pair somewhere in my\nset, that it returned none.Right?That would be correct.So how can I\ngeneralize that conceptto make it something\nI can induct on?What I'm going to do\nis I'm going to say--let's say, after I've\ninterviewed the first Kstudents, if there was a match\nin those first K students,I want to be sure that\nI've returned a pair--because if, after I\ninterview all of you,I've maintained\nthat property, thenI'll be sure, at the\nend of the process,I will have returned\na pair, if one exists.So here's going to be\nmy inductive hypothesis.If first K students\ncontain a match,algorithm returns a match\nbefore interviewing, say,", "start": 1080.0, "heat": 0.193}, {"text": "student K plus 1.So that's going to be\nmy inductive hypothesis.Now, if there's n\nstudents in this class,and at the end of\nmy thing, I'm tryingto interview a student n plus\n1-- oh, student n plus 1'snot there.If I have maintained this,\nthen, if I replace K with n,then I will have\nreturned a matchbefore interviewing\nthe last student--when I have no\nmore students left.And then this algorithm\nreturns none, as it should.OK, so this inductive hypothesis\nsets up a nice variableto induct on.This K I can have\nincreasing, up to n,starting at some base case.So what's my base case here?My base case is--the easiest thing I can do--sure-- 2?That's an easy thing I could do.I could check those\npossibilities,but there's an even\neasier base case.Yeah?There's an even easier\nbase case than 1.STUDENT: 0--JASON KU: 0, right?After interviewing 0 students,\nI haven't done any work, right?Certainly, the first\n0 can't have a match.This inductive\nhypothesis this is truejust because this initial\npredicate is false.So I can say, base case 0--check.Definitely, this\npredicate holds for that.OK.Now we got to go for\nthe meat of this thing.Assume the inductive\nhypothesis true", "start": 1200.0, "heat": 0.151}, {"text": "for K equals, say, some K prime.And we're considering\nK prime plus 1.Then we have two cases.One of the nice\nthings about abductionis that it isolates our problem\nto not consider everythingall at once, but break it\ndown into a smaller interfaceso I can do less\nwork at each step.So there are two cases.Either the first K\nalready had a match--in which case, by our\ninductive hypothesis,we've already returned\na correct answer.The other case is the--it doesn't have a match, and\nwe interview the K plus 1thstudent--the K prime plus 1th student.If there is a match in the\nfirst K prime plus 1 students,then it will include K plus--the student K prime plus\n1, because otherwise,there would have been a match\nin the things before it.So there are two cases.If K contains match, K prime.If first K contains match--already returned by induction.Else, if K prime plus 1\nstudent's contains match,the algorithm checks all\nof the possibilities--", "start": 1320.0, "heat": 0.115}, {"text": "K prime checks\nagainst all students,essentially by brute force.It's a case analysis.I check all of\nthe possibilities.Check if birthday is in record--I haven't told you\nhow to do that yet,but if I'm able to\ndo that, I'm goingto check if it's in the record.If it's in the record,\nthen there will be a match,and I can return it.Otherwise, I have-- re-establish\nthe inductive hypothesisfor the K prime plus 1 students.Does that makes sense, guys?Yeah.OK, so that's how we\nprove correctness.This is a little bit\nmore formal than wewould ask you to do in\nthis class all the time,but it's definitely sufficient\nfor the levels of argumentsthat we will ask you to do.The bar that we're\nusually trying to setis, if you communicated\nto someone else takingthis class what\nyour algorithm was,they would be able to code it\nup and tell a stupid computerhow to do that thing.Any questions on induction?You're going to be using\nit throughout this class,and so if you are unfamiliar\nwith this line of argument,then you should go\nreview some of that.That would be good.OK, so that's correctness,\nbeing able to communicatethat the problem--the algorithm we\nstated was correct.Now we want to argue\nthat it's efficient.What does efficiency mean?Efficiency just means\nnot only how fast", "start": 1440.0, "heat": 0.1}, {"text": "does this algorithm run,\nbut how fast does itcompare to other possible ways\nof approaching this problem?So how could we measure\nhow fast an algorithm runs?This is kind of\na silly question.Yeah?STUDENT: [INAUDIBLE]JASON KU: Yeah.Well, just record the time\nit takes for a computerto do this thing.Now, there's a problem with\njust coding up an algorithm,telling a computer what to do,\nand timing how long it takes.Why?Yeah?STUDENT: [INAUDIBLE]JASON KU: It would depend on\nthe size of your data set.OK, we expect that, but\nthere's a bigger problem there.Yeah?STUDENT: [INAUDIBLE]JASON KU: It depends on the\nstrength of your computer.So I would expect that, if\nI had a watch calculatorand I programmed\nit to do something,that might take a lot longer to\nsolve a problem than if I askedIBM's research computer to\nsolve the same problem usingthe same algorithm,\neven with the same code,because its underlying\noperations are much faster.How it runs is much faster.So I don't want to\ncount how long itwould take on a real machine.I want to abstract the\ntime it takes the machineto do stuff out of the picture.What I want to say\nis, let's assumethat each kind of fundamental\noperation that the computer cando takes some fixed\namount of time.How many of those kinds\nof fixed operationsdoes the algorithm\nneed to perform to beable to solve this problem?So here we don't measure time.", "start": 1560.0, "heat": 0.223}, {"text": "Instead, count\nfundamental operations.OK?We'll get to what some of\nthose fundamental operationsare in a second,\nbut the idea is wewant a measure of how well\nan algorithm performs,not necessarily\nan implementationof that algorithm--kind of an abstract notion of\nhow well this algorithm does.And so what we're going to use\nto measure time or efficiencyis something called\nasymptotic analysis.Anyone here understand what\nasymptotic analysis is?Probably, since it's in both of\nyour prerequisites, I think--but we will go through\na formal definitionof asymptotic notation\nin recitation tomorrow,and you'll get a lot of\npractice in comparing functionsusing an asymptotic analysis.But just to give you\nan idea, the ideahere is we don't measure time.We instead measure ops.And like your colleague\nover here was saying before,we expect performance--I'm going to use performance,\ninstead of time here--we expect that to depend\non size of our input.If we're trying to\nrun an algorithmto find a birthday\nin this section,we expect the algorithm to run\nin a shorter amount of timethan if I were to run the\nalgorithm on all of you.So we expect it to\nperform differently,depending on the\nsize of the input,and how differently is\nhow we measure performance", "start": 1680.0, "heat": 0.199}, {"text": "relative to that input.Usually we use n as a variable\nfor what the size of our inputis, but that's not\nalways the case.So for example, if we have\nan array that I give you--an n-by-n array, that--\nwe're going to say n,but what's the\nsize of our input?How much information do\nI need to convey to youto give you that information?It's n squared.So that's the size of our\ninput in that context.Or if I give you a graph, it's\nusually the number of verticesplus the number of edges.That's how big--\nhow much space Iwould need to convey to you\nthat graph, that information.We compare how fast an\nalgorithm is with respectto the size of the input.We'll use the\nasymptotic notation.We have big O notation, which\ncorresponds to upper bounds.We will have omega, which\ncorresponds to lower bounds.And we have theta, which\ncorresponds to both.This thing is tight.It is bounded from\nabove and belowby a function of this form.We have a couple\nof common functionsthat relate an\nalgorithm's input sizeto its performance, some things\nthat we saw all the time.Can anyone give\nme some of those?STUDENT: [INAUDIBLE]JASON KU: Say again.STUDENT: [INAUDIBLE]JASON KU: Sorry.Sorry.", "start": 1800.0, "heat": 0.1}, {"text": "I'm not asking\nthis question well,but has anyone heard\nof a linear algorithm--a linear time algorithm?That's basically saying that the\nrunning time of my algorithm--performance of my algorithm\nis linear with respectto the size of my input.Right?Yeah?STUDENT: [INAUDIBLE]JASON KU: Say again.STUDENT: Like putting\nsomething in a list--JASON KU: Like putting\nsomething in a list--OK.There's a lot\nbehind that questionthat we'll go into\nlater this week.But that's an example of,\nif I do it in a silly way,I stick something in\nthe middle of a listand I have to move everything.That's an operation that\ncould take linear time.So linear time is\na type of function.We've got a number of these.I'm going to start\nwith this one.Does anyone know this one is?Constant time-- basically, no\nmatter how I change the input,the amount of time\nthis running time--the performance of my\nalgorithm takes, itdoesn't really depend on that.The next one up is\nsomething like this.This is logarithmic time.We have data n, which\nis linear, and log n.Sometimes we call\nthis log linear,but we usually just say n log n.We have a quadratic\nrunning time.In general, if I have a\nconstant power up here,it's n to the c\nfor some constant.This is what we call\npolynomial time,as long as c is some constant.And this right here is\nwhat we mean by efficient,in this class, usually.In other classes, when\nyou have big data sets,maybe this is efficient.But in this class, generally\nwhat we mean is polynomial.", "start": 1920.0, "heat": 0.1}, {"text": "And as you get down\nthis thing, thingsare more and more efficient.There's one class I'm going to\ntalk to you about over here,which is something like--let's do this-- 2 to the\ntheta of n, exponential time.This is some constant to\na function of n that's,let's say, super linear,\nthat's going to be pretty bad.Why is it pretty bad?If I were to plot some of these\nthings as a function of n--let's say I plot values of up\nto 1,000 on my n scale here.What does constant look like?Maybe this is 1,000 up here.What does a constant look like?Looks like a line--it looks like a line\nover here somewhere.It could be as high as\nI want, but eventually,anything that's an\nincreasing functionwill get bigger than this.And on this scale,\nif I use log base2 or some reasonable\nsmall constant,what does log look like?Well, let's do an easier one.What does linear look like?Yeah, this-- that's what I\nsaw what a lot of you doing.That's linear.That's the kind of base that\nwe're comparing everythingagainst.What does log look like?Like this-- OK,\nbut at this scale,really, it's much closer\nto constant than linear.And actually, as n gets\nmuch, much larger this almostlooks like a straight line.It almost looks like a constant.So log is almost just\nas good as constant.", "start": 2040.0, "heat": 0.1}, {"text": "What does exponential look like?It's the exact\ninverse of this thing.It's almost an exact\nstraight line going up.So this is crap.This is really good.Almost anything in this region\nover here is better right.At least I'm gaining something.I'm able to not go up too high\nrelative to my input size.So quadratic-- I don't know--\nis something like this,and n log n is\nsomething like this.n log n, after a\nlong time, reallystarts just looking linear\nwith a constant multipliedin front of it.OK, so these things\ngood, that thing bad--OK?That's what that's\ntrying to convey.All right, so how do\nwe measure these thingsif I don't know what my\nfundamental operations arethat my computer can use?So we need to define some\nkind of model of computationfor what our computer is\nallowed to do in constant time,in a fixed amount of time.In general, what we use\nin this class is a machinecalled a word RAM, which we use\nfor its theoretical brevity.Word RAM is kind\nof a loaded term.What do these things mean?Does someone know\nwhat RAM means?STUDENT: [INAUDIBLE]JASON KU: Random access memory--it means that I can randomly\naccess different placesin memory in constant time.That's the assumption\nof random access memory.Basically, what our\nmodel of a computer isyou have memory,\nwhich is essentially", "start": 2160.0, "heat": 0.1}, {"text": "just a string of bits.It's just a bunch\nof 1's and 0's.And we have a computer, like\na CPU, which is really small.It can basically hold a\nsmall amount of information,but it can change\nthat information.It can operate on\nthat information,and it also has instructions\nto randomly accessdifferent places in memory,\nbring it into the CPU,act on it, and read it back.Does that makes sense?But in general, we\ndon't have an addressfor every bit in memory,\nevery 0 and 1 in memory.Does anyone know how modern\ncomputers are addressed?Yeah?STUDENT: [INAUDIBLE]JASON KU: OK, so we're\ngoing to get there.Actually, what a modern\ncomputer is addressed inis bytes, collections of 8 bits.So there's an address\nI have for every 8 bitsin memory-- consecutive\n8 bits in memory.And so if I want to pull\nsomething in into the CPU,I give it an address.It'll take some chunk, and bring\nit into the CPU, operate on it,and spit it back.How big is that chunk?This goes to the answer that\nyou were asking, which--or saying, which is it's some\nsequence of some fixed numberof bits, which we call a word.A word is how big of\na chunk that the CPUcan take in from memory\nat a time and operate on.In your computers, how\nbig is that word size?64 bits-- that's how much\nI can operate on at a time.When I was growing up,\nwhen I was your age,my word size was 32 bits.And that actually was a\nproblem for my computer,", "start": 2280.0, "heat": 0.187}, {"text": "because in order for\nme to be able to readto address in\nmemory, I need to beable to store that address\nin my CPU, in a word.But if I have 32 bits, how\nmany different addresses canI address?I have a limitation on the\nmemory addresses I can address,right?So how many different\nmemory addressescan I address with 32 bits?2 to the 32, right?That makes sense.Well, if you do that calculation\nout, how big of a hard diskcan I have to access?It's about 4 gigabytes.So in my day, all\nthe hard driveswere limited to being\npartitioned-- even if youhad a bigger than 4\ngigabyte hard drive,I had to partition it into\nthese 4 gigabyte chunks, whichthe computer could\nthen read onto.That was very\nlimiting, actually.That's a restriction.With 64 bits, what's\nmy limitation on memorythat I can address--byte addressable?Turns out to be something\nlike 20 exabytes--to put this in\ncontext, all data thatGoogle stores on\ntheir servers, on alldrives throughout the world--it's about 10.So we're not going to run out\nof this limitation very soon.So what do we got\nwe've got a CPU.It can address memory.What are the operations\nI can do in this CPU?Generally, I have\nbinary operations.I can compare to\nwords in memory,and I can either do integer\narithmetic, logical operations,", "start": 2400.0, "heat": 0.259}, {"text": "bitwise operations--but we're not going to use\nthose so much in this class.And I can write and write\nfrom an address in memory,a word in constant time.Those are the\noperations that I haveavailable to me on most CPUs.Some CPUs give you a\nlittle bit more power,but this is generally what we\nanalyze algorithms with respectto.OK?But you'll notice\nthat my CPU is onlybuilt to operate on a constant\namount of information at once--generally, two words in memory.An operation produces a\nthird one, and I spit it out.It takes a constant\namount of timeto operate on a constant\namount of memory.If I want to operate on a\nlinear amount of memory--n things-- how long\nis that going to take?If I just want to read\neverything in that thing,it's going to take\nme linear time,because I have to read\nevery part of that thing.OK, so in general,\nwhat we're goingto do for the first half\nof this class mostly--first eight lectures, anyway--is talk about data structures.And it's going to be\nconcerned about not operatingon constant amount of data at\na time, like our CPU is doing,but instead, what it's\ngoing to do is operate on--store a large amount of data\nand support different operationson that data.So if I had a record\nthat I want to maintainto store those birthdays\nthat we had before,I might use something\nlike a static array, whichyou guys maybe are not\nfamiliar with, if you", "start": 2520.0, "heat": 0.1}, {"text": "have been working in Python is\nyour only programming language.Python has a lot of really\ninteresting data structures,like a list, and a\nset, and a dictionary,and all these kinds\nof things thatare actually not in this model.There's actually a lot of code\nbetween you and the computer,and it's not always\nclear how much timethat interface is taking.And so what we're going\nto do starting on Thursdayis talk about ways of\nstoring a non-constant amountof information to\nmake operationson that information faster.So just before you go,\nI just want to give youa quick overview of the class.To solve an algorithms\nclass-- an algorithmproblem in this\nclass, we essentiallyhave two different strategies.We can either reduced to using\nthe solution to a problem weknow how to solve,\nor we can designour own algorithm,\nwhich is goingto be recursive in nature.We're going to either put\nstuff in the data structureand solve a sorting problem,\nor search in a graph.And then, to design a\nrecursive algorithm,we have various\ndesign paradigms.This is all in your notes,\nbut this is essentiallythe structure of the class.We're going to spend quiz 1,\nthe first eight lectures on datastructures and sorting.Second quiz will be on shortest\npaths, algorithms, and graphs,and then the last one will\nbe on dynamic programming.OK, that's the end\nof the first lecture.Thanks for coming.", "start": 2640.0, "heat": 0.201}]