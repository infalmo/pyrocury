[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help MIT\nOpenCourseWare continue tooffer high quality educational\nresources for free.To make a donation or view\nadditional materials fromhundreds of MIT courses, visit\nMIT OpenCourseWare atocw.mit.edu.PROFESSOR: Good morning.This is 600.So I hope any of you who thought\nthis was a differentcourse find where you\nreally belong.My name is John Guttag.And I'll be lecturing the\ncourse all semester.OK.Today I want to accomplish\nseveral things.Cover some of the administrative\ndetails.Talk about the goals\nof the course--what I hope you'll learn.And then begin talking\nabout the conceptualmaterial in the course.It will seem a little bit slow,\nbecause it will be alittle bit slow.I promise starting on Thursday\nwe're going to pick up thepace considerably.So let's start with the\nstrategic goals of the course.The official introduction\nto course 6 is 601.Historically, students who\narrive at MIT with little orno programming experience\nfind 601 an ordeal.And the point of this is\nto prepare freshman andsophomores for entering\ncourse 6--that's the Electrical\nEngineering Computer Sciencedepartment--in a gentler, kinder way.So that 601 is not so\nmuch of a problem.I want to help students\nfeel justifiably--and I want to emphasize\nthe word justifiably--confident in their ability\nto write small andmedium sized programs.So at the end of the term, you\nshould all feel comfortable", "start": 0.0, "heat": 0.227}, {"text": "writing programs.The real theme of the course,\nand what I spend most of thetime on, is how to map\nproblems into acomputational framework.There's going to be an emphasis\non scientificproblems, rather than, say,\ncommercial problems.But there will be some talk\nabout some non-scientificproblems as well.How to take a problem that may\nnot at first blush appear tobe attackable with the program,\nand show you how toformulate the problem in such\na way that you can usecomputation to get insight\ninto the problem.It should not take\nyou very long.All of the problem sets involve\nprogramming in Pythonprogramming language, which I'll\nsay a little bit aboutlater today.The first problem set,\nbasically, is getting Pythoninstalled on your\nown computer.Most of the people will want to\njust use whatever their ownlaptop is to do the\nproblem sets on.Don't get fooled by the first\ntwo problem sets into thinkingthis is a gut course.It's not.It starts out gently\nto lure you in.And then life gets pretty\nhard pretty quickly.So don't be fooled.The quizzes--and there will be two evening\nquizzes and a final--are open book open notes.When you get to be my age, you\nget very sensitive about howdifficult it is to\nremember things.And so, we won't be asking\nyou to memorize stuff.The course is about solving\nproblems, knowing how to solveproblems, not how much\nyou can remember.For many of you who are majoring\nin biology or course20, it's going to be kind of a\nshock that this course isn'tabout how much you can remember,\nbut it's about how", "start": 120.0, "heat": 0.19}, {"text": "well you can solve problems.And that's what the quizzes\nare really goingto be focused on.Probably the most unusual thing\nabout this course is thecollaboration policy, which\nis liberal in the extreme.You can collaborate with anybody\nyou want on any of theproblem sets.Not on the quizzes.But on any of the\nproblem sets.You can work with each other,\nwhich is what I recommend.You can work with your parents,\nif one of themhappens to be a software\nengineer.You can work with friends\nin course 6.Whatever you want to do.The goal of the problem sets\nis to help you learn.What we've seen in the past is\npeople who are a little, shallI say too collaborative, i.e.\nthey just copy the problem setfrom somebody else, live in a\nfool's paradise which comescrashing down at\nthe first quiz.People who don't spend enough\ntime thinking about theproblem sets themselves cannot\ntake the quizzes successfully.So it's a fine line.But our goal is not\nto be policemen.I tell my TAs, their job is to\nhelp you learn, not to preventyou from, quote, cheating.So to solve that problem, we've\neliminated the conceptof cheating on problem sets.There is no way to cheat\non problem sets.So just go and do them.There's no textbook.We will be posting readings\non the web.For the most part, these will\nbe pointers to websites.Occasionally we'll\npost readingsthat we wrote ourselves.Doesn't mean you shouldn't\nbuy a textbook.In fact, there are a number\nof Python texts.We'll recommend a few of them.", "start": 240.0, "heat": 0.1}, {"text": "It might make sense to buy one\nand bring it to a quiz,because it will have an index\nthat will let you look thingsup quickly, that\nsort of thing.But again, a lot of students\nnever buy atext and do just fine.We will not be handing\nout class noteson a regular basis.A lot of studies have indicated\nthat students learnmore when they take their own\nnotes than when they arehanded out.And so, as a matter of what I\nthink is good pedagogy, wedon't hand out detailed\nlecture notes.We will be using, after today, a\nlot of handouts with code onthem, which we'll\nmake available.But it's not intended to make\nany sense outside the contextof lectures.It's not self-contained.The main purpose of this course\nis to help you becomeskillful in making the\ncomputer do whatyou want it to do.Once you acquire this skill,\nyour first instinct, whenconfronted with many tasks, will\nbe to write a program todo that task for you.I always tell people I became\na computer scientist in partbecause I'm lazy.And there was a lot of stuff\nthat I found it was easier towrite a program to make\nthe computer do it,rather than do it myself.So I do that a lot.If I need to do something, I\nsay, can I just write a quickprogram to do it?And I'd like you to be able\nto acquire that skill.And remember, that programming\nis actually a lot of fun.So I should say that, in\naddition to learning a lot inthis course, I hope most of\nyou will find it fun.Kind of a strange thought.MIT course, fun.Maybe it's an oxymoron.But I don't think so.I really do think you can have\na lot of fun writing programsfor this course.", "start": 360.0, "heat": 0.113}, {"text": "There are many people\nwho believe that--how shall I say this?Programming is the most\nfun you can have withyour clothes on.It really can be a lot of fun.So think of it that way.All right.So the primary knowledge you're\ngoing to take away iscomputational problem solving.So to start with, we might\nask the question, what iscomputation?And to think about that--this is interesting.Ah, there's where\nthe chalk is.I was afraid I was going to be\nconfronted with a sea of blackboards and erasers\nand no chalk.But there is chalk.So if we think about it,\nthere are essentiallytwo kinds of knowledge.Declarative--and you're going to see, I'm\nnot a great speller.And imperative.Declarative knowledge\nis composed ofstatements of fact.For example, a good health care\nplan improves the qualityof medical care while\nsaving money.As we know from doings in\nWashington, it's a lot easierto state that goal than to know\nhow to achieve that goal.So the key thing about\ndeclarative knowledge is, itsays something that is true.Otherwise it wouldn't be\nknowledge, it would bemisinformation.But doesn't tell you\nhow to do it.In a more mathematical sense,\nsay y is the square root of xif and only if y times\ny equals x.", "start": 480.0, "heat": 0.1}, {"text": "All right?Perfectly clear statement of\nwhat it means to be the squareroot, but it doesn't tell you\nhow to find the square root.Interestingly enough, it does\ntell you how to test whetheror not you have the answer\nto the square root.And so if you had some way of\ngenerating guesses, you can atleast check whether\nthey're correct.And in fact, starting in the\nnext lecture, we'll talk aboutthe fact that a lot of\ncomputational techniquesinvolve something called\nguess and check.Where you have a way to generate\nguesses and a way tocheck whether they're right.Imperative knowledge, in\ncontrast, tells you how tosolve a problem.How to accomplish something.So you could think of it as like\na recipe in a cookbook.So it's one thing to say a\nchocolate cake is somethingthat tastes delicious\nand is bad for you.That's declarative knowledge.But you can open a cookbook and\nget a recipe that tellsyou how to make a\nchocolate cake.That's imperative knowledge.Now, below, we have a recipe for\nfinding not a square rootnecessarily, but anapproximation to a square root.And one of the themes of this\ncourse is that a lot ofproblems we cannot solve\nprecisely, but we can findanswers that are good enough\nfor practical purposes.And those are called\napproximation algorithms.So here's a way--this is a very old method for\nfinding the square root.In fact, it's believed\nthat Heron was", "start": 600.0, "heat": 0.106}, {"text": "the one who did this.Heron of Alexandria.In the news much today,\nAlexandria was the capital ofancient Egypt.He was the first one to\nwrite this methoddown a long time ago.Though it's believed that even\nbefore Heron, the Babyloniansknow how to do it.So you start with a guess, g.Any old guess will do.Then you say, is g times\ng close enough to x?If so, you stop.Say OK, I've got a good enough\napproximation of the answer.If it's not, you create a new\nguess by averaging g and xdivided by g.So g new is going to be\ng old plus x dividedby g old, over 2.And then using this new guess,\nyou go back to step 2.So let's quickly run through\nan example of this.We can start with this\npretty easily.We'll take a guess.Let's say g equals 3.So we look at three times 3.9.And we say, is that\ngood enough?Well, let's say we're looking\nfor the root of 25.I guess I should have started\nwith the problem statement.Sorry about that.Well, 9 is probably not close\nenough to 25 that we're happy.May be good enough for\ngovernment work, but not formost other purposes.So we'll reset g, and we'll\nset g to 3 plus 25 over 3.", "start": 720.0, "heat": 0.118}, {"text": "All of that over 2.Which equals 5.6666 et cetera.All right.So now we'll multiply\nthat by itself.And that gets to\nbe about 32.04.Close enough to 25?Probably not.So we'll take another step.And we'll set g equal to--well, when we're done with it\nall, I'm not going to bore youwith writing the\nformula again.It'll be 5.04.If we square that, it's 25.4.We decide that's close enough\nto 25, and we're done.What we say at this point\nis that the algorithm--and that's an important word.An algorithm is a description\nof how to perform acomputation.We say that the algorithm\nhas converged.Which is a fancy way\nto say it's halted.", "start": 840.0, "heat": 0.1}, {"text": "What we've got here, if you\nthink about it, is a set ofinstructions.Steps that can be executed\nand a flow of control.The order in which\nwe execute them.So if we look at this, there's a\ndefault order of execution--1, 2, 3, 4.But then there's the go back\nto step 2 and start over.And there's a termination\ncondition.It tells us when to stop.And of course, that's\nimportant.I've always been amused, if you\nlook at a shampoo bottle,you'll see an algorithm that\nsays something like lather,rinse, repeat.And if you follow it\nliterally, younever get to stop.Which I suppose make sense if\nyou're selling shampoo,because people use\na lot of it.But really, there\nought to be sometermination condition there.OK.So now, how do we capture this\nidea of a recipe in amechanical process?One way would be to design a\nmachine specifically to dosquare roots.So if I knew how to design\ncircuits, which I don't, Icould sit down-- probably many\nof you could sit down--", "start": 960.0, "heat": 0.116}, {"text": "and design a circuit that wouldimplement this algorithm.And in fact, that's more or\nless what you'll find in acheap four function calculator\nthat does square roots.Not quite this algorithm, but\na similar algorithm is justpart of the circuitry\nto go compute that.And in fact, this used\nto be the way thatall computers worked.So the initial computers\nwere what are calledfixed program computers.They were designed to do very\nspecific things, and that'swhat they did.So for example, one of the very\nfirst computers, designedin 1941, by Atanasoff and\nBerry, solved systems oflinear equations for the purpose\nof plotting artillerytrajectories.And that's all it did.If you wanted to balance your\nbank account with thiscomputer, you couldn't do it.But you could figure\nout how to drop anartillery shell somewhere.Also during World War II, Alan\nTuring built a machinespecifically designed\nfor breaking theGerman enigma code.Actually a fascinating story of\nscience how that was built.But again, that was\nall it could do.These computers were useful,\nbut only in avery limited way.The big breakthrough, the thing\nit made computationreally important to society,\nwas the invention of thestored program computer.", "start": 1080.0, "heat": 0.1}, {"text": "It took people quite a while\nto figure this out.But once they did,\nit seems obvious.The basic notion of a stored\nprogram computer is that theinstructions are the\nsame as data.So now, there is no distinction\nbetween theprogram that implements the\nalgorithm and the data onwhich that program operates.So there's no difference between\nthe input of 25, partof the data, and the steps of\nthe algorithm used to do that.Once that was possible,\nthe machinesbecame infinitely flexible.You could change the program\nanytime you wanted.And furthermore, programs\ncould produce programs.Because programs can\nproduce data.And if program and data are\nthe same thing, that meansprograms can produce programs.And we were off and running.And that's really what made\ncomputers what they are today.Once this became clear as the\nparadigm for computers, peoplebegan to think of the computer\nitself as a program.And in particular, as a kind\nof program called aninterpreter.And we'll get to more\non this later today.An interpreter is a program that\ncan execute any legal setof instructions.", "start": 1200.0, "heat": 0.1}, {"text": "And consequently, can be used\nto describe and accomplishanything you can do\nwith a computer.So roughly speaking, this is\nwhat a stored program computerlooks like.This is 6004 in 40 seconds.It's got memory.Lots of it today.A control unit that basically\ntells it what to do.For example, fetch some data\nfrom memory, put some datainto memory, send some output\nto a screen, all of thosekinds of things.What for historical reasons we\ncall the arithmetic logicunit, this is, in some sense,\nthe brains of the computer.The thing that actually\ndoes computations.An accumulator, which\nis part of theALU that stores results.And a bunch of input\nand output devices.The things that we actually see\nwhen we use a computer.And that's it.And again, the key thing to\nnotice is, there's only onekind of memory.There's not a memory for program\nand a memory for data.There's just the memory.The nice thing to think about\nhere is, given a small set ofinstructions, you can\nthen build any kindof program you want.So typically, the computers have\na very small number ofbuilt-in instructions.Order of dozens,\nand that's it.And by combining those\ninstructions in very cleverways, you can do arbitrarily\ncomplex things.In much the same way a good\nchef can take a very smallnumber of ingredients, and from\nthose, produce a varietyof interesting edibles.", "start": 1320.0, "heat": 0.1}, {"text": "Alan Turing, in the 1930s--very famous British\nmathematician of whom you willhear more--showed that, in fact, there\nwere six primitiveinstructions.Each of which operated on\none bit of information.And with those six primitive\ninstructions, you could doanything that could be\ndone with a computer.Kind of amazing.It was six instructions.There were things like\nread, write, plus--I don't know, maybe minus.I forget what they were.And that was it.That's all you needed.We will not make you write\nprograms using only sixinstructions.We will give you a\nmuch larger set.But still, it's really\nquite remarkable.It's what makes programming\nsuch an amazing endeavor.OK.So what instructions\nwill you be using?Well, that's what a programming\nlanguage does.So a programming language\nprovides a set of primitiveinstructions.A set of primitive control\nstructures.So instructions and mechanisms\nfor controlling the order inwhich they get executed.And that's all.And then you can do whatever\nyou want with them.And what distinguishes one\nprogramming language fromanother is what these\nthings are.What are your instructions?What of your flow of control?And how do you combine them?What are the combining\nmechanisms?And in fact, it's the combining\nmechanisms more thananything else that separate\none language from another.The most amazing thing\nabout programming--", "start": 1440.0, "heat": 0.1}, {"text": "and this has its good side and\nits bad side, and it'ssomething you need to remember\nas you do the problem sets--is that the computer will always\ndo exactly what youtell what to do.It's remarkable.You don't have any friends\nwho will do whatever youtell them to do.I can tell you my children\ncertainly don't do whatever Itell them to do.And my wife doesn't either.Sometimes she probably\nthinks I do whatevershe tells me to do.But a computer will do what\nyou tell it to do.So that's very empowering.It's also very annoying.Because it means if your program\ndoesn't work, it'syour own darn fault.You got nobody else to\nblame but yourself.Because it's not the\ncomputer's fault.You may want to curse the\ncomputer, but you shouldn't.It's just doing what\nyou told it to.So be careful what\nyou wish for.All right.The programming language we're\ngoing to use in 600 is Python.It's a relatively recent\naddition tothe universe of languages.I want to emphasize that\nthis course is notabout learning Python.I will spend relatively little\ntime in the lectures tellingyou about Python.It's about computational\nmethods, is what this courseis really about.And Python is merely\na teaching tool.Once you learn to program in\nPython, it's easy to learn toprogram in another language.It's a very easily transferable\nskill.If we think about what defines\nany programming language, it's", "start": 1560.0, "heat": 0.1}, {"text": "got a syntax, a static\nsemantics, and a semantics.Are any of you here linguistics\nmajors?Not a one.All right.Then I can make up whatever I\nwant about these terms andmaybe you'll believe me.All right.So the syntax tells us which\nsequences of characters andsymbols constitute a\nwell-formed string.So it would tell us, maybe, that\nwe could write somethinglike x equals 3 plus 4.And that's syntactically\ncorrect.It's well-formed.It might also tell us that\nx equals 3 blank 4 is notsyntactically correct.It's not a legal string.So by analogy with English,\nthe syntax describes whichstrings of words constitute\nwell-formed sentences.Well-formed.Not necessarily meaningful.So it would tell you that some\nsentence like Susan isbuilding is syntactically\nwell-formed.It may not be very sensible.The static semantics tells\nus which well-formed", "start": 1680.0, "heat": 0.1}, {"text": "strings have a meaning.That are which strings\nare meaningful.So you can think about that\nas also making sense.So in Python, it might tell us\nthat some strings which aresyntactically fine don't\nmean anything.So for example, it might tell\nus that the string 3 dividedby the character string abc is\nsyntactically well-formedbecause it's value\noperator value.Sort of like noun verb\nnoun is syntacticallywell-formed in English.But it would tell us\nthat there's noreal meaning to this.Dividing a number by a string\ndoesn't mean anything.And so you would get an error\nmessage saying the syntax isOK, but the static semantics\nis broken.So for example, in English ,\nthe sentence I are big issomehow syntactically\nwell-formed--noun verb noun--but we might say it fails the\nstatic semantic test.We don't want to assign\na meaning to it.The semantics of the language\nlooks only at the strings thatare both syntactically correct\nand static semanticallycorrect, and assigns a\nreal meaning to them.In natural language, sentences\ncan be ambiguous.So one of my favorites, when I\nhave to write a recommendationletter for a student that maybe\nI don't think is sogood, I might say something\nlike I cannot praise thisstudent too highly.", "start": 1800.0, "heat": 0.1}, {"text": "Well, you can interpret\nthat however you want.It keeps me from getting sued,\nbut I can also claim, well, Idon't like the student at all.And English is full\nof those things.Programming languages, in\ncontrast, are designed so thatevery well-formed program\nhas exactly one meaning.There's no ambiguity.So you can't typically\ntalk of a program ashaving a semantic error.If it is well-formed, it\nmeans something, andthat's what it means.On the other hand, it's easy\nto talk about a programmeaning something other than\nyou wanted it to mean.And you will discover in the\nproblem sets, most of the timethe programs don't mean what\nyou want them to mean.That is to say, when you run\nthem, they don't give you thecorrect answer.And then you will go through\nthis process of debugging themand learning how to do it.So what might happen when we\nwrite a program that doesn'tdo what we want it to do?It might crash.By that, we mean stop running\nand produce some palpableindication that it\nhas done so.So you've all used programs\nthat have crashed, right?You sat there using your email\nprogram or Word, orPowerPoint, or something.And suddenly, it\njust goes away.And you get a message on your\nscreen and an invitation tosend Apple or Microsoft a file\nexplaining what went wrong sothey can fix it.In a properly designed computing\nsystem, when oneprogram crashes, it does not\ndamage the overall system.", "start": 1920.0, "heat": 0.1}, {"text": "So you'd like it to\njust be local.What else might it do?It might never stop.Now, if you have no idea how\nlong a program is supposed torun, this can be hard\nto diagnose.But again, I'm sure you've\nall run into this.I've certainly run into it.Every once in a while I'll\nsay, try and write aPowerPoint file.And it'll just sit there.Or I'll try to read a file and\nit'll just sit there and neverfinish the job.Or I don't have enough\npatience.But probably it would never\nhave finished it.Again, you will all write\nprograms that do this.It's a good idea to know how\nlong you expect your programsto run, so that you can\nrecognize this.Typically, we say that these\nprograms have in them aninfinite loop.And we'll talk about that when\nwe get to flow of control.Finally, a program might run to\ncompletion and produce thewrong answer.These problems are kind of in\nascending order of badness.If it crashes, at least\nyou know thatsomething has gone wrong.An infinite loop can be very\nannoying, because you justwait for a long time.But the worst thing that happens\nis when you thinkeverything is good\nand it's not.", "start": 2040.0, "heat": 0.1}, {"text": "There have been lots of\nexamples of this.This is the sort of thing\nthat costs lives.There was a radiation therapy\nmachine that produced thewrong dosage of radiation and\nactually killed quite a fewpeople, because they put in\nthe correct input, and itwould dose the patient\nwith radiation.And a fatal dose of radiation.That's a really bad mistake.There are buildings that\ncollapse because people runprograms that do the structural\nengineering, andthe programs give the\nwrong answer.Lots of bad things can happen.So one of the things we're going\nto spend time on thisterm is, what you can do to\navoid writing programs thathave this rather unpleasant\nproperty.How do you test them?How do you write them in such\na way that this is the leastlikely event?That's not what you\nwant to happen.OK.Some programming languages\ngive you a lot of help inavoiding these things.Python is kind of mediocre\nin that respect.It's not the best.It's not the worst.It's somewhere in the middle.Because what you'd like is a\nprogram with very rigorousstatic semantics, such that if\nyou pass those tests, it has ahigh probability of behaving\nas expected.So for example, it's a good\nthing that Python doesn'tallow you to do this.Because who knows what\nthat's going to do?Something weird.You'd rather be told no,\nyou can't write that.And then you have to write\nsomething that's more", "start": 2160.0, "heat": 0.1}, {"text": "obviously meaningful.Rather than it just making\nup an interpretation.As we will see going forward,\nPython is not, for example, asgood as Java is at weeding\nout meaningless things.Or things that have surprising\nmeanings.On the other hand, it's better\nthan C. So kind of in themiddle as these programming\nlanguages go.Why do we use Python in this\ncourse if it's not the best inthat respect?It's got several\ngood features.One of them is, it's\neasy to learn.It's much less complicated\nthan, say, Java.So the learning curve\nis much steeper.That's a good thing.You get up to speed faster.It's very widely used today in\na lot of areas of science,particularly the\nlife sciences.It has probably become the\nmost popular language inbiology and the other\nlife sciences.And therefore, for those of you\nwho have careers in thatarea, it's the most useful\nlanguage to know.It's also widely used in\nother areas as well.It is easier to debug\nthan most languages.And the reason it's easier to\ndebug than most languages, orthan many, is it's an\ninterpreted language.So you'll remember, I talked\nabout a computer as aninterpreter.Something that you feed in a\nbunch of instructions, calledthe source code.You do some checking.And then it executes the\ninstructions, including theflow of control instructions.Produces some output.The nice thing that goes on\nthere is if something untowardhappens, the interpreter can\ndescribe in the language of", "start": 2280.0, "heat": 0.332}, {"text": "the source code what\nwent wrong.The source code is the\ncode that you wrote.On the other hand, the way a\ncompiler works is, you takethe source code, you check it,\nbut then you translate it intoanother language called\nthe object code.This is a language closer\nto the language that thecomputer, the hardware, knows\nhow to interpret.Then the hardware interpreter\ninterprets the compiled code,the object code, and\nproduces output.And the problem here is if\nsomething goes wrong, it wantsto give you an error message in\nterms of the object code,which you've never seen\nin your life.And that can make\nit very obscure.So the advantage?Why do we have compilers?Typically, compiled languages\nare more efficient.Because they go through this\nextra step, they take lesstime to run those programs.You can compile Python as well,\nif you want to get anefficient version.But it's not designed under\nthat assumption.And so, it works well when\nit's interpreted, whichis why we use it.", "start": 2400.0, "heat": 0.345}]