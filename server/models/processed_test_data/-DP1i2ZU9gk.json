[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: All right everyone.Let's get started.So today's lecture and\nWednesday's lecture,we're going to talk\nabout this thing calledobject oriented programming.And if you haven't\nprogrammed before,I think this is a fairly\ntough concept to grasp.But hopefully with\nmany, many examplesand just by looking at the\ncode available from lectures,you'll hopefully get\nthe hang of it quickly.So let's talk a little\nbit about objects.And we've seen objects\nin Python so far.Objects are basically\ndata in Python.So every object that we've\nseen has a certain type.OK, that we know.Behind the scenes,\nthough, every objecthas these two additional things.One is some data representation.So how Python represents the\nobject just behind the scenesand what are different\nways that youcan interact with the object.So for example, every one of\nthese is a different object.For example, this\nis the number 1,234.It's a specific object\nthat is of type integer.The number 5 is a different\nobject that's of type integerand so on.We've seen floats.We've seen strings.We've seen lists.Lists and dictionaries are\nmore complicated objects.Object types.Sorry.But every object has a\ntype, some sort of waythat it's represented\nin Python and some ways", "start": 0.0, "heat": 0.1}, {"text": "that we can interact with them.OK.So the idea behind object\noriented programmingis, first of all, everything\nin Python is an object.We've said that before\nand in this lectureI think we'll really\nget at what that means.So we've seen strings,\nintegers, dictionaries, lists.Those are all objects.When we did functions,\nwe saw that wecould pass as a parameter\nanother function.So functions were also\nobjects in Python.So literally everything\nin Python is an object.So what are the kinds of\nthings we can do with objects?Well, once you have a type,\nyou can create a new objectthat is of some type.And you can create\nas many objectsas you'd like of that\nparticular type, right?An integer 5 and integer 7.Those all work in a program.Once you've created\nthese new objects,you can manipulate them.So for a list, for example,\nyou can append an itemto the end of the list,\nyou can delete an item,remove it, concatenate\ntwo lists together.So that's ways that you\ncan interact with objects.And the last thing you can\ndo is you can destroy them.So and with lists,\nwe saw explicitlythat you can delete\nelements from a list,or you can just\nforget about themby reassigning a variable\nto another value,and then at some\npoint, Python willcollect all of these dead\nobjects and reclaim the memory.So let's continue\nexploring what objects are.So let's say I have these\ntwo separate objects.One is a blue car.One is a pink car.So objects are really\ndata abstractions.So these two cars can be\ncreated by the same blueprint.OK?This is a blueprint for a car\nand if an object is a dataabstraction, there's two\nthings that this abstractionis going to capture.The first is some sort\nof representation.What is going to represent the\ncar, what data represents a carobject?And the second is\nwhat are ways that we", "start": 120.0, "heat": 0.162}, {"text": "can interact with the object?So if we think about\na car blueprint,some general\nrepresentation for a carcould be the number of wheels\nit has, the number of doorsit has, maybe its\nlength, maybe its height,so this is all part of what\ndata represents the car.OK?The interface for\nthe car is whatare ways that you\ncan interact with it.So for example, you\ncould paint a car, right?So you could change its color.You could have the\ncar make a noiseand different cars might\nmake different noises.Or you can drive the car, right?So these are all ways that\nyou can interact with the car.Whereas the representation\nare what makes up the car.What data abstractions\nmake up the car.Let's bring it a little closer\nto home by looking at a list.So we have this data\ntype of list, right?We've worked with lists before.The list with elements 1, 2, 3,\nand 4 is a very specific objectthat is of type list.Again, we think about it\nin terms of two things.One is what is the data\nrepresentation of the list?So behind the scenes how\ndoes Python see lists?And the second is, how do\nyou interact with lists?So what are ways that\nyou can manipulate a listobject once it's created?So behind the scenes\nyou have a list, L,which is going to be made up\nof essentially two things.One is going to be the\nvalue at specific index.OK?So at index 0, it has\nthe value 1, right,because it's the first\nelement in the list.And the second thing\nthat represents a listis going to be this second\npart, which is a pointer.And internally this\npointer is goingto tell Python\nwhere is the memorylocation in the computer where\nyou can access the elementindex 1.So it's just essentially\ngoing to be a chain,", "start": 240.0, "heat": 0.217}, {"text": "going from one\nindex to the other.And at the next memory location\nyou have the value at index 1,and then you have\nanother pointerthat takes you to the\nlocation in memorywhere the index 2 is located.And in index 2 you\nhave the value and thenthe next pointer,\nand so on and so on.So this is how Python\ninternally represents a list.OK?How you manipulate lists,\nwe've done this a lot, right?You can index into a list, you\ncan add two lists together,you can get the length, you can\nappend to the end of a list,you can sort a list, reverse a\nlist, and so many other things,right?So these are all\nways that you caninteract with the list object\nas soon as you've created it.So notice both of these,\nthe internal representationand how you\nmanipulate lists, youdon't actually\nknow internally howthese are represented, right?How did whoever\nwrote the list classdecide to implement a sort.We don't know.You also weren't aware of how\nthese lists were representedinternally.And you didn't\nneed to know that.That's the beauty of\nobject oriented programmingand having these\ndata abstractions.The representations are\nprivate of these objectsand they are only known by what\nyou can find out how it's done,but they only should be known\nby whoever implemented them.You, as someone who\nuses this class,doesn't really need to know\nhow a list is representedinternally in order\nto be able to use itand to write cool\nprograms with them.OK?So just find a\nmotivation here before westart writing our\nown types of objectsis the advantages of\nobject oriented programmingis really that\nyou're able to bundlethis data, bundle some\ninternal representation,and some ways to interact with\na program into these packages.And with these packages,\nyou can create objectsand all of these\nobjects are goingto behave the exact same way.They're going to have the\nsame internal representation", "start": 360.0, "heat": 0.261}, {"text": "and the same way that you\ncan interact with them.And ultimately, this is going to\ncontribute to the decompositionand abstraction ideas\nthat we talked about whenwe talked about functions.And that means that\nyou're going to beable to write code that's a lot\nmore reusable and a lot easierto read in the future.OK.So just like when we\ntalked about functions,we're going to sort\nof separate the codethat we talk about today into\ncode where you implement a datatype and code where you use\nan object that you create.OK?So remember when we\ntalked about functions,you were thinking about it in\nterms of writing a function,so you had to worry\nabout the details of howyou implement a function.And then you had\nto worry about justhow to use a function, right?So it's sort of the\nsame idea today.So when you're thinking about\nimplementing your own datatype, you do that with\nthis thing called a class.And when you create\na class, you'rebasically going to\nfigure out what name youwant to give your\nclass and you'regoing to find some attributes.And attributes are\ngoing to be the datarepresentation and ways that you\ncan interact with your object.So you, as the\nprogrammer of this class,are going to decide\nhow you want peopleto interact with the object\nand what data this objectis going to have.So for example,\nsomeone wrote codethat implements a\nlist class, right,and we don't actually\nknow how that was done.But we can find out.So creating the class is\nimplementing the classand figuring out data\nrepresentation and waysto interact with the class.Once that's done, you\ncan then use your class.And you use the\nclass by creatingnew instances of the class.", "start": 480.0, "heat": 0.34}, {"text": "So when you create\na new instance,you essentially\ncreate a new objectthat has the type, the\nname of your class.And you can create as many\nobjects as you'd like.You can do all the\noperations that you'vedefined on the class.So for example,\nsomeone wrote the codeto implement list class\nand then you can justuse the list class like this.You can create a new list, you\ncan get the length pf the list,you can append to the end of\nthe list, and so on and so on.So let's start defining\nour own types, OK?So now you're going\nto define classes,you're going to\nwrite classes whichare going to define your\nown types of objects.So for today's\nlecture we're goingto look at code\nthat's going to bein the context of a\ncoordinate object.And a coordinate\nobject is essentiallygoing to be an object\nthat's going to definea point in an xy plane.So x, y is going to be a\ncoordinate in a 2D plane.So we're going to\nwrite code that'sgoing to allow us to\ndefine that kind of object.So the way we do that is\nwe have to define a class.So we have to tell Python,\nhey, I'm defining my own objecttype.So you do that with\nthis class key word.So you say class, then you\nsay the name of your type.In this case, we're creating\na type called coordinate.Just like we had type list,\ntype string, and so on.This is going to be a\ntype called coordinate.And then in\nparentheses here, youput what the parents\nof the class are.For today's lecture, the\nparent of the classesare going to be this\nthing called object,and object is the very\nbasic type in Python.It is the most basic\ntype in Python.And it implements things like\nbeing able to assign variables.", "start": 600.0, "heat": 0.252}, {"text": "So really, really\nbasic operationsthat you can do with objects.So your coordinate\nis therefore goingto be an object in Python.All right.So we've told Python we\nwanted to define an object.So inside the class definition\nwe're going to put attributes.So what are attributes?Attributes are going to be\ndata and procedures thatbelong to the class, OK?Data are going to be the data\nrepresentations and proceduresare going to be ways that we\ncan interact with the object.The fact that they\nbelong to the classmeans that the data and the\nprocedures that we writeare only going to work with\nan object of this type.OK.If you try to use any of\nthe data or the procedureswith an object of\na different type,you're going to get an\nerror because these dataand these attributes will\nbelong to this particular class.So the data attributes is,\nwhat is the object, right?What is the data that\nmakes up the object?So for our coordinate\nexample, it'sgoing to be the x and y\nvalues for coordinate.We can decide that\ncan be ints, wecan decide that we can\nlet them be floats,but it's going to have one\nvalue for the x-coordinateand one value for\nthe y-coordinate.So those are data attributes.And procedure attributes\nare better known as methods.And you can think of a\nmethod as a function.Except that it's a\nfunction that onlyworks with this\nparticular type of object.So with a coordinate\nobject, in this case.So the methods are\ngoing to define how youcan interact with the object.So in a list, for\nexample, we've saidthat you can append an item\nto the end of the list,we can sort a list,\nthings like that.So when you're defining\nmethods, you'redefining ways that people can\ninteract with your object.So for example, for\na coordinate object,we can say that we can take\nthe distance between twocoordinate points.", "start": 720.0, "heat": 0.401}, {"text": "OK?And that's going to be a\nway that you can interactwith two coordinate points.And just to be clear,\nthese are goingto belong to this\nclass, which meansthat if you try to use this\ndistance method on two lists,for example, you're\ngoing to get an error.Because this distance method was\nonly defined to work with twocoordinate type objects.All right, so let's\ncarry on and continueimplementing our class.So we've written this\nfirst line so far,class coordinate object.So now let's define attributes.First thing we're going to\ndefine are data attributes.Generally you define data\nattributes inside this init,and this is underscore,\nunderscore, init, underscore,underscore, and it's a special\nmethod or function in a class.And the special\nmethod tells Python,when you implement\nthe special method,it tells Python when you first\ncreate an object of this type,call this method or\ncall this function.So how do we do that?So let's implement it.So we say df because\nit's just a function.The name is the\nspecial name, init.And we give it some\nparameters, right,just like any other function.These last two\nparameters are x and y,which are going to represent how\nyou create a coordinate object.So you give it a value\nfor the x-coordinateand you give it a value\nfor the y-coordinate.The self, however, is\na little bit trickier.So the self is going\nto be a parameter whenyou define this\nclass that representsa particular instance\nof the class.So we're defining\nthis coordinate objectin sort of a general way, right?We don't have a\nspecific instanceyet because we haven't\ncreated an object yet.But this self is\ngoing to be sort", "start": 840.0, "heat": 0.268}, {"text": "of a placeholder for\nany sort of instancewhen you create the object.So in the definition\nof the class,whenever you want to\nrefer to attributesthat belong to an instance,\nyou have to use self dot.So this dot notation.And the dot is going to say\nlook for a data attributex that belongs to this class.So for methods that\nbelong to the class,the first parameter is\nalways going to be self.It can be named\nanything you want,but really by convention\nit's always named self.So try to stick to that.And then any other\nparameters beyond itare going to be just\nparameters as youwould put in a normal function.OK.In this particular\ncase, we're goingto choose to initialize\na coordinate objectby two values, one for\nthe x and one for the y.And inside this\ninit method, we'regoing to have two assignments.The first one says,\nthe x data attributeof a coordinate object.I'm going to assign it to\nwhatever was passed in.And the y data attribute\nfor a particular objectis going to be assigned\nwhatever y was passed in.Questions so far about\nhow to write this init?Yeah, question.AUDIENCE: [INAUDIBLE]PROFESSOR: How do you\nmake sure that x and yare inits or floats?So this is something\nthat you couldwrite in the specifications,\nso the docstringwith the triple quotes.So whoever uses the\nclass would thenknow that if they do something\noutside the specification,the code might not\nwork as expected.Or you could put\nin a cert statement", "start": 960.0, "heat": 0.376}, {"text": "inside the definition\nof the init justto sort of force that.Force that to be true.Great question.Yeah, question.AUDIENCE: [INAUDIBLE]PROFESSOR: Does the x,\ndoes this self x and this xhave to be the same name.The answer is no.And we're going to\nsee in class exercisethat you can have\nit be different.OK.Great.So this defines the way\nthat we create an object.So now we have sort\nof a nice class.It's very simple, but\nwe can start actuallycreating coordinate objects.So when you create\ncoordinate objects,you're creating\ninstances of the class.So this line here, C is\nequal to coordinate 3,4,is going to call\nthe init method.It's going to call the init\nmethod with x is equal to 3and y is equal to 4.I'm just going to go over here\nand I wrote this previously,because notice when we're\ncreating an object here,we're only giving\nit two parameters.But in the init method, we\nhave actually three parameters,right?We have these three\nparameters here,but when we're\ncreating an object,we only give it two parameters.And that's OK because\nimplicitly, Pythonis going to say self is going\nto be this object C, so justby default, OK?So when you're creating\na coordinate object,you're passing it all the\nvariables except for self.So this line here is\ngoing to call the initand it's going to do every\nline inside the init.So it's going to create\nan x data attribute for C,a y data attribute\nfor C, and it'sgoing to assign 3 and 4\nto those respectively.", "start": 1080.0, "heat": 0.403}, {"text": "This next line here is\norigin equals coordinate 0,0 creates another object.OK?It's another coordinate\nobject whose value for x is 0and whose value for y is 0.So now we have two\ncoordinate objects.We can access the\ndata attributesusing this dot notation and\nwe've seen that before, right?When we've worked with lists\nwe'd say something like,L dot append, right,\nwhen we create a list.So the same dot notation can\nbe used with your own objectsin order to access\ndata attributes.So here, this is\ngoing to print 3because the x value\nfor object C is 3,and the next line,\nprint origin xis going to print 0 because the\nx value for the object originis 0.OK.So we've created a\ncoordinate object.We have to find the\ninit method so wehave a way to create objects\nwhen we use the class.And then we can access\nthe data attributes.But that's kind of lame, right,\nbecause there isn't anythingcool we can do with it.There isn't ways to\ninteract with this object.So let's add some methods.Remember methods are going to\nbe procedural attributes thatallow us to interact\nwith our object.Methods are like functions\nexcept that there'sa couple of differences\nwhich you'll see in a moment.And when you're\ncalling methods, you'reusing the dot operator, like\nL dot append, for example,for lists.So let's go back to defining\nour coordinate classand let's define\na method for it.So so far we've defined\nthat part there,class coordinate and an init.So we have that.So in this slide we're going\nto add this method here.So this method here\nis going to sayI'm going to define a\nmethod called distance", "start": 1200.0, "heat": 0.31}, {"text": "and I'm going to pass\nin two parameters.Remember self, the\nfirst parameter,is always going to be\nthe instance of an objectthat you're going to\nperform the operation on.So pretty much by convention\nit's always named self.And then for this\nparticular method,I'm going to give it\nanother parameter,and I can name this\nwhatever I want.I'm naming it other.And this is going to represent\nthe other coordinate objectfor which I want to find\nthe distance from my self.So here I'm going\nto just implementthe Euclidean distance formula,\nwhich is x1 minus x2 squared,plus Y1 minus Y2 squared,\nand square root of all that.So that's what I'm\ndoing inside here.Self and other are\ncoordinate objects.Inside this method, I have\nto refer to the x dataattributes of each\nobject if I wantto find the difference between\nthe 2x values from them.So that's why I'm doing\nself dot x here, right.If I just did x, I would be\naccessing just some variablenamed x in a program which\nactually isn't even defined.So you always have to\nrefer when as we'rethinking about\nclasses, you alwayshave to refer to\nwhose data attributedo you want to access?In this case, I want\nto access the x dataattribute of my self, and I\nwant to subtract the x dataattribute of this\nother coordinate,square that, same for y,\nsquare that, and then add thoseand take the square\nroot of that.So notice this method is pretty\nmuch like a function, right?You have DF, some name,\nit takes in parameters.It does some stuff and\nthen it returns a value.The only difference is the\nfact that you have a self here", "start": 1320.0, "heat": 0.398}, {"text": "as the first thing and\nthe fact that you alwayshave to be conscious about\nwhose data attributesyou're accessing.So you have to use the\ndot notation in orderto decide whose data\nattributes you want access.So we've defined the\nmethod here, distance.So this is in the\nclass definition.Now how do we use it?So let's assume that the\ndefinition of distanceis up here.I didn't include the code.But really all you need\nto know is what it takes.It takes a self and an other.So when you want\nto use this methodto figure out a distance\nbetween two coordinate objects,this is how you do it.So the first line, I create\none coordinate object.Second line, I create\nanother coordinate object.First one is named C, the\nsecond one is named 0.These are two separate objects.And I'm going to\nfind the distance.And I want to first\ncall it on one object,so I'm going to say C dot,\nso I'm using the dot notationto call the method\ndistance on object C.So Python says this object\nC is of type coordinate.It's going to look\nup at the classcoordinate that you defined.It's going to find this\nmethod called distanceand then it's going to say\nwhat parameters does it take?So it takes another parameter,\nright, for the otherand then, in the\nparentheses, I justhave to give it this\nother perimeter.An easier way to\nsee what happensis by looking at what this\nline here is equivalent to.So the third line\nhere prints C dotdistance 0 is equivalent\nto this one on the right.And this one on the\nright essentiallysays, what's the\nname of the class,dot, dot notation, what's\nthe method you want to call,", "start": 1440.0, "heat": 0.408}, {"text": "and then in\nparentheses you give itall of the variables\nincluding self.OK.So in this case you're\nexplicitly telling Pythonthat self is C and other is 0.So this is a little bit easier\nto understand, like that.But it's a little cumbersome\nbecause you alwayshave to write coordinate dot,\ncoordinate dot, coordinate dot,for every data\nattribute you might wantto access, for every\nprocedural attribute youmight want to access.So by convention,\nit's a lot easierto do the one on the left.And as I mentioned,\nPython implicitly says,if you're doing the\none on the left,you can call this method\non a particular objectand it's going to look\nup the type of the objectand it's going to essentially\nconvert this on the leftto the one on the right.And this is what you've\nbeen using so far.So when you create a list,\nyou say L is equal to 1, 2,and then you say L.append,\nyou know, 3 or whatever.So we've been using this\nnotation on the leftpretty much from the\nbeginning of class.So we have a\ncoordinate class, wecan create a\ncoordinate object, wecan get the distance\nbetween two objects.As you're using\nthe class, if youwanted to use this\ncoordinate class,and you were maybe debugging\nat some point, a lot of youprobably use print as a\ndebug statement, right?And maybe you want to print the\nvalue of a coordinate object.So if you create a\ncoordinate object,C is equal to\ncoordinate 3, 4, right?That's what we've done so far.If you print C, you\nget this funny message.Very uninformative, right?It basically says, well,\nC is an object of typecoordinate at this memory\nlocation in the computer.", "start": 1560.0, "heat": 0.353}, {"text": "Which is not what you\nwanted at all, right?Maybe you wanted to know what\nthe values for x and y were.That would be a lot\nmore informative.So by default, when you\ncreate your own type, whenyou print the\nobject of that type,Python tells you this\nsort of informationwhich is not what you want.So what you need\nto do is you needto define your own\nmethod that tellsPython what to do\nwhen you call printon an object of this type.So this is going to be\na special method, justlike init is, because\nit starts and endswith double underscores.And the name of the method is\nunderscore, underscore, str,underscore, underscore.And if you define this method in\nyour class, that tells Python,hey, when you see a\nprint statement that'son an object of type\ncoordinate, call this method,look what it does, and do\neverything that's inside it.And you can choose to make\nit do whatever you wantinside your definition of str.In this case, let's say when\nwe print a coordinate object,we're going to print its\nx and y values surroundedby angle brackets.That seems reasonable, right?So then from now on when you\nprint coordinate objects,you're going to see\nthings like this, whichis a lot more informative.So how do we define this?So so far we've defined\nall that and the last partis going to be new.So we define the init\nand the distance,and let's define this str.So underscore, underscore,\nstr, underscore, underscore, isa method.It's only going to take self\nbecause you're just callingprint on the object itself.There's no other\nparameters to it.Str has to return a string,\nand in this particular case,", "start": 1680.0, "heat": 0.348}, {"text": "we're going to return\nthe string that'sthe angle brackets concatenated\nwith the x value of the object,self.x, concatenated\nwith a comma,concatenated with the y value\nof this particular instanceof an object, self.y,\nand then concatenatedwith the angle brackets.So now any time you have\nprint on an object of typecoordinate, you're going to\ncall this special method str,if it's implemented\nin your code.Any questions?OK.So let's try to wrap our\nhead around types and classesbecause we've seen a lot today.Let's create a\ncoordinate object,assign it 3, 4, as we have been,\nand assign it to variable C.We've implemented the str\nmethod, so when we print C,it's going to print out this\nnice three comma for our anglebrackets.If we print the type\nof C, this is actuallygoing to give us class main\ncoordinate, which tells usthat C is going to\nbe an object thatis of type class coordinate.If we look at\ncoordinate as a class,if we print what coordinate is,\ncoordinate is a class, right?So this is what Python tells\nus, if we print coordinate,it's a class named coordinate.And if we print the\ntype of a coordinate,well that's just\ngoing to be a type.So class is going to be a type.So you're defining\nthe type of an object.If you'd like to figure out\nwhether a particular object is", "start": 1800.0, "heat": 0.232}, {"text": "an instance of a\nparticular class,you use this special\nfunction called is instance.So if you print is instance\nC comma coordinate,this is going to print true\nbecause C is an object thatis of type coordinate.Couple more words on\nthese special operators.So these special\noperators allow youto customize your classes which\ncan add some cool functionalityto them.So these special\noperators are goingto be things like\naddition, subtraction,using the equal equal sign,\ngreater than, less than,length and so on and so on.So just like str,\nif you implementany of these in your classes,\nthis is going to tell Python.So for example, if we've\nimplemented this underscore,underscore, add, underscore,\nunderscore in our class,this is going to\ntell Python whenyou use this plus operator\nbetween two objects of typecoordinate to call this method.If you have not\nimplemented this methodand you try to add two\nobjects of type coordinate,you're going to get an error\nbecause Python doesn't actuallyknow right off\nthe bat how to addtwo coordinate objects, right?You have to tell\nit how to do that.And you tell it how to\ndo that by implementingthis special method.Same with subtract.Same with equals.So if you want to figure out\nwhether two objects are equal.And when you implement these\nmethods in your own class,you can decide exactly\nwhat you want to do.So what happens when you\nadd two coordinate objects?Do you just add the x values,\ndo you just add the y values,do you get them both\ntogether, do youdo whatever you'd like to do.And then you document\nwhat you've decided.So let's create a\nfraction object.So we've looked\nat coordinate, wesaw sort of a higher\nlevel car object.Let's look at a fraction object.", "start": 1920.0, "heat": 0.433}, {"text": "Fraction object\nis going to be, isgoing represent a number that's\ngoing to be a numerator slashdenominator.OK.So that's going to\nbe a fraction object.So the way I've decided to\ninternally represent a fractionobject is with two numbers.And I've decided that I\nwill not let them be floats.They have to be integers,\nhence the assert over here.So inside the init,\nI've decided I'mgoing to represent my\nfracture with two numbers, onefor the numerator and\none for the denominator.So when I create\na fraction object,I'm going to pass in a\nnumerator and a denominator.And a particular\ninstance is goingto have self dot\nnumerator and self dotdenominator as its\ndata attributesand I'm assigning those to be\nwhatever's passed into my init.Since I plan on debugging this\ncode maybe possibly sometimein the future, I'm also\nincluding an str methodand the str method is going\nto print a nice looking stringthat's going to represent\nthe numerator, and thena slash, and then\nthe denominator.And then I've also implemented\nsome other special methods.How do I add two fractions?How do I subtract two fractions?And how do I convert\na fraction to a float?The add and subtract\nare almost the same,so let's look at the\nadd for the moment.How do we add two fractions?We're going to take self, which\nis the instance of an objectthat I want to do\nthe add operation on,", "start": 2040.0, "heat": 0.398}, {"text": "and we're going to\ntake other, whichis the other\ninstance of an objectthat I want to do the\noperation on, so the addition,and I'm going to\nfigure out the new top.So the new top of the\nresulting fraction.So it's my numerator multiplied\nby the other denominatorplus my denominator multiplied\nby the other numeratorand then divided by the\nmultiplication of the twodenominators.So the top is going to be that,\nthe bottom is going to be that.Notice that we're\nusing self dot, right?Once again, we're\ntrying to accessthe data attributes of\neach different instance,right, of myself and the other\nobject that I'm working with.So that's why I have\nto use self dot here.Once I figure out the top and\nthe bottom of the addition,I'm going to return,\nand here notice I'mreturning a fraction object.It's not a number, it's not\na float, it's not an integer.It's a new object that is of\nthe exact same type as the classthat I'm implementing.So as it's the same\ntype of object,then on the return\nvalue I can doall of the exact same\noperations that I can doon a regular fraction object.Sub is going to be the same.I'm returning a fraction object.Float is just going to\ndo the division for me,so it's going to\ntake the numeratorand then divide it\nby the denominator,just divide the numbers.And then I'm defining here\nmy own method called inverse.And this is just going to take\nthe inverse of the instance I'mcalling this method on.And so it's going to also return\na new fraction object that justhas the denominator\nas the top partand the numerator\nas the bottom part.So then we have some code here.", "start": 2160.0, "heat": 0.447}, {"text": "So that's how I implement\nmy fraction object.So now let's use it and\nsee what it gives us.A is equal to a fraction 1, 4.This is going to\nbe 1 over 4 for a.And b is going to\nbe 3 over four.When I do C, notice I'm using\nthe plus operator between twofraction objects, right?A and b are fraction\nobjects so Python'sgoing to say, OK, is there an\nunderscore, underscore, add,underscore, underscore,\nmethod implemented?It is and it's just going to\ndo whatever's inside here.So it's going to say self\ndot numerator plus other dotdenominator.It's going to calculate\nthe top and the bottom.It's going to turn a\nnew fraction object.So this is going to be 4 plus 12\ndivided by 16, and 16 over 16.So C as a fraction\nobject is goingto be 16 for the numerator\nand 16 for the denominatorbecause it's a fraction object.If I print C, it should\nprint 16 over 16,so we can even run it,\nso print 16 over 16.If I print floats C, so this\nspecial method float hereis going to say, is there a\nmethod that converts a fractionto a float and there is.", "start": 2280.0, "heat": 0.412}, {"text": "It's this one\nimplemented right here.So it's just going to divide\nthe two numbers, top and bottom,which gives me 1.So it's this one here and here.Notice I'm doing the\nexact same method call,except I'm doing it\nthe other way whereyou type in the name of the\nclass, name of the method,and then what you're\ncalling it on,and this gives the exact\nsame value here, 1.0.And then here I'm calling\nthe method inverseon object B which is going to\ninvert 3 over 4 to be 4 over 3.And then I'm converting\nit to a floatand then I'm printing the value.So it gives me 1.33.So take a look at this\ncode in more detailand see if you can trace through\nall of those different thingsand see if you can also write\nyour own new fraction objects.OK.So last slide.Power of object\noriented programmingis that you can bundle\ntogether objects thatare of the exact same type.And all of these\nobjects are goingto have the same\ndata representationand the same methods\nthat you can do on them.And ultimately, you're\ngoing to be buildingthese layers of abstraction.So you're going to be building\non a basic object typein Python, you're going to have\ninteger objects, float objects.On top of those, you can\ncreate lists, dictionaries.And on top of\nthose, you can evencreate your own object types as\nwe saw in this lecture today.", "start": 2400.0, "heat": 0.389}]