[{"text": "The following content is provided under a\nCreative Commons license. Your support willhelp MIT OpenCourseWare continue to offer\nhigh quality educational resources for free.To make a donation or view additional materials\nfrom hundreds of MIT courses,visit MIT OpenCourseWare at ocw.mit.edu.PROFESSOR: All right. Good morning, everyone.\nLet's get started. So we're going to start6.046 in earnest today. We're going to start\nwith our first module on divide and conquer.You've all seen divide and conquer algorithms\nbefore. Merge sort is a classic divide andconquer algorithm. I'm going to spend just\na couple minutes talking about the paradigm,give you a slightly more general setting than\nmerge sort. And then we'll get into two reallycool divide and conquer problems in the sense\nthat these are problems for which divide andconquer works very well-- mainly, convex hall\nand median finding.So before I get started on the material, let\nme remind you that you should be signing upfor a recitation section on Stellar. And please\ndo that even if you don't plan on attendingsections. Because we need that so we can assign\nyour problem sets to be graded, OK?So that's our way of partitioning problem\nsets as well. And then the other thing isproblem set one is going to go out today.\nAnd that it's a one week problem set.All problem sets are going to be a week in\nduration. Please read these problem sets theday that they come out. Spend 5, 10 minutes\nreading them.Some things are going to look like they're\nmagic, that they're-- how could I possiblyprove this? If you think about it for a bit,\nit'll become obvious. We promise you that.", "start": 0.0, "heat": 0.1}, {"text": "But get started early. Don't get started at\n7:00 PM when we have 11:59 PM deadline onThursday, all right? That four hours or five\nhours of time may not be enough to go frommagical to obvious, OK?So let's get started with the paradigm associated\nwith divide and conquer. It's just a beautifulnotion that you can break up the problem into\nsmaller parts and somehow compose the solutionsto the smaller parts. And of course, the details\nare going to be what's important when we takea particular problem instance.But let's say we're given a problem of size\nn. We're going to divide it into a sub problems--I'll put that in quotes so you know it's a\nsymbol-- a sub problems of size n over b.And here, a is an integer.And a is going to be greater than or equal\nto 1. It could be two. It could be three.It could be four.This is the generalization I alluded to. And\nb does not have to be two or even an integer.But it has to be strictly greater than one.Otherwise, there's no notion of divide and\nconquer. You're not breaking things up intosmaller problems. So b should be strictly\ngreater than one. So that's the general setting.And then you'll solve each sub problem recursively.\nAnd the idea here is that once the sub problemsbecome really small, they become constant\nsize, it's relatively easy to solve them.", "start": 120.0, "heat": 0.1}, {"text": "You can just do exhaustive search.If you have 10 elements and you're doing effectively\na cubic search, well, 10 cubed is 1,000. That'sa constant. You're in great shape as long\nas the constants are small enough.And so you're going to recurse until these\nproblems get small. And then typically-- thisis not true for all divide and conquer approaches.\nBut for most of them, and certainly the oneswe're going to cover today, the smarts is\ngoing to be in the combination step-- whenyou combine these problems, the solutions\nof these sub problems, into the overall solution.And so that's the story.Typically, what happens in terms of efficiency\nis that you can write a recurrence that'sassociated with this divide and conquer algorithm.\nAnd you say t of n, which is a running time,for a problem of size n is going to be a times\ntfn over b-- and this is a recurrence-- plusthe work that you need to do for the merge\noperational or the combine. This is the sameas merge.And so you get a recurrence. And you're not\nquite done yet in terms of the analysis. Becauseonce you have the recurrence, you do have\nto solve the recurrence. And it's usuallynot that hard and certainly it's not going\nto be particularly difficult for the divide", "start": 240.0, "heat": 0.1}, {"text": "and conquer examples that we're going to look,\nat least today.But we also have this theorem that's called\nthe master theorem that is essentially somethingwhere you can fairly mechanically plug in\nthe a's and the b's and whatever you havethere-- maybe it's theta n, maybe it's theta\nn square-- and get the solution to the recurrence.I'm actually not going to do that today. But\nyou'll hear once again about the massive theoremtomorrow in section. And it's a fairly straightforward\ntemplate that you can use for most of thedivide and conquer examples we're going to\nlook at in 046 with one exception that we'lllook at in median finding today that will\nsimply give you the solution to the recurrence,OK?So you've see most of these things before.\nThat's a little bit of setup. And so let'sdive right in into convex hull, which is my\nfavorite problem when it comes to using divideand conquer.So convex hull, I got a little prop here which\nwill save me from writing on the board andhopefully be more understandable. But the\nidea here is that in this case, we have atwo dimensional problem with a bunch of points\nin a two dimensional plane. You can certainlydo convex hull for three dimensions, many\ndimensions. And convexity is something thatis a fundamental notion in optimization.And maybe we'll get to that in 6046 in advanced\ntopics, maybe not. But in the context of today'slecture, what we're interested in doing is\nessentially finding an envelope or a hullassociated with a collection of points on\na two dimensional plane. And this hull obviously", "start": 360.0, "heat": 0.161}, {"text": "is going to be something, as you can guess,\nthat encloses all of these points, OK?So what I have here, if I make this string\ntaut enough-- this is not working so well,but I think you get the picture. All right,\nso that's not a convex hull. This is not aconvex hull for the reason that I have a bunch\nof points outside of the hull.All right, so let me just-- that is a convex\nhull. And now if I start stretching like thator like this or like that, that's still a\nconvex hull, OK? So that's the game.We have to find an algorithm. And we look\nat a couple of different ones that will findall of these segments that are associated\nwith this convex hull, OK? So this is a segmentthat's part of the convex hull.That's a segment that's part of the convex\nhull. If, in fact, I had something like this--and this was stretched out-- because I have\nthose two points outside the convex hull,this may still be a segment that's part of\nthe electronics hall but this one is not,right? So that's-- the game here is to find\nthese segments. So if you're going to workingwith segments or tangents-- they're going\nto be used synonymously-- all of the tangentsor segments associated with the entirety of\nthe convex hull and we have to discover them.And only input that we have is the set of\npointx-- xiy coordinates.", "start": 480.0, "heat": 0.224}, {"text": "And there's just a variety of algorithms that\nyou can use to do this. The one that I wishI had time to explain but I'll just mention\nis what's called a gift wrapping algorithm.You might not have done this, but I guarantee\nyou I said you probably have taken a misshapengift, right, and tried to wrap it in gift\nwrapping paper.And when you're doing that, you're essentially--\nif you're doing it right you're essentiallytrying to find the convex hull of this three\ndimensional structure. You're trying to tightenit up. You're trying to find the minimum amount\nof gift wrapping paper.I'm not sure if you've ever thought about\nminimizing gift wrapping paper, but you shouldhave. And that's the convex hull of this three\ndimensional shape. But we'll stick to twodimensions because we'll have to draw things\non the board. So let me just spec this outa bit.I've been given endpoints in a plane. And\nthose set of points are s, xi, yi such thati equals 1, 2 to n. And we're just going to\nassume here, just to make things easy becausewe don't want to have segments that are null\nor segments that are a little bit differentbecause they're discontinuous. But we're going\nto assume that no two have the same x-coordinate.This is just a matter of convenience. And\nno two have the same y-coordinate.\nAnd then finally, no three in a line.Because we want to be able to look at pairs\nof points and find these segments. And it", "start": 600.0, "heat": 0.165}, {"text": "just gets kind of inconvenient. You have to\ndo special cases if there of them are on aline. And so the convex hull itself is the\nsmallest polygon containing all points ins. And we're going to call that ch of s--\nconvex hull of s.STUDENT: Smallest convex polygon.PROFESSOR: The smallest convex polygon--\nthank you. And so just as an example on theboard, when you have something like this,\nyou're going to have your convex hull beingthat. This one is inside of it.These two points are inside of it. And all\nthe other ones form the hull. And so we mighthave p, q, r, s, t, u. And v and x are inside\nof the hull. They're not part of the specificationof ch of s, which I haven't quite told you\nhow we're going to specify that.But the way you're going to specify that is\nsimply by representing it as a sequence ofpoints that are on the boundary on the hull\nin clockwise order. And you can think of thisas being a doubly linked list in terms of\nthe data structure that you'd use if you coded", "start": 720.0, "heat": 0.182}, {"text": "this up. So in this case, it would be p to\nq to r to s.You're going to start with t in this case.\nIt's a doubly linked list. So you could conceivablystart with anything. But that's the representation\nof the convex hull.And we're going to use clockwise just because\nwe want to be clear on as to what order we'reenumerating these points. It's going to become\nimportant when we do the divide and conqueralgorithm. So let's say that we didn't care\nabout divide and conquer just for the heckof it and I gave you a bunch of points over\nhere.Can you think of a simple-- forget efficiency\nfor just a couple of minutes. Can you thinkof a simple algorithm that would generate\nthe segments of the convex hull? For example,I do not want to generate this segment vx.If I think of a segment as being something\nthat is defined by two points, then I don'twant to generate the segment vx because clearly\nthe segment is not part of the convex hull.But whereas the segment pq, qr, rs, et cetera,\nthey're all part of the convex hull, right?So what is the obvious brute force algorithm,\nforgetting efficiency, that given this setof points will generate one by one the segments\nof the convex hull?Anybody? Did you have your head up? No? Go\nahead. Yep.", "start": 840.0, "heat": 0.185}, {"text": "STUDENT: Draw the line and check how many other lines intersect with it.PROFESSOR: Draw the line and check how many\nlines it intersects with.STUDENT: Yeah.PROFESSOR: Is there-- I think you got-- you\ndraw the line. That's good, right?STUDENT: [LAUGHS]\nAUDIENCE: [LAUGHING]PROFESSOR: Well-- but you want to do a little\nmore. Yeah, go ahead.STUDENT: For every pair of points you see, make a half-plane and see where they completeall of their other points. [INAUDIBLE]PROFESSOR: Ah, so that's good. That's good.\nThat's good.All right, so the first person who breaks\nthe ice here always gets a Frisbee. Sorryman. At least I only hit the lecturer-- no\nliability considerations here. OK, now I'mgetting scared.Right, so I think there's a certain amount\nof when I throw this, am I going to chokeor not, right? But it's going to get higher\nwhen one of you guys in the back answers aquestion. So you're exactly right.And you draw a line. And then you just look\nat it. And you look at the half plane.And if all the points are to one side, it\nis a segment of the convex hull. If they'renot, it's not a segment-- beautiful. All right,\nare we done? Can we go and enjoy the goodweather outside?No, we've got ways to go here. So this is\nnot the segment whereas one-- let me drawthat. I should draw these in a dotted way.This is not a segment. This is not a segment.\nThis is a segment.And I violated my rule of these three not\nbeing in a straight line. So I'll move thisover here. And then that's a segment and so\non and so forth, OK? Right?STUDENT: It's no longer a side with the ones below it.PROFESSOR: I'm sorry?STUDENT: It would have to go directly to the bottom one from the left one.PROFESSOR: Oh, you're right. That's a good\npoint. That's an excellent point.", "start": 960.0, "heat": 0.137}, {"text": "SO what happened here was when I moved that\nout-- exactly right. Thank you. This is good.So when I moved this out here, what happened\nwas-- and I drew this-- well, this one here,my convex hull, changed. The problem specification\nchanged on me. It was my fault. But then whatwould happen, of course, is as I move this,\nthat would become the segment that was partof the convex hull, OK?So sorry to confuse people. But what we have\nhere in terms of an algorithm, if I leavethe points the same, works perfectly well.\nSo let me just leave the points the same andjust quickly recap, which is, I'm going to\ntake a pair of points.And I'm going to draw-- and let me just draw\nthis in a dotted fashion first. And I'm goingto say that's the segment. And I'm going to\ntake a look at that line and say this breaksup the plane into two half planes. Are all\nabout points on one side?And if the answer is yes, I'm going to go\nahead and, boom, say that is a segment ofmy convex hull. If the answers is no, like\nin this case, I'm going to drop that segment,OK? So now let's talk about complexity.Let's say that there are n points here. And\nhow many segments do I have? I have O n squaretheta n square segments.And what is the complexity of the test? What\nis the complexity of the test that's associatedwith, once I've drawn the segments, deciding\nwhether the segment is going to be a tangentwhich is part of the convex hull or not? What\nis the complexity?STUDENT: O n.PROFESSOR: O n-- exactly right. So on test\ncomplexity-- and so we got over theta n cubedcomplexity, OK? So it makes sense to do divide\nand conquer if you can do better than this.", "start": 1080.0, "heat": 0.22}, {"text": "Because this is a really simple algorithm.\nThe good news is we will be able to do betterthan that. And now that we have a particular\nalgorithm-- I'm not quite ready to show youthat yet.Now that we have a particular algorithm, we\ncan think about how we can improve things.And of course we're going to use divide and\nconquer. So let's go ahead and do that. Andso generally, the divide and conquer, as I\nmentioned before, in most cases, the divisionis pretty straightforward.And that's the case here as well. All the\nfun is going to be in the merge step. Right,so what we're going to do, as you can imagine,\nis we're going to take these points.And we're going to break them up. And the\nway we're going to break them up is by dividingthem into half lengths. We're going to just\ndraw a line.And we're going to say everything to the left\nof the line is one sub problem, everythingto the right of the line is another sub problem,\ngo off and find the convex hull for each ofthe sub problems. If you have two points,\nyou're done, obviously. It's trivial.And at some point, you can say I'm just going\nto deal with brute force. If we can go downto order n cubed, if n is small, I can just\napply that algorithm. So it doesn't even haveto be the base case of n equals 1 or n equals\n2. That's a perfectly fine thing to do.But you could certainly go with n equals 10,\nas I mentioned before, and run this bruteforce algorithm. And so at that point, you\nknow that you can get down to small enoughsize sub problems for which you can find the\nconvex hull efficiently. And then you've gotthese two convex hulls which are clearly on\ntwo different half planes because that's theway you defined them.And now you've got to merge them. And that's\nwhere all the fun is, OK? So let's just write", "start": 1200.0, "heat": 0.137}, {"text": "this out again.You're going to sort the points by x-coordinates.\nAnd we're going to do this once and for all.We don't have to keep sorting here because\nwe're just going to be partitioning basedon x-coordinates.And we can keep splitting based on x-coordinates\nbecause we want to generate these half-lengths,right? So if we can do those once and for\nall-- and for the input set S, we're goingto divide into the left half A and right half\nB by the x-coordinates. And then we're goingto compute CH of A and CH of B recursively.And then we're going to combine. So the only\ndifference here from what we had before isthe specification of the division. It looked\npretty generic.It's similar to the paradigm that I wrote\nbefore. But I've specified exactly how I'mgoing to break this up. So let's start with\nthe merge operation. We're going to spendmost of our time specing that.And again, there's many ways you could do\nthe merge. And we want the most efficientway. That's obviously going to determine complexity.\nSo, big question-- how to merge.So what I have here, if I look at the merge\nstep, is I've created my two sub problems", "start": 1320.0, "heat": 0.159}, {"text": "corresponding to these two half planes. And\nwhat I have here is-- let's say I've generated,at this point, a convex hull associated with\neach of these sub problems. So what I havehere is a1, a2.I'm going to go clockwise to specify the convex\nhull. And the other thing that I'm going todo is in the sub problem case, my starting\npoint is going to be for the left sub problem,the coordinate that has the highest x value,\nOK? So that's a1 in this case-- the highestx value going over. x is increasing to the\nright.And for the right half of the problem, it's\ngoing to be the coordinate that has the lowestx value. And I'm going to go clockwise in\nboth of these cases. So when you see an orderingassociated with the subscripts for these points,\nstart with a1 or b1 and then go clockwise.And that's how we number this-- so just notational,\nnothing profound here.So I got these two convex hulls-- these sub\nhulls, if you will. And what I need to donow is merge them together. And you can obviously\nlook at this and it's kind of obvious whatthe overall convex hull is, right?But the key thing is, I'm going to have to\nlook at each of the pairs of points that areassociated with this and that and try to generate\nthe tangents, the new tangents, that are notpart of the sub hulls, but they're part of\nthe overall hull, right? So in this case,", "start": 1440.0, "heat": 0.118}, {"text": "you can imagine an algorithm that is going\nto kind of do what this brute force algorithmdoes except that it's looking at a point from\nhere and a point from here.So you could imagine that I'm going to do\na pairwise generation of segments. And thenI'm going to check to see whether these segments\nare actually tangents that are part of theoverall convex hull or not. So what I would\ndo here is I'd look at this.And is that going to be part of the overall\nhull? No, and precisely why not? Someone tellme why this segment a1 b1 is not part of the\noverall hull? Yeah, go ahead.STUDENT: If we were to draw a line through the whole thing there would be one on both sides.PROFESSOR: Exactly right-- that's exactly\nright. So here you go. So that's not partof it. Now, if I look at this-- well, same\nreason that's not part of it.In this case-- and this is a fairly obvious\nexample. I'm going to do something that'sslightly less obvious in case you get your\nhopes up that we have this trivial algorithm,OK? This is looking good, right? That's supposed\nto be a straight line, by the way.So a4 b2-- I mean, that's looking good, right?\nBecause all the points are on one side. Soa4 b2 is our upper tangent. Right, so our\nupper tangent is something that we're goingto define as-- if I look at each of these\nthings, I'm going to say they have a yij.OK, what is yij? yij is the y-coordinate.\nof the segment that I'm looking at, the ijsegment.", "start": 1560.0, "heat": 0.11}, {"text": "So this yij is for ai and bj. So what I have\nhere is y42 out here. And this is-- for theupper tangent, yij is going to be maximum,\nright? Because that's essentially somethingwhich would ensure me that there are no points\nhigher than that, right?So if I go up all the way and I find this\nthat has the maximum yij, that is going tobe my upper tangent. Because only for that\nwill I have no points ahead of that, OK? Soyij is upper tangent.This is going to be maximum. And I'm not going\nto write this down, but it makes sense thatthe lower tangent is going to have the lowest\nyij. Are we all good here? Yeah, question.STUDENT: So I am just wondering, I couldn't hear\nwhat she said why we moved out a1 b1.PROFESSOR: OK, so good. Let me-- that reason\nwe moved out a1 b1 is because if I just drewa1 b1 like this-- and I'm extrapolating this.\nThis is again supposed to be a straight line.Then you clearly see that there are points\non either side of the a1 b1 segment when youlook at the overall problem, correct? You\nsee that on a1 b1, b2 is on this side, b3is on this side if I just extend this line\nall the way to infinity in both directions.And that violates the requirement that the\nsegment be part of the overall hull, OK?That make sense? Good. So, everybody with\nme?So clearly, there's a trivial merge algorithm\nhere. And the trivial merge algorithm is tolook at not every pair of points-- every ab\npair, right? Every aibj pair.And so what is the complexity of doing that?\nIf I have n total points, the complexity would", "start": 1680.0, "heat": 0.295}, {"text": "be-- would be in square, right? Because maybe\nI'd have half here and half here, ignore constants.And you could say, well, it's going to be\nn squared divided by 4, but that's theta nsquared. So there's an obvious merge algorithm\nthat is theta n square looking at all pairsof points. And when I mean all pairs of points,\nI mean like an a and a b.Because I want to pick a pair when I go left\nof that dividing line and then right of thedividing line. But either way, it's theta\nn square, OK? So now you look at that andyou go, huh. Can I do a better?What if I just went for the highest a point\nand the highest b point and I just, no, that'sit? I'm done-- constant time. Wouldn't that\nbe wonderful? Yeah, wonderful, but incorrect,OK?Right, so what is an example. And so\nthis is something that I spent a little bitof time last night concocting. So I'm like\nyou guys too. I do my problem set the nightbefore.Well, don't do as I do. Do as I say. But I've\ndone this before. So that's the difference.But this particular example is new. So what\nI have here is I'm going to show you why there'snot a trivial algorithm, OK, that-- I got\nto get these angles right-- that you can'tjust pick the highest points and keep going,\nright?", "start": 1800.0, "heat": 0.508}, {"text": "And then that would be constant time. So that's\nmy a over here. And let's assume that I havemy dividing line like that. And then what\nI'm going to do here-- and I hope I get thisright-- is I'm going to have something like\nthis, like that.And then I'm going to have b1 here clockwise--\nso b2, b3, and b4. So as you can see here,if I look at a4-- a little adjustment necessary.\nOK, so if I look at that, a4 to b1 versus--I mean, just eyeball it.A3 to b1-- right, is a4 to b1 going to be\nthe upper tangent? No, right? So now a3 islower than a4. You guys see that?And b1 is lower than b2, right? So it's clear\nthat if I just took a4 to b2 that it willnot be an upper tangent. Everybody see that?Yep, all right, good. So we can't have a constant\ntime algorithm. We have theta and square inthe back. So it is there something-- maybe\ntheta n?How would we do this merge and find the upper\ntangent by being a little smarter about searchingfor pairs of points that give us this maximum\nyij? I mean, the goal here is simple. At somelevel, if you looked at the brute force, I\nwould generate each of these things.I would find the yj intercepts associated\nwith this line. And I just pick the maximum.And the constant time algorithm doesn't work.The theta n squared algorithm definitely works.\nBut we don't like it. So there has to be something", "start": 1920.0, "heat": 0.274}, {"text": "in between. So, any ideas? Yeah, back there.STUDENT: So... I had a question. [INAUDIBLE]PROFESSOR: No, you're just finding-- no, you're\nmaximizing the yij. So for once you have thissegment-- so the question was, isn't the obvious\nmerge algorithm theta n cubed, right? Andmy answer is no, because the theta n extra\nfactor came from the fact that you had tocheck every point, every endpoint, to see\non which side of the plane it was. Whereashere, what I'm doing is I've got this one\nline here that is basically y equals 0, ifyou like, or y equals some-- I'm sorry, x\nequals 0 or x equals some value.And I just need to, once I have the equation\nfor the line associated with a4 b1 or a4 b2,I just have to find the intercept of it, which\nis constant time, right? And then once I findthe intercept of it, I just maximize that\nintercept to get my yij. So I'm good, OK?So it's only theta n squared, right? Good\nquestion. So this is actually quite-- very,very, very clever.This particular algorithm is called the two\nfinger algorithm. And I do have multiple fingers,but it's going to work a lot better if I borrow\nEric's finger. And we're going to demonstrateto you the two finger algorithm for merging\nthese two convex hulls. And then we'll talkabout the complexity of it.And my innovation again last night was to\nturn this from a two-finger algorithm. Notonly did I have the bright idea of using Eric--\nI decided it was going to become the two fingeran string algorithm. So this is wild.This is my contribution to 046 lore-- come\non. So the way the two finger algorithm works--", "start": 2040.0, "heat": 0.252}, {"text": "this pseudo code should be incomprehensible.\nIf you just look at it and you go, what, right?But this demo is going to clear everything\nup. Right so here's what you do. So now we'regoing to do a demo of the merge algorithm\nthat is a clever merge algorithm than theone that uses order n square time. And it's\ncorrect. It's going to get you the correctupper tangent and what we are starting at\nhere is with Erik\u2019s left finger on A1, whichis defined to be the point that's closest\nto the vertical line that you see here, theone that has the highest x-coordinate. And\nmy finger is on B1, which is the point thathas the smallest X-coordinate on the right\nhand side sub-hull. And what we do is we compute,for the segment A1 B1, we compute by Yij,\nin this case Y11, which is the intercept onthe vertical line that you see here that Erik\njust marked with a red dot. And you can lookat the pseudocode over on, to my right if\nI face the board. And what happens now isI'm going to move clockwise, and I'm going\nto go from B1 to B4. And what happened here?Did the Yij increase or decrease? Well, as\nyou can see it decreased. And so I'm goingto go back to B1. And we're not quite done\nwith this step here. Erik\u2019s going to gocounterclockwise over to A4. And we're going\nto check again, yeah, keep the string taught,check again whether Yij increased or decreased\nand as is clear from here Yij increased. Sonow we move to this point. And as of this\nmoment we think that A4 B1 has the highest", "start": 2160.0, "heat": 0.182}, {"text": "Yij. But we have a while loop. We\u2019re going\nto have to continue with this while loop,and now what happens is, I\u2019m going to go\nfrom B1 clockwise again to B4. And when thishappens, did Yij increase or decrease? Well\nit decreased. So I'm going to go back to B1and Erik now is going to go counterclockwise\nto A3. And as you can see Y31 increased alittle bit, so we're going to now stop this\niteration of the algorithm and we're at A3B1, which we think at this point is our upper\ntangent, but let's check that. Start overagain on my side B1 to B4, what happened?\nWell Yij decreased. So I'm going to go backto B1. And then Erik\u2019s going to try. He\u2019s\ngoing conterclockwise, he's going to go A3to A2 and, well, big decrease in Yij. Now\nErik goes back to A3. At this point we'vetried both moves, my clockwise move and Erik\u2019s\ncounterclockwise move. My move from B1 toB4 and Erik\u2019s move from A3 to A2. So we've\nconverged, we're out of the while loop, A3B1 for this example is our upper tangent.\nAll right. You can have your finger back Erik.So the reason this works is because we have\na convex hull here and a convex hull here.We are starting with the points that are closest\nto each other in terms of A1 being the closestto this vertical line, B1 being the closest\nto this vertical line, and we are moving upwardin both directions because I went clockwise\nand Erik went counterclockwise. And that's", "start": 2280.0, "heat": 0.145}, {"text": "the intuition of why this algorithm works.\nWe're not going to do a formal proof of thisalgorithm, but the monotonicity property corresponding\nto the convexity of this subhull and the convexityof the subhull essentially can give you a\nformal proof of correctness of this algorithm,but as I said we won't cover that in 046.\nSo all that remains now is to look at ourpseudocode which matches the execution that\nyou just saw and talk about the complexityof the pseudocode.So what is the complexity of this algorithm?\nIt's order n, right? So what has happeninghere, if you look at this while loop, is that\nwhile I have two counters, I'm essentiallylooking at two operations per loop.And either one of those counters is guaranteed\nto increment through the loop. And so sinceI have in this case p points, in one case\np plus q equals n-- so let's say I had p pointshere and I have q points here. And got p plus\nq equals n.And I got a theta n merge simply because I'm\ngoing to be running through and incrementing--as long as I'm in the loop, I'm going to be\nincrementing either the i or the j. And themaximum they can go to are p and q before\nI bounce out of the loop or before they rotatearound.And so that's why this is theta n. And so\nyou put it all together in terms of what themerge corresponds to in terms of complexity\nand put that together with the overall divideand conquer. We have a case where this is\nlooking like a recurrence that you've seen", "start": 2400.0, "heat": 0.286}, {"text": "many a time t of n.I've broken it up into two sub problems. So\nI have 2. And I could certainly choose thisl over here that's my line l to be such that\nI have a good partition between the two setsof points.Now, if I choose l to be all the way on the\nright hand side, then I have this large subproblem-- makes no sense whatsoever. So what\nI can do-- there's nothing that's stoppingme when I've sorted these points by the x-coordinates\nto do the division such that there's exactlythe same number, assuming an even number of\npoints n, exactly the same number on the lefthand side or the right hand side. But I can\nget that right roughly certainly within onevery easily.So that's where the n over 2 comes from, OK?\nIn the next problem that we'll look at, themedian finding problem, we'll find that trying\nto get the sub problems to be of roughly equalsize is actually a little difficult, OK? But\nI want to point out that in this particularcase, it's easy to get sub problems that are\nhalf the size because you've done the sorting.And then you just choose the line, the vertical\nline such that you've got a bunch of pointsthat are on either side. And then in terms\nof the merge operation, we have 2t n over2 plus theta n. People recognize this recurrence?\nIt's the old merge sort recurrence.So we did all of this in-- well, it's not\nmerge sort. Clearly the algorithm is not mergesort. We got the same recurrence.And so this is theta n log n-- so a lot better\nthan theta nq. And there's no convex hullalgorithm that's in the general case better\nthan this. Even the gift wrapping algorithm", "start": 2520.0, "heat": 0.388}, {"text": "that I mentioned to you, with the right data\nstructures, it gets down to that in termsof theta n log n, but no better.OK, so good. That's pretty much what I had\nhere. Again, like I said, happy to answerquestions about the correctness of this loop\nalgorithm for merge later. Any other questionsassociated with this?STUDENT: Question.Yeah, back there.STUDENT: If the input is recorded by x coordinates, can you do better than [INAUDIBLE]?PROFESSOR: No, you can't, because-- I mean,\nthe n log n for the pre-sorting, I mean, there'sanother theta n log n for the sorting at the\ntop level. And we didn't actually use that,right? So the question was, can we do better\nif the input was pre sorted?And I actually did not even use the complexity\nof the sort. We just matched it in this case.So theta n log n-- and then you can imagine\nmaybe that you could do a theta n sort ifthese points were small enough and you rounded\nthem up and you could use a bucket sort ora counting sort and lower that.So this theta n log n is kind of fundamental\nto the divide and conquer algorithm. The onlyway you can improve that is by making a merge\nprocess that's even faster. And we obviouslytried to cook up a theta one merge process.\nBut that didn't work out, OK?STUDENT: But are there algorithms that [INAUDIBLE] ?PROFESSOR: First-- if you assume certain things\nabout the input, you're absolutely, right?So one thing you'll discover in algorithms\nin 6046 as well is that we're never satisfied.OK, so I just said, oh, you can't do better\nthan theta n log n.But that's in the general case. And I think\nI mentioned that. You're on the right track.If the input is pre sorted, you can take that\naway-- no, it doesn't help in that particular", "start": 2640.0, "heat": 0.208}, {"text": "instance if you have general settings. But\nif you-- the two dimensional case-- if thehull, all the segments have a certain characteristic--\nnot quite planar, but something that's a littlemore stringent than that-- you could imagine\nthat you can do improvements. I don't knowif any compelling special case input for convex\nhull from which you can do better than thetan log n.But that's a fine exercise for you, which\nis in what cases, given some structure onthe points, can I do better than theta n log\nn? So that's something that keeps coming upin the algorithm literature, if you can use\nthat, OK? Yeah, back there-- question.STUDENT: Where's your [INAUDIBLE] step?You also have to figure out which lines to remove from each of your two...PROFESSOR: Ah, good point. And you're exactly,\nabsolutely right. And I just realized thatI skipped that step, right?Thank you so much. So the question was, how\ndo I remove the lines? And it's actually fairlystraightforward.Let's keep this up here. And we don't need\nthis incomprehensible pseudo code, right?So let's erase that.And thank you for asking that question. So\nit's a little simple cut and paste approachwhere let's say that I find the upper tangent\nai bj. And I find the lower tangent.Let's call it ak bm. And in this particular\ninstance, what do I have? I have a1, a2, a3,a4 as being one of my sub hulls. And then\nI have b1, b2, b3, b4 as the other one.", "start": 2760.0, "heat": 0.263}, {"text": "Now, what did we determine to be the upper\ntangent? Was it a3 b1? Right, a3 b1?So a3 b1 was my upper tangent. And I guess\nit was a1-- a1 b4? A1 b4 was my lower tangent.So the big question is, now that I've found\nthese two, how do I generate the collect representationof the overall convex hull? And so it turns\nout that you have to do this-- and then thecomplexity of this is important as well. And\nyou need to do what's called a cut and pastethat's associated with this where we're going\nto just look at this and that.So if we're going to have these two things,\nthen we've got to generate a list of points.Now, clearly a4 is not going to be part of\nthat, right? A4 is not going to be part ofthe overall hull.What is it that we want? We want something\nlike a1, a2, a3, b1, b2, b3, b4, right? Butthere's a point that we have to discard here.\nAgree?And so the way we do this is very mechanical.\nThat's the good news here. I mean, you don'thave to look at it pictorially.I just made that up looking at-- eyeballing\nit. Clearly, a computer doesn't have eyeballs,right? And so what we're going to do is we're\ngoing to say the first link-- in general,the first link is ai to bj.Because that's my upper tangent, OK? And in\nthis case, it's going to be a3 d1, OK? Andthen I'm going to go down the b list until\nyou see bm, which is the lower tangent.", "start": 2880.0, "heat": 0.707}, {"text": "You're on the b list. So you're looking for\nthe lower tangent point. And then you're goingto jump until you see bm. You link it to ak,\nOK?You link it to ak and continue until you return\nto ai. And then you have your circularlist, OK? So what you see here is you have\na3 here. So I'm going to go ahead and writeout the execution of what I just wrote here.So I have a3. And I'm going to go jump over\nto b1. So I'm going to write down b1. ThenI'm going to along the b's until I get to\nb4.In this case, I'm going to include all of\nthe b's. So I got b1, b2, b3, b4. And thenI'm going to jump from b4 to a1 because that's\npart of my lower tangent.And I got a1 here, a2. And then I'm back to\na3, which is great. Because then I'm done,OK?And so exactly what I said happened, thank\ngoodness, which is we dropped a4 but we keptall the other points. Does that answer your\nquestion? Good.What is the complexity of cut and paste? It's\norder n. I'm just walking through these lists.So there's no hidden complexity here, OK?\nGood, good-- thank you. You definitely deservea Frisbee.In fact, you deserve two, right? Where are\nyou? I-- oh, could you stand up?Yeah, right-- two colors. All right. Oh, so\nhe-- well, you can give it to him if you like.", "start": 3000.0, "heat": 0.409}, {"text": "So good, thank you.So are we done? Are we done with convex hull?\nOK, good. So let's go on and do median finding.Very different-- very different set of issues\nhere.Still on divide and conquer, but a very different\nset of issues. The specification here is,of course, straightforward. You can think\nof it as I just want a better algorithm thansorting and looking for the median at the\nparticular position-- in over two position,for example. Let's say n is odd. And it's\nfloor of n over 2. You can find that median.Right, so it's pretty easy if you can do sorting.\nBut we're never satisfied with using a standardalgorithm. If we think that we can do better\nthan that. So the whole game here is goingto be I'm going to find the median.And I want to do it in better than theta n\nlog n time. OK, so that's what median findingis all about. You're going to use divide and\nconquer for this.And so in general, we're going to define,\ngiven a set of n numbers, define rank of xas the numbers in the set that are greater\nthan-- I'm sorry, less than or equal to x.", "start": 3120.0, "heat": 0.37}, {"text": "I mean, you could have defined it differently.\nWe're going to go with less than or equalto.So in general, the rank, of course, is something\nthat could be used very easily to find themedian. So if you want to find the element\nof rank n plus 1 divided by 2 floor, that'swhat we call the lower median. And n plus\n1 divided by 2 ceiling is the upper median.And they may be the same if n is odd.But that's what we want. So you can think\nof it as it's not median finding, but findingelements with a certain rank. And we want\nto do this in linear time, OK?So we're going to apply divide and conquer\nhere. And as always, the template can be instantiated.And the devil is in the details of either\ndivision or merge.And we had most of our fun with convex hull\non the merge operation. It turns out mostof the fun here with respect to median finding\nis in the divide, OK? So what I want is thedefinition of a select routine that takes\na set of numbers s.And this is the rank. So I want a rank i.\nAnd that i might be n over 2-- well, floorof n plus 1 over 2, whatever?And so what does the divide and conquer look\nlike? Well, the first thing you need to dois divide. And as of now, we're just going\nto say you're going to pick some element x", "start": 3240.0, "heat": 0.367}, {"text": "belonging to s.And this choice is going to be crucial. But\nat this point, I'm not ready to specify thischoice yet, OK? So we're going to have to\ndo this cleverly. And then what we're goingto do is we're going to compute on k, which\nis the rank of x, and generate two sub arrayssuch that I want to find the fifth highest\nelement. I want to find the median element.I want to find the 10th highest element. So\nI have to keep track of what happens in thesub problems. Because the sub problems are\ngoing to determine, depending on how manyelements are inside those sub problems, which\nI can only determine after I've solved thosesub problems. I'm going to have to collect\nthat information and put it together in themerge operation.So if I want to find the 10th highest element\nand I've broken it up relatively arbitrarily,it's quite possible that the 10th highest\nelement is going to be discovered in the leftone or the right one. And I have to show that\nit's the 10th highest. And it might be thatthere's four elements in the left and five\non the right that are-- let's see.If I defined the rank as less than or equal\nto x, there's four on the left and five onthe right that are smaller. And that's why\nthis is the 10th highest element. And that'sessentially what we have to look at. So b\nand c are going to correspond to the sub arraysthat you can clearly eliminate one of them.You can count the number of elements in b,\ncount the number of elements in c. And youcan eliminate one of them in this recursion\nas you're discovering this element with the", "start": 3360.0, "heat": 0.616}, {"text": "correct rank-- in this case, i. So let me\nwrite the rest of this out and make sure we'reall on the same page.What I have here pictorially is I've generated\nb here and c. So this is all of b and that'sall of c. I have k minus 1 elements here in\nb.And let's say I have n minus k elements in\nc. And I'm going to do-- essentially take--once I've selected a particular element, I'm\ngoing to look at all of the elements thatare less than it and put it into the array\nb. I'm going to look at all the elements thatare better than it.Let's assume all elements are unique. I'm\ngoing to put all of them into c. And I'm goingto recur on b and c. Those two are my sub\nproblems.But what I have to do is once I recur and\nI discover the ranks of the sub problems,I have to put them together. So what I have\nhere is if k equals i-- so I computed therank and I realized that if k equals-- equals\ni, I should say-- if k equals i, then I'mgoing to just return x. I'm done at this point.I got lucky. I picked an element x and it\nmagically ended up having the correct rank,OK? Not always going to happen. And so in\nother case, if k is greater than i, then goingto return select bi.", "start": 3480.0, "heat": 0.485}, {"text": "So what I've done here is if k is greater\nthan i, then I'm going to say, oh, so nowI'm going to have to find the element in b.\nI know that it's going to be in b becausek is greater than i. And I've got to find\nthe exact position depending on what i isover here. But it's going to be somewhere\nbetween 1 and k minus 1.And then the last case is if k is less than\ni, then this is a little more tricky. I'mgoing to turn on c of i minus k, OK? So what\nhappens here is that my k is-- the rank forthe x that I looked at over here is less than\ni.So I know that I'm going to find this element\nthat I'm looking for in c. But if I just lookat c, I don't want to look at c and look for\nan element of rank i within c, right? Thatdoesn't make sense because I'm looking for\nan element of rank i in the overall arraythat was given to me.So I have to subtract out the k elements that\ncorrespond to x and all of the k minus 1 elementsthat are in b to go figure out exactly what\nposition or rank I'm looking for in the subarray corresponding to c, OK? So, people buy\nthat. So that's just a small, little thingthat you have to keep in mind as you do this.So that's pretty straightforward, looking\npretty good. And you say, well, am I donehere? And as you can imagine, the answer is\nno, because we haven't specified this value.Now, can someone tell me, at least from an\nefficiency standpoint, what might happen,what we're looking for here? As you can imagine,\nwe want to improve on theta n log n. And so", "start": 3600.0, "heat": 0.391}, {"text": "you could you say, well, I'm happy with theta\nn. That theta n complexity algorithm is betterthan a theta n log n complexity algorithm,\nwhich is kind of in the bag.Because we know how to sort and we know how\nto index. So we want a theta n algorithm.Now, if you take this and if I just picked,\nlet's say, the biggest element-- I kept pickingx to be n or n minus 1 or just picked a constant\nvalue. I picked x to be in the middle.I picked the index. I can always pick an element\nbased on its index. I can always go for themiddle one.So what is the worst case complexity of this\nalgorithm? If I don't specify or I give youthis arbitrary selection corresponding to\nx belonging to s, what is the worst case complexityof this algorithm? Yeah, go ahead.STUDENT: N squared.PROFESSOR: N squared-- why is that?STUDENT: Because if you [INAUDIBLE] take like the least element.PROFESSOR: Yep.STUDENT: How do you compare like N o against the other analysis?PROFESSOR: Exactly right. That's exactly right.\nSo what happens is that you're doing a bunchof work here with this theta n work.Right here, this is theta n work, OK? So given\nthat you're doing theta n work here, you haveto be really careful as to how you pick the\nx element. So what might happen is that youend up picking the x over here.And given the particular rank you're looking\nfor, you have to now-- you're left with alarge array that has n minus 1 elements in\nthe worst case. You started with n. You didnot go to n over 2 and n over 2, which is\nwhat divide and conquer is all about-- evenn over b, OK?You went to n minus 1. And then you go to\nn minus 2. And you go to n minus 3 becauseyou're constantly picking-- this is worst\ncase analysis. You're constantly picking thesesub arrays to be extremely unbalanced.So when the sub arrays are extremely unbalanced,\nyou end up doing theta n work in each", "start": 3720.0, "heat": 0.343}, {"text": "level of the recursion. And those theta n's,\nbecause you're going down all the way fromn to one, are going to be theta n square when\nyou keep doing that, OK? So thanks for thatanalysis.And so this is theta n squared if you have\na batch selection. So we won't talk aboutrandomized algorithms, but the problem with\nrandomized algorithms is that the analysiswill be given a probability distribution.\nAnd it'll be expected time.What we want here is a deterministic algorithm\nthat is guaranteed to run in worst case thetan. So we want a deterministic way of picking\nx belonging to s such that all of this worksout and when we get our recurrence and we\nsolve it, somehow magically we're gettingfully balanced partitions-- firmly balanced\nsub problems in the sense that it's not nminus 1 and 1. It's something like-- it could\neven be n over 10 and 9n over 10.But as long as you guarantee that, you're\nshaking things down geometrically. And theasymptotics is going to work out. but the\ndeterminism is what we need.And so we're going to pick x cleverly. And\nwe don't want the rank x to be extreme.So this is not the only way you could do it,\nbut this is really very clever.There's a deterministic way. And you're going\nto see some arbitrary constants here. Andwe'll talk about them once I've described\nit. But what we're going to do is we're going", "start": 3840.0, "heat": 0.273}, {"text": "to arrange s into columns of size 5, right?We're going to take this single array. And\nwe're going to make it a two dimensional arraywhere the number of rows is five and the number\nof columns that you have is n over 5-- theceiling in this case. And then we're going\nto sort it each column, big elements on top.And we're going to do this in linear time.And you might say, how did that happen? Well,\nthere's only five elements. So it's linear.You could do whatever you wanted. You could\ndo n raised to four.But it's five raised to four and it's constants.\nDon't you love theory? So then we're goingto find what we're going to call the median\nof medians.So I'm going to explain this. This works for\narbitrary rank, but it's a little easier tofocus in on the median to just explain the\nparticular example. Because as you can see,there's an intricacy here associated with\nthe break up.And so here we go. I'm going to draw out a\npicture. And we're going to try and arguethat this deterministic strategy that I'll\nspecify gives you fairly balanced partitionsin all cases, OK?So what we see here is we see-- pictorially,\nyou see columns of length five. Each of thesedots corresponds to a number. This one dimensional\narray got turned into a two dimensional right.", "start": 3960.0, "heat": 0.522}, {"text": "So I got four full columns. And it's suddenly\npossible, given n, that my fifth column isnot full, right? So that's certainly possible.\nSo that's why I have that up here. It so whatI've here is I'm going to lay them out this\nway.And I'm going to look at that. I'm going to\nlook at the middle elements of each of thesen over five columns. That's exactly what I'm\ngoing to look at. Now, if I look at what Iwant, what I want over here is this x. If\nI want to find--I'm going to find the median of medians. So\nis x. Now, it is true the first thatthese columns-- I'm just putting that up here\nimagining that that's x.That's not guaranteed to be x because the\ncolumns themselves aren't-- well, these columnsare sorted. And what I'm going to have to\nguarantee, of course, is that when I go findthis median of medians is that it ends up\nbeing something that gives me balanced partitions.So maybe say a little bit more before I explain\nwhat's going on.Each of these columns is sorted. And s is\narranged into columns of size 5 like I justsaid here. These are the medians, OK? If I\nlook at determining the medians and I saythat once I've determined this x, which I've\ndiscovered that it's the median, then thisis right there in the middle. There's going\nto be a bunch of columns to the left of it,", "start": 4080.0, "heat": 0.293}, {"text": "a bunch of elements to the left of it, and\na bunch of elements to the right of it.And in this case, I have five columns. I could\nhave had more. It happens to be the thirdone.So the idea is that once I find this median\nof medians, which corresponds to this x number,I can say that all of the columns-- these\nall correspond to columns that have theirmedian element greater than x. These correspond\nto columns that have their median elementless than x, OK? So what I have here in this\npicture is that these elements here are goingto be greater than x.And these elements here are going to be less\nthan x. So let me clear. What's happened hereis we've not only sorted all of the columns\nsuch that you have large elements up here.Each of these five columns have been sorted\nthat way. On top of that, I've discoveredthe particular column that corresponds to\nthe medians of medians. And this is my x overhere.And it may be the case that these columns\naren't sorted. This one may be larger thanthat or vice versa-- same thing over there.\nI have no idea.But it's guaranteed that once I find this\nmedian that I do know all of the columns thathave elements in this position that are less\nthan this x. And I know columns that in thisposition have elements that are greater than\nx, OK? Yep.STUDENT: Shouldn't the two elements below x also be computed [INAUDIBLE] less than x.PROFESSOR: You're exactly right. I would have\nprobably been able to get the same asymptotic", "start": 4200.0, "heat": 0.278}, {"text": "complexity if I dropped those because I had\na constant number. But you're absolutely exactlyright.So the point that-- the question was-- I just\nredrew it. These two are clearly less thanx as well because they're part of the sorting.\nAnd that's essentially I have here.Now, my goal here-- and you can kind of see\nfrom here as to where we're headed. What I'vedown here by this process of sorting each\ncolumn and finding the median of medians isthat I found this median of medians such that\nthere's a bunch of columns on the left. Androughly half of those elements in those columns\nare less than x.And there are a bunch of columns on the right.\nAnd roughly half of those columns have elementsthat are greater than x. So what I now have\nto do is to do a little bit of math to showyou exactly what the recurrence is. And let\nme do that over here.So that's the last thing that we have to do.\nI probably won't solve the recurrence, butthat can wait until tomorrow. The recurrence\nwill be something that's not particularlydifficult to solve. So I want to now make\na more quantitative argument that the variablebeing n as to how many elements are guaranteed\nto be greater than x.And essentially what I'm saying, which is\nI'm writing out what I have on that picturethere, half of the n over 5 groups contribute\nat least three elements greater than x except", "start": 4320.0, "heat": 0.201}, {"text": "for one group with possibly less than five\nelements, which is the one that I have allthe way to the right, and one group that contains\nx.\nSo for all the other columns, I'm going toget three elements that are greater than x.\nAnd so if you write that out, this says thereare at least three n over 10, because I have\nhalf of all of those groups, minus 2.And I'm not counting perfectly accurately\nhere, but I have an at least. So this shouldall be fine. 3n over 1d-- 3 times n over 10\nminus 2 elements are strictly greater thanx. And that comes from that picture.I'm going to be able to say the same thing\nfor less than x as well. I can't count theone. Depending on how things go, maybe I could\nhave played around and subtracted 1 insteadof a 2 in the latter case.But I'm just being conservative here. It is\nclear that I'm going to have a bunch of columnsthat are full columns, that are going to be\ncontributing three elements that are greaterthan x. And in this case, I have, well, two\nof them here for the less than x.And I got one for the greater than x. So that's\nall that I'm seeing over here with respectto the balance of the partitions. And it turns\nout that's enough.It turns out all I have to do with this observation\nis to go off and run the recurrence. And we'regoing to get an efficient algorithm. Yep.", "start": 4440.0, "heat": 0.334}, {"text": "STUDENT: Should it not be like greater than or equal to, because there's... [INAUDIBLE]PROFESSOR: No, there's nothing that's equal.STUDENT: So you are saying, that's all you need.PROFESSOR: Yeah. Yeah, I assume that-- so,\nconvenience, yeah. There's always a littlebit of convenience thrown in here.We will assume that the a has unique elements.\nSo there's nothing that's x, OK? Good.So the recurrence, once you do that, is t\nof n equals-- we're going to just say it'sorder one for n less than or equal to 140.\nWhere did that come from? Well, like 140.It's just a large number. It came from the\nfact that you're going to see 10 minus 3,which is 7. And then you want to multiply\nthat by 2.So some reasonably large number-- we're going\nto go off and we're going to assume that'sa constant. So you could sort those 140 numbers\nand find the median or whatever rank. It'sall constant time once you get down to the\nbase case.So you just want it to be large enough such\nthat you could break it up and you have somethinginteresting going on with respect to the number\nof columns. So don't worry much about thatnumber. The key thing here is the recurrence,\nall right?And this is what we have spent the rest of\nour time on. And I'll just write this outand explain where these numbers came from.\nSo that's our recurrence for n less than orequal to 140.And else, you're going to do this. So what\nis going on here? What are all of these componentscorresponding to this recurrence?Really quickly, this is simply something that\nsays I'm finding the median of medians. I'm", "start": 4560.0, "heat": 0.35}, {"text": "finding some element that has a certain rank.\nSo this median of medians is going to be runningon n over 5 columns. So I've got this-- there\nare n over 5 columns here.And I'm going to be calling this algorithm\nrecursively, the median finding algorithm,to do that-- finding the median of medians.\nThis thing over here is-- I'm going to bediscarding at least regardless of what I do.\nBecause I have these two statements here,I take the overall n. And I'm going to discard.In my paradigm over here, I'm either going\nto go with b or I'm either going to go withc depending on what I'm looking for. And given\nthat b and c are not completely unbalanced,I'm going to be discarding 3n over 10 minus\n6 elements, which simply corresponds to meignoring the ceiling here and multiplying\nthe 3 out. So that's 3n over 10 minus 6.So then I have 7n over 10 plus 6. That's the\nmaximum size partition that I'm going to recuron. It's only going to be exactly one of them,\nas you can see from that.It's either else. It's not recurring on both\nof them. It's recurring on one of them. Sothat's where the 7n over 10 plus 6 comes from.\nAnd then you ask where does this theta n comefrom.Well, the theta n comes from the fact that\nI do have to do some sorting. It's constanttime sorting for every column, OK? Because\nit's only five elements.So I'm going to do constant time sorting.\nBut there's order n columns. Because it's--then it's n over 5 columns.So this is the sorting of all of the columns,\nall right? So that's it. And I'll just leave", "start": 4680.0, "heat": 0.1}, {"text": "you with-- you cannot apply the master theorem\nfor solving this particular recurrence. Butif you make the observation-- and you'll see\nthis in section.You make the observation that n over 5 plus\n7n over 10 is actually less than n. So youget 0.2n here and 0.7n there. That's actually\nless than n.This thing runs in linear time. And you'll\nsee that in section tomorrow. So this wholething is theta n time. See you next time.", "start": 4800.0, "heat": 0.131}]