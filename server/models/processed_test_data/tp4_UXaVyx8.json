[{"text": "The following\ncontent is providedunder a Creative\nCommons license.Your support will help MIT\nOpenCourseWare continueto offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Today's\nour last lectureon dynamic programming,\nthe grand finale.And we have a bunch of fun\nexamples today on piano,guitar, Tetris and\nSuper Mario Brothers.What could be better?We are, again, going to\nfollow this five-step planto dynamic programming, define\nsub-problems, guess somethingin order to solve a sub-problem,\nwrite a recurrence thatuses that guessing to relate\ndifferent sub-problems,then build your dynamic\nprogramming eitherby just implementing as\na recursive algorithmand memorizing or\nbuilding it bottom up.For the first, you need to check\nwith the recurrence is acyclic.For the second, you need an\nactual topological order.These are, of course,\nequivalent constraints.Personally, I like to write\ndown on topological orderbecause that proves to\nme that it is acyclic,if I think about it.But either way is fine.Then we get that the\ntotal running timeis number of sub-problems\ntimes time per sub-problems,and then we need to solve\nour original problem.Usually it's just one\nof the sub-problems,but sometimes we have to\nlook at a few of them.So that's what\nwe're going to do.And we have one\nnew concept todaythat all these examples\nwill illustrate,which is a kind of\nsecond kind of guessing.We've talked about\nguessing in part twohere in which we saw\nthe obvious thing.In the recurrence, we\nusually take the minof a bunch of options or the\nmax of a bunch of options.And those options correspond\nto a guessed feature.We don't know whether\nthe go left or go right,so we try them both.That's guessing.But there's another\nway to guess.", "start": 0.0, "heat": 0.1}, {"text": "So two kinds of guessing.So you can do it in step two.Let's see what I have\nto say about these.In step two and three,\nyou are guessing usuallywhich sub-problems\nto use in orderto solve your\nbigger sub-problem.So that's what we've seen\nmany, many times by now.Every DP that we've covered\nexcept for Fibonacci numbershas used this kind of guessing.And it's sort of the most\ncommon, I guess you might say.But there's a higher\nlevel of guessingthat you can use, which\nwe've sort of seenin the knapsack dynamic\nprogramming, dynamic program,which is when you define your\nsub-problems, you can add more.Add more sub-problems to\nguess or you can think of itas remembering more\nfeatures of the solution.And we just leave it at that.Essentially what this does--\nso remember with knapsack,we had a sequence of items.They had values and sizes.And we had some target\nknapsack, some capacity.We wanted to pack those\nitems into that knapsack.And the obvious sub-problems\nwere suffixes of the items.", "start": 120.0, "heat": 0.301}, {"text": "Because we always know\nsuffixes, prefixes, substrings,those are the obvious\nthings to try.But suffixes wasn't\nquite enough.Because if we\nlooked at a suffix,we didn't know of\nthe prefix that we'veskipped over how\nmany of those itemswere in-- and in particular,\nhow much of the capacitywe'd used up.And so we needed to\nadd more sub-problemsto remember how much capacity\nhad we used up in the prefix.We did that by multiplying\nevery sub-problemby s different choices, which is\nhow many units of the knapsackstill remain.So in some sense,\nwe're remembering moreabout the prefix.You can also think of it as--\nin the more forward direction,we have the suffix problem.I'm going to solve\nit s different times,or s plus 1 different times.I'm going to solve it.What if I had a big knapsack?What if I had a\nsmaller knapsack?What if I had a\nzero-size knapsack?All of those different\nversions of the problem.In some sense, you were\nsolving more sub-problems.You're, in some, sense\nfinding more solutionsto that sub-problem.You're looking at a suffix.And I want to know all these\ndifferent solutions thatuse different amounts\nof the knapsack.So in that sense, you're just\nadding more sub-problems.But from a guessing\nperspective, you'reremembering more about the past.We're going to see a bunch of\nexamples of this type today.We'll always use\nthis type, but we'llsee more of this where the\nobvious sub-problems don't workand we need to add more.So the first example is\npiano and guitar fingering.This is a practical problem for\nany musicians in the audience.How many people here play\npiano, or have played piano?OK, about a quarter.How many people\nhave played guitar?A few, all right.I brought my guitar.I've been learning\nthis semester.I'm not very good yet,\nbut we'll fool aroundwith it a little bit.So the general idea is you're\ngiven some musical piece", "start": 240.0, "heat": 0.15}, {"text": "that you want to play.And on a piano, there's\na bunch of keys.You have all these\nkeyboards, so youknow what a piano looks\nlike, more or less.It's just like a\nkeyboard, but only row.It's crazy.Each key that you\npress makes a note,and every key has\na different note.So it's very simple from\na computer scientist'sperspective.You want to play a\nnote, you push the key.But you could push it with\nany one of these fingers.Humans have 10 fingers.Most humans.I guess a few have more.But you want to know,\nwhich finger should Iuse to play each note?It may not seem like a big deal.And if you're only playing\none note, it's not a big deal.But if you're going to play\na long sequence of notes,some transitions are\neasier than others.So let's say we're given\na sequence of n noteswe want to play.And we want to find a\nfingering for each note.So fingering, so let's\nsay there are-- I'mgoing to label the fingers\non your hand, 1 up to f.For humans, f is\n5 or 10, dependingon if you're doing one\nhand or two hand stuff.I think to keep it simple, let's\nthink about piano, right handonly, and just you're playing\none note at the time, OK?We're going to make it\nmore complicated later.But let's just think of a\nnote as being a single note.OK, or you can think of\nguitar, single note, left handis playing things.You want to assign one of\nthese fingers to each node.And then you have a\ndifficulty measure, d.", "start": 360.0, "heat": 0.186}, {"text": "And this you need to\nthink about for awhilemusically, or anatomically,\nhow to define.If we have some note p\nand we're on finger fand we want to transition\nto note q using figure g,how hard is that?So this is-- the p and\nq are notes to play.I guess p stands for pitch.And f and g are fingers.So this is how hard is it\nto transition from f on pto g on q.There's a huge\nliterature on for piano.There are a lot of\nrules like, well,if p is much smaller than\nq, unless they're stretched,then that becomes hard.And if you want to\nstretch, you probablyneed to use fingers that are\nfar away from each other.If your playing legato-- so you\nhave to smoothly go from onenote the other-- you can't use\nthe same finger on both keys.So if f equals g and\nyou're playing legato,then p better be the\nsame as q sort of thing.There's a weak finger rule.You tend to avoid fingers\nfour and five, these two.Apparently going from-- I'm\nnot much of a pianist-- sogoing from between\nthree and four,which I can barely hold them\nup, it's kind of difficult,is \"annoying.\"That's what I wrote down.So between three and four\ntransitions you try and avoid.And so you can encode\ninto this function.It's a giant table.You can just put\nin whatever valuesyou want that you're\nmost comfortable with.And music theorists\nwork a lot on tryingto define these function so.So you can do that.And for guitar, maybe I\nshould do a little example.Get this out.", "start": 480.0, "heat": 0.207}, {"text": "I can't play much,\nso bear with me.Bet you didn't think\nthis would happen in 006.[LAUGHTER]So let's see.So let's say you're trying\nto play your favorite song.[STRUMS \"SUPER MARIO BROTHERS\"\n THEME][LAUGHTER]OK.So when I'm playing that, I have\nto think about the fingering.Which finger is going to\ngo where to play each note?OK, so the first notes\nare actually open,so it's really easy.And then I go up to holding the\nfirst fret on the fifth string.OK, and I'm using my index\nfinger because everyoneloves to use their index finger.And in particular because\nthe very next noteI'm going to play-- well,\nactually it's down here.Then the next note is\ngoing to be this one.So I'm holding on the third\nfret of the bottom string.And then I've got to\ntransition over here.And actually, usually I do\nit with my middle finger.I don't know quite why I\nfind that easier, but I do.OK, and so I've actually\nplayed that opening a zilliontimes with lots of\ndifferent things.This is the one I found to\nbe the most comfortable.And there's this issue, right?If your pinky is here, where\ncan I reach with this finger?Where can I reach\nwith this finger?It gets difficult.And in particular,\nit's very hard for meto reach down here\nwhen my pink is there.And so you can encode\nthat in this d functionhowever you want.You get the idea.[APPLAUSE]Thanks.I'll skip to our lessons.\n[? We're ?] [? worth ?][? it. ?] So let's solve this\nwith dynamic programming, OK?That's the cool thing.So we can do it.And we follow our\nfive step procedure.So the first thing is\nto define sub-problems.What are the sub-problems\nfor a set-up like this?", "start": 600.0, "heat": 0.224}, {"text": "What are the three\nobvious candidates?Do you remember last lecture?How many people know the answer?Just checking.One person.Go for it.AUDIENCE: Prefixes,\nsuffixes, and substrings.PROFESSOR: Right.Prefixes, suffixes,\nand substrings.We have a sequence of notes.We're not going to worry\nabout the sequence of fingers.I don't think that's\ntoo big a deal.That's what we're finding.What we're given is\na sequence of notes,so we should try suffixes,\nprefixes, or substrings.I'll just tell you,\nsuffixes are fine.Kind of.So a sub-problem\nwill be suffixes,so how to play notes\nfrom i onwards.Intuitively, we\nwant to figure out,how should we play\nthe first note?And then we go on to the\nsecond note and so on.So we're applying\nthem one by onefrom left to right\nfrom the prefix side.And so we'll always\nbe left with a suffix.OK, then we need\nto guess something.What's the obvious\nthing to guess,given I need to\nplay notes i onward?Think little harder.This one you shouldn't\nhave to think.That's what I tell you.Try suffixes, try\nprefixes, try substrings.Yeah?AUDIENCE: Maybe which\nfinger to just put around i?PROFESSOR: Yeah, which we're\ngoing to use for note i.", "start": 720.0, "heat": 0.262}, {"text": "Our whole point is\nto assign fingering.The first note here is i.So let's think about i,\nwhat could you do for i?We'll try all the possibilities.Which finger to use for note i?OK, now the really hard part--\nbecause it's impossible--is to write a recurrence.This is wrong, by the way, but\nit's the first thing to try.So this is what\nI want to ask youto do because it's not possible.But intuitively, what\nwe might try to dois we're trying\nto solve DP for i.And we want to find--\nthis is difficulty,so you want to\nminimize difficulty.So we'll take a min\nover all of our guessesof what it would take to\nsolve the rest of the notes,to play the rest of the\nnotes, plus somehow the costof playing the first note.So what's the cost of\nplaying the first note?And then is going to be\na for loop over fingers.OK, that's going to be the min.We want to try all possible\nfingers for note i.Then we have to play\nall the remaining notes.And then there's\nthis transition costwhere you're going from\nnote i to i plus 1.So it's going to\nbe something like dof if-- we know that we use\nfinger f to play i-- thenwe have to go to note i plus 1.But then the problem is we have\nno idea what to write here,because we don't know\nwhat finger we'regoing to guess\nfor note i plus 1.So this cannot be known.OK, but it's the\nfirst thing you shouldtry, because often this works.For simple DPs, that's\nenough for sub-problems.But we need to know\nmore informationabout what we're\ngoing to do next.And this seems very\nworrisome, maybenow we have to guess two things.Do we have to guess\nmore than two things?Turns out two things is enough.But we cannot use\nthis type of guessing.", "start": 840.0, "heat": 0.304}, {"text": "We need to use-- we need\nto add more sub-problems.More sub-problem, more power.So any guesses what we\ncould do for sub-problem?A couple of right answers here.Yeah?AUDIENCE: Maybe like all\nthe suffixes [INAUDIBLE]like the i, for all written i's,\nlike all the possible fingersfor i?PROFESSOR: All the\npossible fingersfor i in the sub-problem.Yeah, good.How to play-- it's still\nabout the suffixes.We're still going to use that.But we're going to\nsuppose we alreadyknow what finger to use\nfor the first note, note i.OK, this is a little weird,\nbecause we were guessing thatbefore.Now we're just\nsupposing someone tellsus, use finger f for that note.This will work.That's the one I had in mind.But the question becomes,\nwhat should we guess?Anyone else?You clearly get\n[? a pillow. ?] Idon't know how many\nyou have by now.Have another one.That's tough.This is not easy to figure out.Now, given that that's\nour sub-problem, whatis the next thing to guess?Do you have an idea?AUDIENCE: I got an\nidea to define it.Like either the next or\nprevious finger for the--PROFESSOR: The next\nor previous finger.Well, I'm looking at suffixes.So I only care\nabout the next one.Yeah.I see what you mean\nby next or previous.", "start": 960.0, "heat": 0.374}, {"text": "But what we mean\nis note i plus 1,that's the next thing\nwe don't know about.So we're going to\nguess finger-- we'llcall it g-- for note i plus 1.And now magically,\nthis recurrencebecomes easy to write.So it's almost the same thing.I wish I could just copy and\npaste this over, but I can't.It's not a digital blackboard.Are there digital blackboards?That would be cool.Someone should make that.I don't know why switched from\nopen parens to square brackets,but I did.Then we have-- I think it's just\nthe obvious thing, if i plus 1g.Ahh, this is a\nslightly wrong, though.It's a copy paste error.This should really\nbe DP of i commaf, because now sub-problem\nconsists of two things-- whichsuffix am I in, and what's\nmy finger for note I?And so when I call DP, I also\nhave to provide two arguments.It's going to be DP\nof i plus 1 comma g.And then I'm looping over g.I'm trying all\npossibilities for g.That's the recurrence.So if I want starting\nwith finger f on note i,how do I solve\nthe suffix from i?Well, I guess what\nfinger am I goingto use for the very next note.Then I have to pay this\ntransition cost for f on ito g on i plus 1.Yeah, OK.So slightly, I'm cheating\nthe notation here.This probably should be\nthe note, what is note i,and this thing should be\nwhat is note i plus 1.", "start": 1080.0, "heat": 0.253}, {"text": "If you think of this d\nfunction just being givennotes, pitches that\nyou need to play,instead of indices\ninto the array.It doesn't really matter, but\nthat's how I defined it before.OK, so I have to pay\nthis transition cost.What does it take to make that\ntransition from i to i plus 1?And then what does it take to\ndo the rest of the notes, giventhat now my finger is-- or now\nfinger g is playing the notei plus 1?So we transition from\nf to g, and that's nowkept track of in\nthe sub-problem.This is the magic of\ndefining more sub-problem.We needed to know where\nour finger used to be.And now we're telling it,\noh, your finger right nowis finger f.Finger f is the one that's\ncurrently playing the note.And then afterwards, g is\nthe finger that's currentlyplaying the note, and we\ncan keep track of that.You could also define\nthis to say, oh,f was the finger that was\nused for the previous note,note i minus 1.But it's just a shifting\nof the indices here.You can do i minus 1 to i\ninstead of i to i plus 1.But this is, I think,\nslightly cleaner.OK, and then we\nhave a DP, right?We've just memoized\nthat recurrence.We get a recursive DP, or\nyou could build it bottom up.If you were building\nit bottom up,you'd want to know\na topological order.And this requires a\nlittle bit of carebecause there's two parameters.And so it's going\nto be a for loopover those two\nparameters in some order.And I believe the\nright order is for ihas to go from right to left\nbecause this is suffixes.So I would write reversed range\nn python if there are n notes.And then within that loop, I\nwould do a for loop over f.If you reverse the order\nof these for loops,it would not be in the right\norder, I'm pretty sure.But this one will work.You can check it.And then to solve our\noriginal problem, here", "start": 1200.0, "heat": 0.144}, {"text": "we require a little\nmore work because noneof these sub-problems\nare what wewant to solve because we don't\nknow what the first finger is.We know what the first note is.That's note 0.But what finger goes there?I don't know.And DP of 0 requires\nus to give it a finger.Give it the finger, ha.Give it the finger for\nwhatever is the first note.So this is pretty easy though.We just take a min\nover those choices.Which finger should we give it?That should do it.So we don't know what\nfinger to start with.Just try them all, take the min.This is just like the\nguessing that we did here,just a slightly simpler version.There's no transition cost\nbecause there's no transition.We weren't anywhere before.Just what finger\ndo you start with?I don't care what\nfinger I start with.It's how I transition from one\nnote to the next that's hard.OK, done.That's the DP.Now, if this is not\nobvious or not clear,I think it's easier to think\nabout it in the DAG form.So let's draw all\nthe sub problems.We have here a two dimensional\nmatrix of sub-problems.We have the different\nsuffixes on the one hand.So this is it, it stats\na 9, goes to n minus 1.And then in the\nother dimension, wehave what finger\nto use from 1 to f.And so in each of these\npositions, there a note.There's a sub-problem.Race.", "start": 1320.0, "heat": 0.107}, {"text": "I wanted to get five rows\nbecause there are five fingers.And then our\ntransitions basicallylook-- if we're at\nfinger one on this note,we can go to finger\none on the next note.Or we can go, if\nwe're not legato,or we can go to finger\ntwo on the next note,or finger three or finger\nfour or finger five.And then if we're\nstarting with finger two,we could go to any one of these.So you get a complete\nbipartite graph,which you usually\ndraw like this.That is how graph theorists\ndraw complete bipartite graphs.OK, but I tried to draw a\nlittle more explicitly here.It's just any\npossible transition.And for each of\nthese, the point isyou can compute the\nD cost, because youknow what figure you were at.You know what finger\nyou are going toand what note\nyou're starting fromand what note you're going to.Those are the four\narguments you need for D.So you put those\nweights on, and thenyou solve shortest\npaths on this DAG.And that is exactly what\nthis DP is doing, OK?Except there's no\nsingle source here,which is kind of annoying.And so you need to take\nthis min over what'sthe shortest path from\nhere, what's the shortestpath from here, from here,\nfrom here, from here.Of course, you\ndon't actually needto do that by running single\nsource shortest paths f times.If you're a clever\nshortest paths person,you would add an extra\nsource note, connectthat with 0 weight to\nall of these sources.So put 0s on there.And then do single\nshortest paths from here.And you will find the best way.You don't really care\nwhere you started,so this is trying\nall the options.That's exactly what\nwe're doing here.But here I'm doing it with\nthe shortest paths trick,here I'm doing it with guessing\nand taking a min like DP style.OK, so that's how to do\npiano figuring and guitar", "start": 1440.0, "heat": 0.162}, {"text": "fingering for single\nhand, one note at time.Questions?And this even worse\nfor aliens if youhave arbitrarily many\nfingers on your hand.I guess we should figure\nout what's the running time.So we have sub-problems.We see how many\nsub-problems there are here.There's n times f sub-problems.How much time, or how\nmany choices are therefor our guess?Well there's f different\nchoices for what finger we use.And when we do this min,\nwe spend theta F time.Because there's a\nfor loop over F,we're doing constant\nwork assumingD lookups take constant time.This is theta F time.So we multiply those\ntwo things together,and we get the total time, the\nnumber of sub-problems whichis n times F, and\nwe multiply themby theta F for each sub-problem.So this is nF squared.And given F is usually pretty\nsmall, it's almost linear time.So that's a pretty\ngood algorithm.But in reality, you tend\nto play multiple notesat the same time.In music, typically\nyou're playing a chord.With piano, you're\nplaying several noteswith one hand, maybe several\nnotes with another hand.Two handed piano, it's crazy.You could do four handed piano,\nmake it a little more exciting.With the guitar, play-- I\ndon't know very many chords,but I know at least one.You play, I don't know.This looks like something.That's a G chord.Do I know any others?And that's an E chord.All right, you get the idea.", "start": 1560.0, "heat": 0.1}, {"text": "I mean, for each\nof these chords,different people use\ndifferent fingers,even for a single cord.So it's sort of a\npersonal taste howyou're going to define\nyour difficulty measure.But I could play an E like\nthis, or I could-- I don't know,play it like this.Or I could play like this.And there's lots of crazy\nways to put your finger hereand your finger here\nand your finger here.And for each of them, you\ncould define some difficulty.And then, of course,\nis a transitionfrom one chord to another.And because there's different\nways to play different chords,that wasn't a very good\nexample because they alllook pretty bad.Well, this one for example,\nthis is the G again.I could use my-- one, two,\nthree, four-- fourth fingerhere, or I could\nuse my fifth finger.My instructor says we should\nuse our pinky because peopletend not to use their pinky.But it makes a\ndifference what I'mgoing to transition to next.Maybe my pinky really\nneeds to go over here nextand I should free\nit up for later,or maybe it's better if this\none's freed because then Ican move it somewhere else.So that's what we'd\nlike to capturein a generalized form\nor this dynamic program,and we can do it.So I'll try to do\nit quickly so wecan get on to the\nother examples.All right, other fun stuff.Actually, there's\nanother fun thingwith guitar, which\nis that there'smore than one way\nto play each note.There are six strings here.And you could play like this\nnote for the Super MarioBrothers.I could also play that\ndoing the fifth thing here.It's slightly out of tune, but\nthose sound almost the same.Or I could play on the 10th\nfret on the third string.That's the same as bottom one.So a lot of options, so you\nalso like to capture that.This is actually not too hard.You just need to generalize\nthe notion of finger", "start": 1680.0, "heat": 0.1}, {"text": "to what finger you're using\nand what string you're using.So there are f different choices\nfor what finger you're using.If you use a generalized\nguitar, there'ss choices for what\nstring you're playing.There's a lot of different\nguitars with various numbersof strings, so we can\njust generalize that.And now it's not only, which\nfinger am I going to use,but what sting\nwill I play it on?And then you can still\ndefine a difficulty measurelike this for this\nset up, dependingboth on the finger\nand the string.And then the running\ntime grows slightly.It's now n times F\nsquared S squared,because now I have to take\nthe product of F and S. OK,so that's first thing.But then if I wanted\nto do multiple notes,well, you can imagine it's\na similar type of deal.It's going to get harder though.First thing we need to\ngeneralize is the input.Before the input was\na sequence of notes.Now it's going to be a\nsequence of multi-notes.So notes of i is now\ngoing to be, let's say,a list of notes that all\nneed to be played at once.And conveniently, it's probably\ngoing to be, at most, F notes,because you really can only\nplay one note with each fingerpretty much.I guess you could try to\nplay two notes at onceon a piano with\na finger, but eh.It sounds difficult.For a guitar, it's\nat most s notes.You can only play one note\nper string, more or less.So that's our input.And now we need to adjust\nthe dynamic program.And I think I'll tell\nyou how to do this.", "start": 1800.0, "heat": 0.146}, {"text": "Basically, now you need to know\nwhere all your fingers are.So you go from one\npose to another pose,from one chord to another.Different ways to finger that.Which fingers are\nand which stringsand which frets on the\nguitar, which fingersare on which keys\non the keyboard.But you just need\nto know all that.And all your fingers\nmight be doing something,and you've got to know for\neach finger what note is it on,or is it not being used at all.So how many different ways to\ndo such a mapping are there?I mean, this is just a function.So it's the number of\ntargets of the function.So how many of these are there.Gosh, well, I guess we said\nthere are, at most, f notes.So f plus 1 is the maximum\nnumber of possible thingseach finger can do.And we raise that to the power\nof the number of fingers.That's the possible mappings\nof what all of my fingerscould be doing.It's exponential\nin f, not so great.But if f is 5, it's all right.And then-- well, then you\njust generalize the rest.I don't think I'll\nwrite it down in detail.But our sub-problems\nnow are goingto be-- let me\nswitch boards here.How do we play these\nmulti-notes from i onwards,given that we're going to\nuse that pose-- or I calledit the state of all my fingers--\nfor the first notes of iis now a whole bunch of notes.So given I'm now going\nto play those noteswith this particular\nfinger assignment,", "start": 1920.0, "heat": 0.468}, {"text": "how do I play the rest?And then what we'll guess is\nthe entire finger assignmentfor the next set of\nnotes, i plus 1--the next chord, if you will.And that guessing involves\nnow F plus 1 to the F time.And then we just write the\nrecurrence in the same way.So we're basically generalizing\nhere we call the finger,now it's an entire\npose for your hand.Instead of F, you might write\nH for hand or something.And so the running\ntime in this situationis going to go up to something\nlike n times F of plus1 to the F. Did I miss anything?Probably have to square that.2F.Before it was F\nsquared, now it'sjust F plus 1 to the F squared.So if F is small,\nthis is all right.Otherwise, not so great.This is the best algorithm\nI know for chord fingering.Questions?Just trying to\nmake it practical,solve the real life problem.I would love, I\nthink-- I don't knowif this has been\nimplemented, but someoneshould implement this\nin some-- I don't know,score program,\nmusical score program.I would love as\nlearning guitar, it'dbe great for someone to just\ntell me how to finger things.Then I can\nretroactively figure outwhy using the dynamic program.All right, let's\nmove on to Tetris.All these problems are going\nto have the same flavor.You can solve them\nwith basicallythe same dynamic program.It's all about figuring out\nwhat should the sub-problems be.So let me-- does anyone\nhere not know Tetris?OK, good.No one's willing to admit it.So you've got these\nblocks falling.But I'm going to make several\nartificial constraints.First of all, I tell\nyou the entire sequenceof pieces that\nare going to come.This is more like\na Tetris puzzle.", "start": 2040.0, "heat": 0.328}, {"text": "OK, we're given sequence\nof n pieces that will fall.For each of them, we must\ndrop the piece from the top.OK, and if you're a\nfancy Tetris player,you can let a piece fall and\nthen rotate it at very endto do some clever, clever thing.I disallow that.You always have to\npush the drop button.So the piece starts here, it\ngoes instantly to the ground.This will be necessary.I don't know how to\nsolve the problemwithout this constraint.OK, and then the\nother weird thing--this is very weird for Tetris--\nfull rows normally clear,but now they don't clear.This is like hardcore Tetris.You're guaranteed\nto die eventually.The question is, can you\nsurvive these n pieces?That's the question.Can you survive?Oh, I've got one\nother constraint.This is actually\nkind of natural.The width of the board is\nsmall, relatively small,because we're going to\nbe exponential in w.In real life it's 12, I think?AUDIENCE: Ten.PROFESSOR: Ten, sorry.It's been a while since\nI wrote my Tetris paper.So all right, these are all\nkind of weird constraints.If you don't make all of\nthese constraints-- oh,also the board is\ninitially empty.That's like level one of Tetris.If all of these things\nare not the case, whichis regular Tetris, if you\njust have the first thingthen this problem is\ncalled NP-complete.We'll be defining\nthat next class.So it's computationally\nintractable.But if you make all\nof these assumptions,the problem becomes\neasy, and youcan do it by\ndynamic programming.So how do we do it?We define sub-problems\njust like before.", "start": 2160.0, "heat": 0.151}, {"text": "The obvious thing\nto try is suffixes.How do we play a suffix\nof pieces i onwards?How to play those guys.And just like fingering, this is\nnot enough information, right?Because if we're going to play\nfrom pieces i onward, whatwe need to now is what the\nboard currently looks like.I said here the board\nis initially empty.That's not going to\nbe the case after youplace the very first piece.So in general, after we've\nplaced the first i pieces,we need to know what\nthe board looks like.And here's where I'm going to\nuse all of these assumptions.If you always drop things from\nthe top and rows don't clear,then all you really care about\nis how high each column is.This is what you might call\nthe skyline of the board.OK, now in reality,\nthere might be holes herebecause you drop\nthings in silly ways.Maybe you drop a\npiece like this.And then I claim, because\nI'm dropping thingsfrom infinity from\nthe sky, I reallydon't care about that\nthere's a whole here.I can just fill that in and\nsay, OK, that's my new skyline.Because if you can't do\nthese last minute twistsand if lines never clear,\nthat's going to be gone.That material is wasted.OK, so all I need to remember\nis how high is each column.So I should say given\nthe board skyline.Now, how many choices\nare there for that?It's quite similar to this\nfunction, the fingering.Let's see.There's the height of the\nboard, different choices.It's going to be h.For each column it could be\nanywhere between 0 and h,so I guess h plus 1 if\nyou want to get technical.And then we raise\nit to the power w,because there's w different\ncolumns and each of them", "start": 2280.0, "heat": 0.199}, {"text": "is independent choice.So this is going to n times\nthat different sub-problems.And here's what I\nneed the is smallbecause this is\nexponential in w.So it's reasonable in\nh, but exponential in w.OK, then what do I guess?Any suggestions what to guess?AUDIENCE: So where the new\npiece falls, as in [INAUDIBLE]?PROFESSOR: Yeah.What should I do with piece i?There's not that many choices.I can rotate it zero,\none, two, or three times.I can choose\nsomeplace to drop it,but those are my only choices.So it's just how\nto play piece i.And given that guess,\nyou can figure outhow the skyline updates,\nlike I did here.If I drop that piece like\nthat, then I fill in this partand recompute my new skyline.So it's going to\nbe something like 4times w different choices,\nroughly-- 4 for the rotation,w for the x-coordinate.And so the running\ntime is just goingto be the product of these.n times w times h\nplus 1 to the w.Open problem, if I drop any\none of these assumptions,can you get a dynamic\nprogram that's reasonable?Could you do it if w is large?I don't know.Could you do if rows do clear?", "start": 2400.0, "heat": 0.668}, {"text": "That's the least\nnatural constraint here.I don't know.Puzzle for you to think about.I'd love to know the answer.You can obviously do the\nrest of the steps, right?You can write down\nthe recurrence.It's the same thing.You take the min\nover all guesses.What are we minimizing?Hmm.I guess here the\nquestion is survival.Can you survive?So this is one of the first\nexamples where the answer isa Boolean value, true or false.But if you think of true\nor false as 0 and 1,then it's still a\nmaximization problem.You want to maximize.You want 1 if possible.Otherwise, you'll get\n0 when you maximize.So you can write the\nrecurrence using max.And in the base case, you have\ntruth values, true or false.And you'll see, did I survive?Did I die?That sort of thing.I want to go on to\nSuper Mario Brothers,because everyone loves\nSuper Mario Brothers.has?Anyone not played NES\nSuper Mario Brothers 1?Aww, you got to play it, man.You're the only one.You can play it on an emulator.Maybe not legally, but you\ncan play it on an emulatorand just see how it is.So what I'm going\nto talk about next,in theory, works for many\ndifferent platform games,side-scrolling platform games.But Super Mario Brothers\n1 has some nice features.In particular, a nice feature\nis that whenever anythingmoves off of the screen, it\ndisappears from the world.So the monster moves\noff, it's gone.You can think of there's\na static level there.When the level comes into\nscreen, when a monster comeson screen, then\nit starts acting.But as soon as you move the\nscreen-- you can't actually", "start": 2520.0, "heat": 0.245}, {"text": "move backwards in Super\nMario 1, but as soonas you move forwards and\nthat character is offscreen,it's gone.So in a sense, that\npart of the levelreset to its initial state.Now, as long as your screen is\nnot too big-- and thankfully,on NES screens\nwere not very big.It's 320p, or whatever.This will work.If you are given\nthe entire level--so let's say there's n\nbits of information there--and you have a small screen,\nw by h screen, w and hare not too big.Then I claim we can\nsolve Super MarioBrothers by dynamic programming.So let's say we want\nto maximize our score.Want to run through the level\nand maximize your score,or you want to minimize\nthe amount of time you use.You're doing level runs.Pick your favorite measure,\nall of those can be solved.And the way to do it, this\nsort of general approachto all these DPs is\nwe need to write downwhat do I need to know\nabout the game state.I'll call that a configuration.What can we care about\nfor Super Mario Brothers?Well, I guess\neverything on screen.This is a bit tricky, but\nthere's stuff on screen.There are monsters and objects.For the monsters, I need to\nknow their current position.For the objects, I\nneed to know-- like,is there a question mark box?Did I hit it already?Did I already get the coin or\ndid I already get the mushroom?So for each of those\nthings, there'ssome amount of information\nyou need to store.How much information?I think something like constant\nto the w times h should do.That's saying for every\npixel on the screenor for every square\non the screen,however you-- whatever you\ndefine the resolution hereto be.Let's say for every little\nunit square in Mario land,is it a brick?Is it a hard brick, or has\nit been a destroyed brick?", "start": 2640.0, "heat": 0.1}, {"text": "Is a monster there right now?Is Mario there right now?All these kinds of information.OK, so there's a cost number\nof choices for each pixel.You can write them all down.You might also want\nMario's velocity.I had to play it\nagain just to checkthat there is indeed velocity.Turning around is slower\nthan going forward.You do accelerate a little bit.So you've got to remember that.There's probably only\na constant numberof choices for what\nyour velocity is.What else?Ah, I want to\nremember the score.You want to maximize score.And let's say you also--\nhow much time is left.There's a time counter.If it hits zero, you die.Now, these are kind of annoying,\nbecause they're integers.They could be kind of large.So I'm going to say the\nscore could be capital S big,and time could be capital T big.So this'll be a\npseudopolynomial algorithm.The number of\nconfigurations in totalhere is the product\nof these things.It's exponential in w and h.And then multiply by\nS and T. So that'sthe number of configurations.And that's also going\nto be our sub-problem.I guess we should\nalso write downwhere is the screen\nrelative to the level.OK, how far to the\nright have you gone?That's another w.That's not a big deal.OK, given this information,\nyou know everythingyou need to know about\nplaying from here on.And the time counter's\nalways going to keep ticking.So you can draw a graph\nof all configurations,just enumerate all\nof these things.It's this many of them.And then draw, for\nevery configuration,what are the possible\nthings I can do?I could push this button.I can push the A button, I\ncan release the A button.I can push the B button, I\ncan release the B button.I can push the up arrow.Those are all the\nthings you could do.It's a constant\nnumber of choices.So each vertex will have\nconstant out degree.", "start": 2760.0, "heat": 0.252}, {"text": "If you did this, what\nconfiguration would I reach?Just draw that whole graph.Do shortest paths.Or dynamic programming,\nthese are your sub-problems.There are no suffixes here.These are your sub-problem.And then you take\na max, if you'retrying to maximize score or max\nif you're trying to maximizetime, minimize the time you use.This is time remaining.And you can relate\neach sub-problemto a constant number\nof other sub-problems.So your running\ntime will be this,because you only pay constant\ntime per sub-problem.And now you can solve Super\nMario Brothers optimally,as long as your screen is\nnot too big and as longas your scores and times\ndon't get too big either,because we're only\npseudopolynomial with respectto S and T.Questions?All right.That's-- yeah?AUDIENCE: So are we\ngoing to be tryingto memoize all of these\npossible configurations?PROFESSOR: If you do\nthe recursive version,you will end up memoizing all\nof these configuration values.Well, anyone that's reachable\nfrom the initial state.Some configurations\nmight not be reachable,but the ones that\nare reachable you'regoing to start doing them.When you finish doing them,\nyou will memoize the result.", "start": 2880.0, "heat": 0.301}]