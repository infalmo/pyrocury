[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: So this\nis a 2-3 tree.So as you can see, every node\nhas-- so the 2-3 is eithertwo children or three children.Every node can have either\none key or two keys.And the correlation\nis that every--so if there are n keys in a\nnode, it has n plus 1 children.So the way that works is\nsimilar to binary search trees.So if you have value here, the\ntwo children surrounding it--so this side is less,\nthis side is more.So it's essentially sort of\ngoing in order reversal, leftchild, root, right child.So [INAUDIBLE], it's ordered.So generally a B tree\nwill have some nodes.So let's say n and\nn plus 1 children.And if you take\nanything in the middle,look at the two children,\nall the keys in this sub-treeare smaller than the key\nhere, and all the keysin this sub-tree are\nlarger than the key here.So that's the general node.So before we go\ninto more detailsof the properties\nand everything,the question is why use B-trees.So if we do a quick\ndepth analysis,we can see that the\ndepth is to log n rate.Is that clear to everyone sort\nof, why the depth is log n?Because you have branching just\nlike in binary search trees.In fact, you have\nmore branching.But in any case,\ndepth is to log n.But why use B-trees over\nbinary search trees?", "start": 0.0, "heat": 0.1}, {"text": "Anyone have a\nreason why you wouldprefer to use B-trees or not?So all the operations\nare still log n.Any guesses?None.OK.Well, OK, the reason\nis memory hierarchy.So normally in\n[INAUDIBLE], we justassume that the computer\nhas access to memory,and you can just pick up things\nfrom disk and constant timeand do your operations with\nit, and you don't worryabout caches and everything.But that's not how\ncomputers work.So in a computer, you\nhave-- so those of youwho have taken some\ncomputer architectureclass [INAUDIBLE] or something,\nyou will know that hierarchy.So there's a CPU-- so\nlet's draw it somewhere.So you have your CPU.And [INAUDIBLE] CPU,\nyou have some registers.You have your caches,\nL1, L2, L3, whatever.You have your RAM.You have disk after that.So disk [? loads. ?] Then\nyou have your, I don't know,your cloud, whatever.So each level, your\nmemory size growsand your access\ntime grows as well.So in the basic memory\nhierarchy model,we have just two levels\nof hierarchy, let's say.So you have cache connected\nby a high bandwidth channelto the CPU, and you have a\nlow bandwidth channel to disk.So the difference\nis-- so essentiallyyou can consider that cache\njust has infinite speed.Cache, just like,\nwhatever you can take it.You don't have any cost for\nbringing in stuff from cache.But it's finite size.So the way cache works is it\nhas a bunch of words, whichis a finite number of words.So each word has size B, and\nlet's say you have m words.However, hard disk is just,\nlet's say, infinite memory,but it has some cost\nassociated to accessing things.Also when you access\nthings from hard disk,you copy them into cache.When you copy a block of\nsize b, you take it up", "start": 120.0, "heat": 0.81}, {"text": "from the hard disk,\nand you take a block,and you put it into cache.And you have to get rid of\nsomething because it's fine.So what you want to do\nis you want to utilizethat b block efficiently.You just want to bring\na b block every timeyou want to access a new node.In a binary search tree,\nnormal operations are what?You start in the root\nand go to a node.But that's not very easily\ncorrelated with this.Right?So if you want to\nutilize an entire block,you would want something like\na block which sort of goes downthe tree.But that's not how\nbinary trees are stored.Binary trees are\nstored this way.So that's the nice\nthing about B-trees.So this is just a 2-3 tree.This is not a general B-tree.A general B-tree will\nhave a bunch of nodes,and we'll come to that number.But generally you want to make\nthat number of nodes somethinglike the cache-- what is it?The word size in the cache.So once you do that, you can\nget an entire node from disk,like work on that, and then\nget another [INAUDIBLE],so your height is reduced.And you can do your\noperation much quicker,because you're not accessing\ndisk every time you'regoing down a level.Sorry.You are accessing disk every\ntime you go down a level,but you're utilizing\nthe whole blockwhen you're accessing disk.Good?Sort of make sense?OK.So let's write down the\nspecifications for B-trees now.All right.So number of children.So first of all, a\nB-tree has somethingcalled a branching factor.So in the 2-3 tree, the\nbranching factor is two.So what that means is\nsimply that it just balances", "start": 240.0, "heat": 0.482}, {"text": "the number of children.So the number of children has to\nbe greater than or equal to 2.Other than the root node.The root node can have\nless than B children.It's fine.Also it's upper bounded\nby 2B [? plus ?] 2B.Notice that this is\na strict upper bound.So you can have at most 2B\nminus 1 children from a node.Also remember that the number\nof keys, the number of keysis just 1 less than\nthe number of children.Therefore, these inequalities\nare just reduced by 1.So you have minus 1 and\nyou have 2B minus 1.So the number of keys can be\nbetween minus 1 and 2B minus 2.The rationale for that\nwill become clear-- yeah?AUDIENCE: Is B the\nheight of the tree?PROFESSOR: No, B\nis the branching.B is the branching factor.So that is the\nnumber of children.It's not the number of children.It's a bound of the\nnumber of children.So like in the 2-3\ntree, B is equal to 2,and this is a 2-3 tree.So the 2 refers to-- you\ncan have either two childrenor you can have three children.And so the upper bound on\nchildren is 2B minus 1.2B minus 1 is equal to 3.So you can have two\nor three children.And correspondingly, you\ncan have either one or twokeys in a node.Make sense?AUDIENCE: Yeah.PROFESSOR: Cool.OK So coming back to this.So the root does not\nhave a lower bound.The root can have one\nchild in any tree.So you have a B equal\nto 5 tree, the rootcan still have\none child-- sorry.Not one child, one key\nelement, two children.All right.It's good.Also it's completely balanced.", "start": 360.0, "heat": 0.174}, {"text": "So all the leaves\nare the same depth.So you can see it here, right?So you can't have a\ndangling node here.This is not allowed.You have to have a leaf.You have to have\nsomething going down,and everything ends\nat the same level.All right.So that's the thing.So also the leaves obviously\ndon't have children,so this condition is\nviolated by the leaf.So that's the basic\nstructure of a B-tree.So the first operation\nwe'll consider on B-treesis searching.So that should be\nrelatively straightforward.So remember how searching is\ndone in the binary search tree.You bring in a value\nx compared to the key.Let's say x is less than\nK, you go down this path.Let's say x is greater than\nK, you go down this path.So similarly in a B-tree.So let's say we\nbring in a value.Let's say you are\nlooking for 20.So you bring in 20\ncompared to this.20 is less than 30,\nso you go down here.Now you have two values.So where does 20 fit in here?Not here.Not here.It fits here.OK.Go down this tree.You find 20, that's it.So in general, you bring in a\nkey K, you look at this node,and you go through\nall the values.So something I forgot to\nmention, which should be clear.All the keys in a node, they're\nsorted, one after the other.So your values go like this.So they're increasing\nin this way.Make sense?So you bring in a key.Look at all the keys in\nthe node you're looking at,pick the place where K fits\nin, unless it's already", "start": 480.0, "heat": 0.19}, {"text": "in the node.Then you're done.You've found it.Otherwise, let's say K fits\nin between these two guys.So you go down this\nchild and continue.So searching with log\nn, similar to BSTs.So searching is not\nvery interesting.So next is insertion.So insertion is a little more\ninteresting than searching.So what you do in\ninsertion is you--[SIDE CONVERSATION]PROFESSOR: So before we resume,\ndoes anyone have any questionsabout the structure of B-trees.We rushed through\nthat quite fast.About how B-trees\nare structured,everyone good with that?OK, also any questions about\nsearching in a B-tree or a BST?Go ahead.AUDIENCE: Just a\nrandom question.So the 38 there, it can\nonly have two children.PROFESSOR: Yep.So one value, two children.So you have some\nnode in the B-tree,and whatever is\nbelow it is splitinto parts by the elements.So if you have n\nelements, it splits it upinto n plus 1 segments.AUDIENCE: You said that the root\ndidn't have to follow the root.PROFESSOR: No.AUDIENCE: Why is that?PROFESSOR: Well, you'll see when\nwe do insertion and deletionwhy that's necessary.But essentially you can\nconsider that it's an invariant.", "start": 600.0, "heat": 0.1}, {"text": "And all we have to do is\npreserve that invariant.So the root, it has to\nstill have less than two--it still has to have\nthe upper bound.But it doesn't need\nto have a lower bound.AUDIENCE: How do you choose B?PROFESSOR: Well, the whole\n[INAUDIBLE] cache size,so something with that.So you probably want 2B to\nbe about your cache sizeso you can get the\nwhole block in one go.I've never implemented\na B-tree, so Idon't know how it's\nactually done in practice.But that is the reason, so\nI'm assuming it's somethingto do with the cache length.AUDIENCE: Is the 14, is it\na child of both 10 and 17?PROFESSOR: Well, it's\nnot a child of either.It's a child of this node.So this node has two\nelements, so it'sbeing divided-- dividing the\ninterval up into three parts.So it's in between 10\nand 17 is the point here.AUDIENCE: So then this\nnode has five children?PROFESSOR: Sorry?No, it has three children.So don't think of\nevery key as a node.Think of the whole\nunit as a node.So it's not necessarily--\nin a binary search tree,you have one element,\nbut here every nodehas multiple elements.That's the point of it.Anyone else?OK, let's start with searching.So let's leave this here.Well, you have the formulas\nup there, so that's good.Insertion.Let's start with insertion.We already did searching.So insertion is you\nbring in a new key K,and you want to insert\nit into the tree.So what's the problem\nthat could happen?You can find the location where\nyou want to insert it, justlike searching.", "start": 720.0, "heat": 0.1}, {"text": "You just go down the tree and\nfind where it should be placed.But once you do place\nit, you have a problem.What is the problem?The problem is that one of your\nnodes will become overfull.Whatever.It'll overflow, and\nthat's not what you want.So you want some way\nso you can manage this.How do you manage this?So I have this lovely prop here,\nwhich I hope to demonstrate.OK.So here we have B equal to 4.So let's first figure\nout the number of keys.So what is the minimum number of\nkeys, anyone for B equal to 4?AUDIENCE: Three.PROFESSOR: Three, precisely.So what is the maximum\nnumber of keys?AUDIENCE: Six.PROFESSOR: 4 into\n2 minus 3, yeah.Correct.3, 4.It's not seven, there's\na strictly less than signsomewhere.Yes.And you'll see why it's\nnot seven in a minute.[LAUGHTER]Oh.Hypocritical of me.All right.So as you can see,\n1, 2, 3, 4, 5, 6, 7.So some insertion happened.Is the writing clear?Can everyone read the numbers?49 looks a little skewed.Anyway, essentially\nthese are all sorted.This is the parent node.Doesn't matter what's over here.All that matters is 8, 56,\nand whatever's in between.So what we do when we\nhave an overfull nodeis something that's\ncalled a split operation.So split.And there's something\nwhich is calleda merge, which we'll\ncome to later whenwe're doing deletion.But a split is--\nvery intuitively,it splits the node\ninto two parts.So what it does is when\nyou have an overfull node--so the number of\nelements here is what?2B minus 1, which is\njust 1 over the max.", "start": 840.0, "heat": 0.1}, {"text": "So what do you do is you\ntake the middle elementand remove it.and now you split the\nnode into two parts.Observe that there are\nthree here and three here,which is perfect.And now what you do\nwith the middle node--so now you're\nactually disruptingthe structure of the\ntree, because therewas one pointer going in.There was one child.And now you have two children.So somehow you need to\nadjust the parent node,because the parent node\nhad only one child.Well, at least there are other\nchildren off to the side.But here it had only one child,\nand now it's split apart.So you do something very simple.You just insert\nthis guy in here.And then you say,\noh, this points here,and this points here.Make sense?I'm going to get\nrid of these two.And you can even\nconvince yourselfthat this preserves all\nthe nice properties.So your children have\nnicely fallen backinto their interval.Your sequence is\ncompletely correct,because this was the\nmiddle element of this.So this divides this\ninterval properly.This is also between 8 and 56,\nbecause this was in this node.So all the properties.But there's one property\nthat is a problem.So you have just increased the\nsize of the parent node by 1.So now it's possible that the\nparent node has overflowed.So what do you do?You split it again.And split it again.And if at any\npoint, you're fine,you look at the parent node\nand go, OK, that's fine.That's in the range.But every time it overflows,\nyou can keep going.And how many times\ncan you do this?You can do this all\nthe way up to the root.And when you reach the\nroot, either it's fineor the root is too big.It's reached 2B minus 1.And then you split\nthe root, and youget one single\n[INAUDIBLE] up there.So that, in answer\nto your question,", "start": 960.0, "heat": 0.1}, {"text": "that is why you need that\nproperty in some sense.Not a very convincing\nargument, but sort of.So let's actually\ndo an insertionin this tree we have here.So we are going to insert 16.So 16 comes in here.It's less than 30,\nit goes to the left.It's between 10 and 17,\nit goes in the middle.16.And it's greater than\n14, so we add 16 here.All right.That seems good.All the properties fine.This still has two elements,\nwhich is the maximum,but it's good.It doesn't overflow.Let's insert something else.Let's insert 2.So 2 goes to 30,\ngoes down, goes down.And we have a problem, because\n2 has overflowed this node.So we split.And the way we split is we\ntake the middle element.So we split the node here.And 3 goes up to the\nparent, so 3 goes here.And all good, except for\nthe parent has overflowed.So what do we do\nwith the parent?We split the parent again.And this time, it's right down\nthe middle, the 10 goes up.So OK, let's get rid of this.So now that we split the\nparent, the 10 goes up here.And you're good.It's a bit cluttered, so\nlet me reposition the 17.", "start": 1080.0, "heat": 0.1}, {"text": "Did those two\noperations make sense?Questions?AUDIENCE: If your node size\n[INAUDIBLE] number of--PROFESSOR: So just pick\nthe-- first of all-- OK.If the way we're doing it--\nwhen your node is overflowing,it's returning only one\nthing at a time, right?AUDIENCE: Yeah.PROFESSOR: So if your\nnode is overflowing,it'll be 2t minus 1, which\nis an odd number always.There might be a case where\nyou get an even numberif you do something weird.Maybe you have a-- there are\ndifferent ways to do B-trees.But if it does, you can probably\npick the one, either of them,and then [INAUDIBLE].I'm not sure about that.I'll look into it.But in general, if you're doing\nit this way, it's always odd.So you don't have\nto worry about that.Anything else?AUDIENCE: If we did reach\nall the way to the rootand then went one more up--PROFESSOR: So what\nyou would do is--AUDIENCE: That root would have--PROFESSOR: That root would\nhave two children, one elementand two children, which is\nfine because we didn't putthat restriction on the root.That's good.How we doing on time?OK, we have some time.Let's jump into deletion, unless\nanyone else has questions.AUDIENCE: [INAUDIBLE] any point?PROFESSOR: So-- oh, yeah.That's a good-- thank you.So you are going\ndown to the leavesat most-- at most\nof the leaf ones,and you're going back up one.So it's like log n plus\nlog n, and you're good.Let's do deletion.So deletion is more complicated.So the reason, it'll be clear.So the problem in deletion\nwill be remove a nodeand a node is now underfull.So it has less than B minus\n1 keys in it suddenly.So let's turn this around.", "start": 1200.0, "heat": 0.1}, {"text": "So again B equal to 4.This node is a problem.Only two things in it.So what do we do?So before we go into that,\nlet's make this assumptionthat-- there are two\nsteps to deletion.The first step is making\nthe deletion at a leaf.How do you do that?So the way you make a deletion\nat a leaf is, let's say,you have a key.You come down in your\nB-tree, and you add a node.Oh, this key needs\nto be deleted.But it's not a leaf.So what do you do?So essentially what you do is\nyou look at these two subtrees.So it might have\nonly one subtree.If it's at the end,\nit will have only one.Actually, no, that's not true.Ignore that.If it's not a leaf,\nit has two subtrees.So either take the\nrightmost elementin this subtree,\nwhich is a leaf,because you can always\nkeep going down,right, right, right, right\ntill you get to a leaf,or the leftmost element\nin this subtree.So that is just the next\nelement after this guy.So you delete this, and\nyou bring this up to here.We'll do an example of\nthis, and it'll be clearer.So you take either the rightmost\nelement in the left subtreeor the leftmost element\nin the right subtreeand bring it up here.So you sort of like move\nthe deletion to the leaf.And now it's easier\nto deal with.So we will come to that.Also just note that this is not\nwhat is done in the recitation.This algorithm for\ndeletion, I think,is not done in the\nrecitation notes.This is a different thing, which\nI'll send out a link for later.But I believe it\nworks, because I got itfrom the [INAUDIBLE] reference.So once you move to the leaf--\nso now let's look at this.So this is a node\nthat is underfull.And you want to fix it.So how do you fix it?So what do is you\nlook at its siblings.So in this case,\nit has one sibling.", "start": 1320.0, "heat": 0.1}, {"text": "It can have up to two siblings.It can have left or right.So what you do is you\nlook at a sibling.And this sibling is\nactually 1 over the minimum.And if it's 1 over the\nminimum, then it's really easy.All you have to do is take\nthe leftmost thing here--or if it's the\nsibling on this side,take the rightmost thing here.And look at its parent.So you bring the parent down,\nand you move the sibling up.And there we go.So you basically are rotating\nthe thing into place.So you move the parent down\ninto the underfull node,and you replace the parent\nby the leftmost thing here.Everyone see why that\npreserves everything?And the child is also shifted.Make sure you see that.So the child which was in this\nsubtree is now in this subtree.But then you can\nhave the situationwhere you don't\nhave a nice siblingto take care of your problems.So in this scenario, the\nsibling is barely full.It has three things, and it\ncan't donate anything to you.So what do you do in that case?So then you do something which\nis a parallel of the splitoperation.You do a merge.So what do you have?So here you have B minus 2,\nand here you have B minus 1.And you get 2B minus 3.Well, you've got\nanother element.You also take the parent.So how do you do the merge.I just want to show\nyou the merge first.So the way you do it is\nyou move the parent down,and you merge these two.Seems OK?So you move the parent node\ndown and merge these two.And, well, now this\ncomes together,and this points\ninto the new node.Sort of clear what's going on?", "start": 1440.0, "heat": 0.125}, {"text": "Questions?Yes?AUDIENCE: So now the\nparent is underfull?PROFESSOR: Well, so you\nhave-- yeah, exactly.So you have decreased\nthe size of the parent,so it might be underfull.So you propagate.Anything else?AUDIENCE: So are these\nall different techniquesfor doing that?PROFESSOR: So there\nare two cases.So either you have a sibling\nwhich has extra nodes to donateto you or you don't.If you don't, then\nyou have to do this.AUDIENCE: But what\nabout that case?Or is that just like--PROFESSOR: No, that is\nmoving it down to the leaf.Once you move the\ndeletion down to the leaf,so here we have something now.And now you move it\nall the way back up.So there are two cases.Let's do an example.That'll make it clearer.How are we doing on time?Five minutes, all right.So we are going to delete 38.38 is gone.But we want to move\nit down to the leaf.So let's take an element.Let's say we take 41.So we take 41 and\nmove it up here.41 is the leftmost thing\nin the right subtree.So this vacancy doesn't\nreally affect anything,because this node still has\nthe right number of things,because it's still got one\nthing in it, which is good.So you're fine.This is now just 48.Let's say we now delete 41.So 41 is gone.So now that 41 is\ngone, what do youreplace this blank spot with?Either this or this, right?Doesn't matter.So let's just do this\none for consistency.So you have 48 here.And now you a problem\nbecause you have a blank box.So can you rotate?", "start": 1560.0, "heat": 0.216}, {"text": "Yes, no?No, right?Because sibling is barely full.So what can you do?So you merge.And how do you merge?You move the 48 down, and\nyou combine everything.So this is kind of\nhard to understand,but this is like a\nzero-element node.So when you merge, you\nhave 32, 48, and nothing,so it's just 32 and 48.So what you do is--\nso this seems weird,but this is just\nanother empty node.You just propagated\nthe emptiness upwards.Now you take this empty node,\nand you look for its siblings.Again, its sibling is--\nwell, it's barely full.So what do you do now?You bring the 30 down,\nand you merge this.So let's do that.30 comes down, and there we go.Looks fine?Does that tree look good?Questions about the operation?I'm sure it was not\nclear, but-- anything?Make sense?OK, let's do a deletion where\nwe can actually do a rotation.So let's go ahead and delete 20.So you do your searching,\ngo down the tree.You find the 20 under here.So now, OK.So you're left with just--\nactually never mind.We'll do another one.So this doesn't do anything.You lost the 20, and you're\nleft with the 24 this time.So now you delete the 24.So now that you've\ngot rid of the 24,you have a blank box here now.But its sibling is\nnot barely full.", "start": 1680.0, "heat": 0.291}, {"text": "It has something to donate.So anyone, which elements\nare going to rotate?AUDIENCE: 17 and 16.PROFESSOR: 16 and 17, right.Cool.So 16 goes up, 17 goes down.And you're done.You're consistent again.So that was deletion.Those are the two\ncases for deletion.Does that make sense?Anyone?Any questions?OK.So that's all the topics we\nwere supposed to cover today.Any questions about\nany of the operations,any of the other topics,\nlecture, anything?", "start": 1800.0, "heat": 0.327}]