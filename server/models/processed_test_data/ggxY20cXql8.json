[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help MIT\nOpenCourseWare continue tooffer high quality educational\nresources for free.To make a donation or view\nadditional materials fromhundreds of MIT courses, visit\nMIT OpenCourseWare atocw.mit.edu.PROFESSOR: I apologize to\nthose of you watching onOpenCourseWare.I forgot to turn on\nmy microphone.And you missed some incredibly\nbrilliant things.But such is life.Let me go back to where I was,\nwhich was we we're looking atthis code to find the cube\nroot of a perfect cube.We saw this last week, and\nindeed, you also saw it inrecitation.I'm not going to belabor it.I do want to ask you the\nquestion, for what values willthis program terminate?That is to say the only\ninput is to x.For what values of\nx is this programguaranteed to always stop?Anybody want to volunteer\nan answer to that?Ask a simpler question.Let's assume that\nx is a number.In fact, let's assume\nit's an integer.Will it terminate for all\npositive integers, allpositive values of x?Yeah.All negative values?As far as I can tell.How about 0?Yeah.So in fact, it terminates\nfor all values of x.How do I know that?And that's a key question.I know that because I've used,\nand I mean by used as a mentaltool, something in my head,\nthe notion of a", "start": 0.0, "heat": 0.132}, {"text": "decrementing function.And every time I write a loop,\nI think about one of these,because that explains to\nme why the loop isguaranteed to terminate.We'll go over here where we have\na bigger board and lookat the properties that\na decrementingfunction needs to have.One, it will map some\nset of programvariables to an integer.Two, when the loop is entered\nfor the first time or when Iencountered the test of the loop\nfor the first time, itsvalue is non-negative.Three, when its value gets to\nbe less than or equal to 0,the loop terminates.And finally four, it's\ndecreased eachtime through the loop.", "start": 120.0, "heat": 0.314}, {"text": "So what we see is if it starts\nto be a positive value ornon-negative, and it's decreased\nevery time I executethe body of a loop, that\neventually, it's got to reach0 or something less than 0.And when it does,\nthe loop stops.If such a function exists, then\nthe loop is guaranteed toalways terminate.Now, of course, one can count up\nto a value instead of down.But there's always a trick we\ncan use of subtracting to makeit the same.So what's the decrementing\nfunction for this loop?How did I know it will\nalways terminate?Yeah?AUDIENCE: [INAUDIBLE].PROFESSOR: Answer equals\nanswer plus 1.I don't think so.Does that satisfy all\nof these properties?Remember, a function is going\nto map some set of programvariables to an integer.So what are the interesting\nprogram variables here?Well, there are only\ntwo, ans and x.Right?At least, that's\nall I can see.So what would be an interesting\nfunction?Somebody?Surely, there's someone who\ncan figure this out.Yes?Or no, you're just scratching\nyour head.You fooled me.", "start": 240.0, "heat": 0.415}, {"text": "I can't see because of the\nlight, but I'm sure there mustbe dozens of hands up if\nI could only see them.Actually, I don't see\nany hands up.This is not so hard, guys.It's the absolute value of\nx minus answer cubed.So what does this\nvalue start at?Let's pick a value.Suppose that x is equal to 8.What is the initial value of\nthe decrementing function?Wow.Come on.Let's be a little cooperative,\nplease.Yes?AUDIENCE: So it's 8, answer\nis 0 and absolutevalue of x is 8.PROFESSOR: So it's 8 minus\n0, which is equal to 8.So it satisfies conditions\none and conditions two.What happens to this value every\ntime through the loop?Does x change?Does answer change?And how does it change?It's increasing.What does answer start at?It starts at 0, and\nit increases.So I know that answer cubed\nwill always be positive.Right?So I know that every\ntime through theloop, it will be 8.The first time through,\nit'll be 8 minus 1cubed, which is 7.", "start": 360.0, "heat": 0.322}, {"text": "And then the next time through,\nit'll be 8 minus 2cubed, which is 0.And then, I exit the loop.And it's that kind of reasoning\nthat I used toconvince myself that this\nloop terminates.And every time I write a loop,\nand I hope every time youwrite a loop, you will think\nabout what's the reason theloop is going to terminate.And you will do it by thinking\nabout what the decrementingfunction is.People get me on that?And whoever finally answered\na question surelydeserves to be fed.I obviously have to bring better\ncandy to encouragebetter responses.Now, let's go back and look\nat the program itself.Now that we know it stops, and\nyou can take my word for itthat it actually computes the\ncorrect answer, let's thinkabout what kind of algorithm\nthis is.What's the method?This is an example of\nguess and check.And it's a particular kind\ncalled exhaustive enumeration.Each time through the loop, I'm\ntaking a guess at to whatthe value is, and I'm checking\nwhether it's true.But I'm enumerating\nthe guesses in avery systematic way.They're not just\nrandom guesses.I'm enumerating all the\npossible answers.If I get through the entire\nspace of answers, or possible", "start": 480.0, "heat": 0.424}, {"text": "answers, and I don't find a\nsolution, then I know that itdoesn't exist, and it's\nnot a perfect cube.So that's why it's called\nexhaustive enumeration becauseI'm exhausting the space\nof possible answers.Does that makes sense\nto everyone?So let's try it.Let's try it with say a very\nlarge value of x, becausethat's always an issue, of\ncourse, when we do exhaustiveenumeration.So I'm going to enter\nthis value.Is that a perfect cube?Who thinks it is?Who can tell me what it is?What's the cube root of that?Well, this is a question I did\nnot expect you to answer.But it's 1,251.That'll be in the first quiz,\nso make a note of it.Notice how quickly the\ncomputer did this.It found the cube\nroot of quite alarge number very quickly.And so while one might\ninitially think thatexhaustive enumeration is a\nsilly technique because takesa lot of guesses, for an awful\nlot of problems, we canactually just write a pretty\nstupid program that's solvesit by exhaustive enumeration.We typically refer to such\nprograms as brute force.And brute force is often\nexactly the rightway to solve a problem.Why does it work?Because computers\nare really fast.How fast are computers?Well, today, a good computer\ncan execute in a single", "start": 600.0, "heat": 0.431}, {"text": "processor in the order of 100\nmillion instructions a second.How fast is that?And now, we're going to see if\nMitchell has answered thequestion I asked in the\nway in the class.How many instructions can a\ncomputer execute between thetime I say something and the\ntime the people in the backrow hear it?Mitch thinks it's 400 million\ninstructions.I think that's about right.It's hundreds of millions\nat any rate.It's kind of amazing between the\ntime I say something andthe time you hear it, hundreds\nof millions of instructions.It's mind boggling\nhow fast that is.And that's why we can often use\nthese kind of solutions.Next lecture, actually, even\na little bit later in thislecture, I hope to get to an\nexample of why that doesn'treally get the job done,\nat least not always.Before I do that, I want\nto look at onemore programming construct.And that's a variant\non the while loop.So if we think about what the\nwhile loop we were justlooking at did or does, as the\ndecrementing function told us,it's looking at all the possible\nvalues of answerranging from 0 to the\nabsolute value of x.And at each step testing and\ndoing something, we canabstract this process using\nsomething called a for loop.So let's look at this code.It's essentially exactly\nthe same algorithm.", "start": 720.0, "heat": 0.35}, {"text": "I got bored of typing ans\ntimes ans times ans.So I used a Python notation\nfor exponentiation, whichyou'll see is star, star.Now, be easier to read\nif I get rid of that.But other than that, the\ninteresting thing I did wasreplace the while\nloop by a for.So you'll see this line of code\nthere, for ans in range 0to abs of x plus 1.What that says is range is a\nbuilt-in function of Pythonthat generates, in this case,\na sequence of integers,something called a tuple, which\nwe'll be looking at in alecture or so.But for now, it's pretty simple\nto think about what youget is if you look at the\nexpression range of x to y,that gives me a sequence\nof values, x, x plus 1up to y minus 1.Notice not up to y, but\nup to y minus 1.So it gives me a sequence\nof length y--well, assuming that's 0.Right?It doesn't have to be 0.It can be anything.It can be another\nvalue as well.0 in my example.And then, the for loop executes\nit on this value andthe next iteration on this\nvalue, and finally, at thevery end on that value.", "start": 840.0, "heat": 0.281}, {"text": "So it executes it one iteration\nof the loop on eachvalue in this sequence\nof values generatedby the range statement.And normally, it does\nall of them.However, you'll see I've added\nsomething called a break here,a command in Python.And what break says\nis exit the loop.So it exits it prematurely\nwithout executing all of thevalues generated by range.You can nest loops just like\nyou nest if statements.And if you do that break,\nalways executes--always exits rather the\ninnermost loop.So what this does is it's\ngenerates a setof values to test.It checks whether or not\nit's got the answer.If it does, it terminates\nthe loop.And eventually, you\nexit the loop.And then, it just checks as\nbefore whether or not it founda correct answer and does\nthe right thing.So you'll find, particularly\nwhen you're iterating overintegers, but later we'll see\nwhen you're iterating over alot of other kinds of things,\nfor loops are a veryconvenient shorthand.There's nothing you can't\ndo with a while loop.You don't need for loops.But they do make life easy.And over the semester, I think\nyou'll end up writing a lotmore for loops than you\nwill while loops.Any questions about this?If not, I'm going to\nmove right along.So this is the moment.", "start": 960.0, "heat": 0.3}, {"text": "I'm going to move right along.So we've now got a program that\ndoes something reallysilly, really.It finds cube roots\nof perfect cubes.Well, that's not typically\nuseful.Right?You've even got these $0.50 four\nfunction calculators thatfind square roots.And they don't insist that you\nonly give it perfect squares.So now, let's think about how\nwe would take this kind ofprogram, and indeed, this kind\nof method of writing programsand use it to find--for now, we'll look at the\nsquare root of any number, ofany floating point number.Well, the first question we need\nto ask is what do I mean?That's kind of a subtle\nquestion.What does it mean to find the\nsquare root of a number?What does it mean, for\nexample, to find thesquare root of 2?Well, we know that that was an\nendless series of digitsbefore we can find the\nsquare root of 2.Right?It does not have\na nice answer.So we can't just say we have to\nfind something that if wemultiply it by itself,\nit will equal 2.Because we can't find\nsuch a thing.So we've got to think\nabout a differentnotion of what we mean.Furthermore, even for some\nnumbers which there is asquare root, it might be a\nmillion decimal places long,and consequently, really\nhard to find.So we need to think\nabout a differentkind of concept here.And it's the concept of an\napproximation, finding an", "start": 1080.0, "heat": 0.423}, {"text": "answer that is good enough.So what should we do here?How do we think about this?Typically, what we do when we\nthink about an approximationis we define how good\nan approximationwe're willing to accept.So for example, we might want\nto say, I want to find asquare root that lies\nwithin epsilon ofthe true square root.So find a y such that y times\ny is equal to what?What does it mean?How would I express it within\nepsilon of the perfect answer?I don't want to say it's equal\nto x, because that may beimpossible or too time\nconsuming to find.So really, what I mean is\nx plus or minus epsilon.So that's what I'm asking.Find one that's close enough.And that's what the next\npiece of code Iwant to show you does.", "start": 1200.0, "heat": 0.457}, {"text": "Excuse me.So I'm starting, just giving it\na value for x, so I don'thave to keep typing one in.Let's say it's 25.I'm going to take epsilon\nto be 0.01.So I want it within that\ndistance of the true answer.I'm going to keep track of the\nnumber of guesses here, notbecause we need it to actually\ncompute the answer, butbecause I want to then discuss\nhow many iterations of theloop we're doing.We're going to start by setting\nmy first guess at 0.0.Again, this is going to be\nexhaustive enumeration.Then, I'm going to essentially\nencode this as a test of mywhile loop while the absolute\nvalue of answer squared minusx is greater than or equal to\nepsilon, and answer is lessthan equal to x.So it's now a more\ncomplicated test.I've got a Boolean value.Two things have to be true to\nexecute the body of the loop.I'm going to increment answer\nby a tiny amount, incrementthe number of guesses just so\nI can keep track of it.Maybe I'm going to comment\nthis out for the first goaround just so we don't see too\nmany print statements andkeep doing it.And then when I'm done I'm going\nto see whether or notwhat I found is indeed a square\nroot or close enough.So if we think about why this\nloop terminates, why am Iguaranteed that this loop\nwill terminate?", "start": 1320.0, "heat": 0.303}, {"text": "What's my decrementing\nfunction here?Somebody?What's the decrementing\nfunction?What am I guaranteed to reduce\neach time through, and when Iget through, I'm done?Yeah?AUDIENCE: [INAUDIBLE]answer squared minus\nx1 times 1.PROFESSOR: No.Close, sort of.But I appreciate\nyou're trying.That's worth something\njust for the effort.Somebody else.Remember, if we look at the\nproperties it has to have,it's going to guarantee me that\nwhen it gets to the rightvalue, I exit the loop, which\nsuggests it's going tocertainly be part of the\ntest of the while.Just look at this piece\nover here at the end.Answer starts at 0.I keep incrementing it.Eventually, answer minus x\nwill hit a value, right?Eventually, I'll get to\nthe point that thiscondition must be true--must be false rather.And then, I exit the loop.So this piece is not\nreally the key.It's this piece that guarantees\nme I'm going to getout eventually.This piece can get\nme out sooner.It's kind of an optimization,\nif you will.So I'm just going to go until\nI find the answer.Let's see what happens\nwhen I run it.", "start": 1440.0, "heat": 0.248}, {"text": "It tells me that 4.99, et cetera\nis close to the squareroot of 25.So there are some things\nto note about this.First, it didn't find 5, 25\nhappens to be a perfectsquare, yet I didn't find it.Is that OK?Yeah.Because that wasn't\nwhat I said.What I said is find\na y that has theseproperties over here.And I did.I didn't say find the y that\ngets closest to thesquare root of x.I said find one that has\nthese properties.Effectively, what this is is a\nspecification of the problem.And I've now written a piece\nof code that meets thespecification.It does what I set out to do,\nand that's good enough.Now, let's turn this print\nstatement back on.It took almost 1/2 million\nguesses to get there.But it was still blindingly\nfast.So once again, exhaustive\nenumeration seems to be OK.Suppose, however, I choose\na bigger number.Now, first, let's choose\nsomething that doesn't have agood answer.Let's see what it\ndoes for that.All right.Pretty good.Also pretty fast.Not too many guesses.", "start": 1560.0, "heat": 0.195}, {"text": "But now, let's try this one.Well, it's going to wait.It's going to get done, but it's\ngoing to take a littlebit longer than maybe\nwe want it to take.Why is it taking so long?There it is.It found an answer, which\nI think is good.But as you can see, it\ntook quite a fewguesses to get there.So why?Well, let me first ask\nthis question.Can we look at the code and\nanticipate how many guessesit's going to have to take?We're going back to this issue\nof computational complexity,but here, not of the problem\nbut of the solution.So this is algorithmic\nanalysis.We're analyzing the algorithm,\nthis exhaustive enumerationalgorithm, and trying to figure\nout how long it'slikely to take to run.Well, what does the running\ntime of thisalgorithm depend upon?Yeah?AUDIENCE: [INAUDIBLE].PROFESSOR: It depends on\nthe actual square root.Yes.But in particular, the distance\nof the actual squareroot from the starting point.So that's one factor\nit depends on.But that's not the\nonly factor.What else does it depend on?Oh, do we have an injury?We had a dropped pass and\na deflection there.All right.Yes?AUDIENCE: It depends on the\nlevel of accuracy, so how youdefine epsilon.PROFESSOR: It depends upon\nthe value of epsilon.Absolutely.", "start": 1680.0, "heat": 0.156}, {"text": "How long it takes to run.AUDIENCE: [INAUDIBLE].PROFESSOR: Someone with\na concern for safety.it depends upon the actual value\nof epsilon, because ifepsilon is small, we may have\nto take more steps to get aprecise enough answer.And it depends upon\none more thing.Yeah?AUDIENCE: [INAUDIBLE] the\nincrement that [INAUDIBLE]?PROFESSOR: The increment.Exactly.Because the number of times we\ngo through the loop is goingto be related to how\nbig a step wetake each time through.No applause?Thank you.So it depends upon all\nof these things.And here, since we're trying\nto find a pretty [? big ?]square root and a sort of\nprecise answer, but we'retaking tiny steps, it's\ngoing to take along time to execute.So we could make it faster.For example, suppose I change\nthe step size to this.Plus equal by says increment\nthe value by whatever theright side is.So I'm going to increment\nit by 1.Wow, it was really fast.But it didn't work.It failed.That's not so good.So I can't just do that.And of course, it's not\nsurprising, because I ended upjumping all over the answer.", "start": 1800.0, "heat": 0.119}, {"text": "I could make epsilon smaller,\nbut that seems like cheating.So really, what I need to do is\nfind a better algorithm, abetter way to attack\nthe problem.Fortunately, I don't\nhave to invent it.Some people a lot smarter than\nI am figured out a long timeago a good method for solving\nthis kind of problem.And they're doing it\nusing somethingcalled bisection search.As we look at this particular\nimplementation of it, we'regoing to use two algorithmic\ntechniques that you'll useover and over again because\nthey're generally useful.So the first one related to\nbisection search is we'll cutthe search space in half\neach iteration.So with my brute force\nalgorithm, we're trimming thesearch base only a little\nbit each step.So if we think about it, what it\nlooks like, we had a spaceof values to search\nfor the answer.And I started here.And each step, I just trimmed\noff a tiny, tiny little bit,0.001, leaving me a lot\nof space to search.And that's why it\ntook so long.When I do bisection search, the\nbasic idea is each step I", "start": 1920.0, "heat": 0.1}, {"text": "want to cut the search\nspace in half.Get rid of half of the search\nspace each time.So one way I could do\nit is I start with aguess say in the middle.Just pick some guess that's in\nthe middle of my search space.And now I say is it too\nhigh or too low?I can easily answer\nthat question.I square it.See is my result bigger than\nthe actual square root orsmaller than the actual\nsquare root?That tells me whether my guess\nis too big or too small.Once I know that, I know which\nside of the guess the rightanswer is on.So if I knew that my guess was\ntoo big, then I know there'sno point in looking over\nhere for my next guess.So I can get rid of this\nwhole half in one step.Now, what should my\nnext guess be?Yeah?AUDIENCE: [INAUDIBLE].PROFESSOR: My next\nguess should behalf way through there.Exactly.And now, let's say this time\nmy answer is too small.Then I know I can\nget rid of this.So now, I'm very quickly pruning\nmy search space.If I think about that, how many\ntimes am I likely to haveto prune it?", "start": 2040.0, "heat": 0.162}, {"text": "It's much faster, right?As we'll see later, it's\nbasically log base 2.If I have some number of\nvalues to look at--and by the way, how many values\ndo I have in my searchspace to start with?What determines it?Clearly, the first value and the\nlast value, but also, howsmall I'm dividing it up.Right?So I have to think\nabout that too.What is the precision with\nwhich I do this.Am I looking at every\none millionth of anumber or every 0.01?That will tell me\nhow big it is.Once I know how big my search\nspace is, I know that if Isearch it linearly looking at\nevery value, my worst cases, Ilook at everything until\nI get to the end.Well, my best case is\nI get lucky, and myfirst guess is right.But if I use bisection search,\nmy worst case is going to belog number of values\nin that space.Because each time, I throw\nhalf of them away.We'll see that in more\ndetail later on.Let's go back and look\nat the code now.So it starts as before with\na value for epsilon.", "start": 2160.0, "heat": 0.199}, {"text": "But now, I'm going to take a\nlower bound, here, and anupper bound on my\nsearch space.I'm going to say my initial\nguess will be the upper boundplus the lower bound\nover 2 halfwaythrough my search space.And then, I'm just going to work\nmy way through it until Iget to the answer or\ndon't find it.So should we look at what's\ngoing on here?Let's try this.Well, let's first make sure it\nworks for a small value.Never test your program first\non something big.Always try your program in\nsomething small first.Let's try it on that.Got an answer.Notice that it's different from\nthe answer we got lasttime we looked for the\nsquare root of 25.But that's OK, because it's\nstill meets the specification.It's still within epsilon of\nthe actual square root.And I didn't have to say that\nI wanted it below or thesquare root or above, just\nsaid within epsilon.Sure enough, different\nalgorithm, different answer,but equally good, but\na lot faster.Now let's try it for\nthe big value.", "start": 2280.0, "heat": 0.265}, {"text": "Wow, that was a lot\nfaster, wasn't it?It got me an answer.Probably, not exactly\nthe same answer asbefore but pretty close.But it did it in only\n26 guesses.Pretty cool.And in fact, we'll see over and\nover again that bisectionsearch is a really good\ntechnique forfinding quick answers.And again, why is it 26?Well, we had some number of\nguesses to start with.After 1, it was half as big,\nthen a quarter is big, andeventually, log 2 of the size.But what was the size?Was it the number 12345?No.We already sort of talked\nabout that.What was it?Let's look at the code, and\nlet's think about what was thesize of our initial\nsearch space.It's a little bit tricky to\nthink about this, right?Now, we have to think a little\nbit harder about when we exitthe loop, because in\nfundamentally, that's tellingme the size of the\nsearch space.So what determined the size\nof the search space?Well, we talked about the upper\nand the lower bound.But what's telling me\nroughly speaking how", "start": 2400.0, "heat": 0.243}, {"text": "many divisions I have?It's epsilon.It's not 0.01 because when\nI square it, it has to besmaller than 0.01.But that tells me roughly\nhow many I have.And so it's going to be roughly\n12345 divided by 0.01squared, which turns out to\nbe 26.897 more or less.So we could predict it.And son of a gun, when we ran\nit, we actually matched theprediction.That's the great thing about\nalgorithmic analysis.We can actually get accurate\nguesses as to how long aprogram is likely\nto take to run.This is an important thing\nbecause sometimes we do thatand we say, oh, it's going\nto take a year.I better not even try.I better find a smarter\nalgorithm.Or we do it and say, well, it's\ngoing to take almost notime at all.I'm not going to waste\nmy time lookingfor a smarter algorithm.I'm going to live with\nthe one I've got.It's important, and again, as\nI said, it's a topic we'regoing to get back to.Of course, whether it's\n26, 27, or even 50doesn't really matter.What matters is it's\nnot a billion.Right?Because we don't really care\nsmall differences.Whether it takes 25 or it\ntakes 50 will be animperceptible difference.It's whether it's a huge\ndifference that matters.And that's really the kind of\nthings we're going after isorders of magnitude.Now, I have a question\nabout this program.I've been obsessing about\nwhether it's fast enough.And we've shown it is.But does it work?Kind of more important.It's always possible to write\na really fast program that", "start": 2520.0, "heat": 0.261}, {"text": "gives you the wrong answer.The problem is to write a fast\nprogram that give you theright answer.Does this program always work?Well, it worked for 25.It worked for 12345.Is that good enough?Probably not.We might want to try it\nin some other values.I'll ask a simpler question.Does it always work on\npositive values?All right.I'll give you a hint.No.It does not.I'm not going to, however,\ntell you why it doesn't,because I want you to\nthink about it.And I want you to\ntell me why itdoesn't in the next lecture.But because I'm not a complete\nsadist, I'll give you a hint.When we use bisection search, or\nfor that matter, any searchmethod, we are depending upon\nthe fact that the answer liessomewhere in the region\nwe're searching.If indeed the answer is out\nhere or out here, then itdoesn't matter how carefully\nI search this region.I'm not going to find\nthe answer.And so this program doesn't work\non some potential valuesof x because the actual square\nroot of x will not lie in theregion that the program\nis searching.I leave it to you to think about\nwhat such values are.And we can talk about that\non the next lecture.Suppose I want to use this\nprogram to find the cube root.Suppose it worked, and\nI want it to use it", "start": 2640.0, "heat": 0.212}, {"text": "to find a cube root.What would I have to change?How would I change it, so it\nfound cube roots instead ofsquare roots?Well, I can take it up.I could use cut and paste, and\npaste it into my editor andget a new program.And how would I change\nthat new program tomake it do cube roots?Not very hard.Think only two places\nhave to get changed.That's for the simplicity,\nsay cuberoots of positive numbers.I think you said the\nright thing.All I have to do is change that\ntwo to a three and thattwo to a three, and I'm done.And I should probably change the\nmessage to say cube root.Pretty easy.On the other hand, suppose I\nalso want it to find thefourth root, and the fifth\nroot, and the sixth root,however many roots.Well, I'm going to get pretty\ntired of cutting, and pasting,and building a whole\nbunch of things.So really, what I want to do\nis find a way to write thecode that will find the nth root\nof a number for any n.To do that, I'm going\nto introduce anew programming concept.And that concept is\nthe function.And that will be the main topic\nof Thursday's lecture.", "start": 2760.0, "heat": 0.198}]