[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or to\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: So today, we're going\nto talk about Kerberos, whichis a cryptographically\nsecure, in some ways,protocol for\nauthenticating computersand applications to one\nanother over the network.So this is now finally\ngoing to use cryptographywhereas last lecture,\nwe looked at justusing these TCP sequence\nnumbers to provide security.So before we dive\ninto the details,I want to mention there's\ntwo bits of administriviathat you might want to know.There's a quiz review today\n7 to 9 o'clock in some room,I think 32 or 23.It's on schedule page and\nthe quiz is next Wednesday.And also, we want\nyou guys to postsome idea for your\nfinal project on Piazzaby tomorrow just so\nthat your classmates canknow what you're thinking\nand help you form groups.All right, so let's talk\nabout Kerberos, all right?So what is the\nsetting that Kerberosis trying to support, here?So the model for\nKerberos, what these guyshad in mind when\nthey were designingAthena guess 25 or\n30 years ago now,is that they were\nimagining they weregoing to have a network\nwith many server machinesand many client machines\ninteracting with one another.So you could imagine, well, you\nhave a file server somewhereout there.You probably have a mail server\nconnected to the network, maybeother services-- printer.And all these are just connected\nto some sort of a networkrather than being processes\non a single machine.So the prelude to\nAthena and Kerberosis that you just have a\ntime sharing machine whereeverything was a single\nprocess and everyone would just", "start": 0.0, "heat": 0.174}, {"text": "log into the same system\nand store their files there.So these guys wanted a\nmore distributed system.So this meant that you'd have\nthese servers on one sideand you'd also have a\nbunch of workstationsthat users would\nuse themselves whichwould run applications\nand potentiallyconnect to these servers\nand store the user's files,get their mail et cetera.And the problem that\nthey wanted to solvewas how to authenticate\nthe users thatare using these workstations\nto all these different serversin the back end without\nhaving to trust the networkto be correct, which seems\nlike a sensible designrequirement in many ways.And I should\nmention that I guessthe alternative to\nKerberos at the timewas these R login\ncommands that we'relooking at in last lecture,\nwhich seems like a bad plan.They just use IP addresses\nto authenticate the users.And Kerberos was\nreasonably successful.It actually still\nis used at MIT.And actually, it's the basis\nof Microsoft's Active Directoryserver.So pretty much every Microsoft\nbased sort of Windows Serveruses Kerberos in\nsome form or another.But of course,\nbecause this protocolwas designed 25 or 30 years\nago, requirements change.What people assume change.People now understand\nmuch more about security.So their version of\nKerberos that's in use todayis noticeably\ndifferent in many waysfrom the version in the paper.And we'll look at exactly what\nassumptions aren't good enoughanymore today and what\ndid they get wrong.It's sort of inevitable\nfor any protocol thatwas the first protocol to\nreally use cryptographyto authenticate parties over\nthe network in this sortof full system scale.Anyway, so that's the sort\nof setting for Kerberos.And it might be\ninteresting to figure outwhat's the trust model, right?So Kerberos is going to\nintroduce this extra Kerberosserver sitting on the side.So our third model\nat some level isthat the network is\nuntrusted like we were", "start": 120.0, "heat": 0.252}, {"text": "thinking about in last lecture.But who do we have to trust\nin this Kerberos setting?So of course, one thing is\neveryone-- all parties haveto trust the Kerberos server.So that's an assumption\nthese guys werewilling to make at the time\nthat this Kerberos server wouldbe in charge of all\nnetwork authenticationin some form or another.Do we have anyone else\nthat has to trust anythingin the setting?For example, yeah.STUDENT: Well users should\ntrust their own machines.PROFESSOR: Yes, so that's\na good point, right?There's the users that\nI didn't draw here.But these guys are\nusing some workstation.And it's actually pretty\nimportant in Kerberosthat the user trusts\ntheir workstation.So what goes wrong if you\ndon't trust your workstation?Or presumably, it can\njust sniff your passwordand do whatever you type-- you\nknow, LS, it tries-- runs RMX.That seems kind of unfortunate.Yeah.STUDENT: But it's\nmore than that though,because they could even, like,\nsniff your Kerberos ticket.PROFESSOR: Yeah, exactly.Or when you log in, you\ntype in your password, whichis even worse than the ticket.Yeah, absolutely, yeah.So this is actually a bit\nof a problem with Kerberosin the sense that if you don't\ntrust the workstation, thenyou're in a bit of trouble.So if you have your\nown laptop, thisseems like a sensible\nassumption to make.If you're using a\npublic computer,this is a bit more questionable.And we'll see exactly\nwhat could go wrong.Yeah.STUDENT: You have to trust the\npeople administrating aren'tdoing anything bad with\n[INAUDIBLE] serversand giving them privilege\naccess to one another.STUDENT: So what do you mean?So of course,\nlike, ISNT is goingto run these machines down here.But I think the machines\nthemselves don't necessarilyhave to trust one another.So the mail server doesn't trust\nthe print server or the fileserver necessarily.STUDENT: Not to\ntrust, but he mightbe able to access\na server you're notsupposed to have access to by\ngoing through another server.", "start": 240.0, "heat": 0.462}, {"text": "PROFESSOR: Yeah,\nthat's true, I guess.Yeah, so if you set up\nany trust relationshipbetween these guys-- like,\nif you give the mail serversome back end to go access your\nfiles just for convenience,then this could be abused, yeah.So you have to be careful\nabout not introducingadditional sort of levels of\ntrust or trust relations here.All right, anything\nelse that matters here?Do the servers have\nto trust the usersin any way or the workstations?No, I guess presumably not.So this was the whole\ngoal that the serverdoesn't have to a priori\neven know necessarilywhat all these users or\nhow to authenticate themor what this workstation\nis doing until it cancryptographically prove that\nthis is a legitimate userand they should have access\nto their data or whatnot.All right, so let's look\nat how does Kerberos workor what's the overall\narchitecture, at least.So the plan that\nthese guys had in mindis that there would be\nthis Kerberos server.We have drawn it up\nthere but let's draw itin a slightly bigger scale.So this is the Kerberos server.And today, it's typically called\nKDC-- Key Distribution Center.And there's all these users\nout here somewhere and alsoservices that you might\nwant to connect to.And the plan is that\nthe Kerberos serveris going to be responsible\nfor storing a sharedkey between the Kerberos server\nand every entity in the world,or in this realm at least.So if the user has some\nsort of a key KC for client,than the Kerberos\nserver is goingto remember this\nkey somewhere here.And similarly for the\nserver, the key KSis going to be known\nto the service itselfand to the Kerberos server\nbut hopefully no one else.So you can think of it as like\na generalization of passwords,", "start": 360.0, "heat": 0.349}, {"text": "right?So you know a password\nand the Kerberos serverknows your password\nbut no one else.And this is how you guys are\ngoing to prove to each other,yeah, I'm the right guy.I know this password\nand no one else does.Makes sense?And the other thing the Kerberos\nserver is going to have to dois, of course, keep\ntrack of who isit that owns this key, right?So it's going to have this table\nmapping some sort of a name.So this is some sort of a user.This is maybe service maybe\nAFS or something like this.And the KDC is responsible for\nstoring the gigantic table--well, not very large in\nterms of the number of bytes,necessarily, but\none entry per entityat MIT that the Kerberos\nserver knows about.Makes sense?All right, and then we're\ngoing to have sort of providetwo interfaces, right?The paper is a little\nfuzzy above thisor it pretends like there's\nreally two services.But really, what's going on\nis that there's two interfacesto the same machine.One of them is called Kerberos\nin the paper and one of themis called TGS for\nTicket Granting Service.And really, these\nare just two waysof talking to the same\nthing in the back end.And the protocol is a little\ndifferent for these things.So initially, when\nthe user logs in,they're going to talk\nto this guy over here.And they're going to\nsend their client name,C. So this might be\nyour Athena username.And the server is\ngoing to respondto back with a ticket,\na TGS or-- well,some sort of a ticket.We'll look at the\ndetails in a bit.And then when you want to\ntalk to some server down here,KS, then you're going to\ntalk to this TGS firstand say, oh, hey,\nI already logged inthrough the Kerberos interface.Now, I want to talk\nto the server S.", "start": 480.0, "heat": 0.187}, {"text": "So you'd tell the TGS about\nthe server you want to talk to.And then it returns you\nback some sort of a ticketfor talking to the server\nS. And then you can finallystart talking to\nthe server over hereby initially passing\nit this ticket for S.Does this all make sense?This is the sort\nof high level plan.So why do these guys\nhave two interfaces?Well, I guess I\nwanted to actually aska bunch of questions.Like, in the case of a\nservice, this serviceis probably going to\nbe stored on disk.What's going on with\nthis KC on the user side?Where does KC come\nfrom in Kerberos?Yeah.STUDENT: KDMS\n[INAUDIBLE] the database.PROFESSOR: Yeah, well,\nthe key C sits here.And that's absolutely true.It's sits on this\ngiant database.But it also has to\nbe known to the userbecause the user has to\nprove that they are the user.Yeah.STUDENT: Is that a one way\nfunction and then the password?PROFESSOR: Yeah,\nso they actuallyhave this sort of cute plan\nwhere the KC is actuallygoing to be derived by\nhashing the user's passwordor really some sort of\nkey duration function.And there's several different\nones of perverse uses.But you're basically\ngoing to take a password,transform it in some\nway, and get this key KC.All right, so that seems good.Why do we need two\nprotocols, right?You could imagine that you just\nalways ask the Kerberos serverfor tickets directly this way.You say, well, hey,\nI want a ticketfor this particular\nprinciple name.And it'll send you back a\nticket and you can decrypt itwith your KC afterwards.Yeah.STUDENT: Can you\n[INAUDIBLE] or ask the userto reenter their\npassword each time theywant to [INAUDIBLE] service?PROFESSOR: Right, so the\nreason for the differencebetween these two interfaces\nis that on this interface,all the responses come back\nencrypted with your key KC.And the Kerberos designers\nare a little worriedabout keeping this KC\naround for a long time.", "start": 600.0, "heat": 0.246}, {"text": "Because either you have to\nask the user to enter it,which is just\nannoying for the user,or it sits around in memory.And this is basically as\ngood as the user's password.So if this gets disclosed,\nthen someone with access to KCcan keep accessing the user's\nfiles until the user maybechanges their password and\npotentially even longer.We'll see about that.So this KC is a really\ndangerous thing to leak.So the whole point of using\nthis interface first and usingthis interface later for\nall subsequent requestsis that you can\nactually forget KCas soon as you decrypt this\nTGS response from the Kerberosinterface.And from that point on,\neven if you leak it,there is a lifetime\nassociated with this ticket.So worst case,\nsomeone gets accessto your account for\na couple of hours,not for an unbounded\namount of time.So that's the sort\nof main differencewhy you guys have this slightly\nmore complicated picturewith two ways of\naccessing the same thing.All right, so before we dive\ninto the mechanics of howthese protocols actually\nlook like on the wire,let's talk a little bit about\nthis naming aspect in Kerberos,right?So at some level, you\ncould think of Kerberosas being a name registry, right?So it's really\nresponsible for mappingthese cryptographic\nkeys onto string names.And this is the fundamental\nsort of operationthat Kerberos needs to provide.In fact, you'll see in the\nnext lecture even on the web,we need some function like this.It's implemented\ndifferently from Kerberosbut this is a fundamentally\nvery important thingto have in almost any\ndistributed systemfor security.So let's look at how Kerberos\nactually deals with names.So in Kerberos,\nthe sort of systemcalls every entity in\nthis database a principalAnd a principal in Kerberos is\nactually just a string, right?So you can actually have some\nprincipal like, I don't know,nickolei.", "start": 720.0, "heat": 0.231}, {"text": "So that's a string.And that could be a principal\nin some Kerberos realm.So it would literally\nbe the thingthat sits in this left\ncolumn of the KDC's table.And there's also\nsome extra instancesthat the protocl supports.I could say, you know,\nnikolai.extra secureor something.And I might use this\nas a different entityfor machines I\nreally care about.So maybe I will have\na different passwordfor really secure things\nand a different passwordfor my regular account.So this is just sort\nof how Kerberos--this is what the paper\ntalks about with instances.So one might actually\nwonder-- wheredo you actually see instances?Where do influences come from?So the Kerberos service\nmaps names to keys for you,but how do you know\nwhich name to ask foror which name to expect when\nyou are talking to some machine?So I guess what I'm asking is,\nwhat are names appear outsideof the Kerberos machine.So I guess we could ask, OK,\nwhere do user names appear?Any ideas?Yeah.STUDENT: You can ask the\nMIT server for usernamespresumably.PROFESSOR: Right, yeah.So you could enumerate\nthese things.Also, the users just\ntype them in whenthey log into a machine.So that's where it\ninitially comes from.Do usernames appear\nanywhere else?Should they appear\nanywhere else?Yeah.STUDENT: Possibly\naccess the [INAUDIBLE]lists on the various services.PROFESSOR: Yes, that's actually\nan important point, right?The goal of Kerberos is\njust to map keys to names.But it doesn't tell you what\nthat name should have accessto.In fact, the way the\napplications typicallyuse Kerberos is that\none of these serversuses Kerberos to figure out,\nOK, what string name am Italking to?So when the mail server\ngets a connectionfrom some workstation and it\nget the Kerberos ticket thatprove that maybe this\nuser is called Nikolai,then the mail server\ninternally nowhas to figure out,\nOK, well, whatshould that guy have access to?And same for a file server.", "start": 840.0, "heat": 0.223}, {"text": "So inside of all\nthese servers, there'sprobably things like access\ncontrol lists, maybe groups,maybe other things that actually\ndo the authorization step.So Kerberos provides\nauthenticationwhich tells you who is\nthis person I'm talking to.And the service itself is\nresponsible for implementingthe authorization part where\nthey decide what accessyou should have based\non your username here.Makes sense?All right, so that's where\nthe user names appear.There's also other\nprincipal namesthe Kerberos supports\nfor services, right?So services, I guess\nthe paper suggests,look something like this.That's rcmd.hostname.And the reason that you need a\nname for one of these servicesis that you want to\nknow, for example, whenI connect to a file\nserver, I actuallywant mutual authentication.It's not just the final\nserver learns who I am,but I, the user or\nthe workstation,want to be convinced that\nI'm talking to the right fileserver and not some\nfake file server that'simpersonating my files.Because maybe I'll\nlook at the gradesfile and submit it\nto the registrar.It would be too bad\nif some file servercan impersonate the response and\ngive me the wrong grades fileall of a sudden.So this is why the\nservice principles alsoneed their own name and the\nworkstations need to figure outwhat name should I expect to see\nwhen I connect to the service.And typically, this comes\nfrom the user at some level.So for example, if I type\nSSH some machine foo,then this means that\nI should be expectinga Kerberos principal\ncalled rcmd.fooon the other end\nof this connection.And if it turns out\nto be someone else,this SSH client\nshould abort and notlet me connect because then\nI will be misled into talkingto some other machine.That make sense?", "start": 960.0, "heat": 0.399}, {"text": "So here's one\ninteresting question.When can we reuse\nnames in Kerberos?It's like, all of you\nguys have Athena accounts.And when you\ngraduate, could MIT,like, wipe out\nyour database entryand allow someone else to\nregister that same username?Would that be a good idea?Well, aside from the fact\nthat you guys want accounts.Yeah.STUDENT: Updated services\nas well so that they would,like map that username\nto [INAUDIBLE] permissiontheoretically?PROFESSOR: Yeah, because\nthese guys are actuallyjust string entries somewhere\nin some ACL on a fileserver on a mail server.And just because you wipe out\nthis entry in the Kerberosdatabase doesn't mean\nthat this entry is gone.And they're not versioning\nin any way, right?This entry could\nliterally say, you know,Alice has access to\nsome Athena locker.And if this Alice graduates\nand her entry gets removed,then some new Alice\ncomes along, registers,in the Kerberos database.But she gets a\nprincipal that looksidentical to the old Alice.It's the same string.So all of a sudden,\nthe file serverwill give access to the new\nAlice to old Alice's data.So there's a bit of\na complicated processfor reclaiming principal\nnames in Kerberosbecause there's\nno real connectionor versioning\nbetween these guys.So as a result, it's\nactually kind ofhard to reuse principal names.Once you register a\nprincipal, you probablydon't want to reuse\nit very often.And same for, in some\nsense, these principal namesfor service as well.As long as this hostname\nremain some well-known servicethat people expect to\nfunction in a certain way,you probably don't want\nto get rid of its keyeven if the service goes on.Because maybe a year later,\nsome guy tries to connect to itand expects certain things.And if it's been reused\nfor a different service,that guy can impersonate things.Probably not as dramatic\nor as bad, but still,you have to be careful with\nreusing principal namesin this kind of protocol.Makes sense?Any questions?All right, so let's look at how\nthe protocol itself now works.So we'll look first and\nthis step of the protocol", "start": 1080.0, "heat": 0.756}, {"text": "where you initially get your\nticket with your password.And then we'll look at how\nthis TGS interface worksand how it differs\nthen a little bit.All right, so I guess\nthere's this main datastructure that Kerberos\nuses called a ticket.And this ticket looks like this.So there's a ticket to\nbetween a client and a server.And this guy is\nbasically the namesof the server and\nthe client that we'retalking about-- the IP\naddress of the client,some kind of timestamp, and an\nexpiration time for how longthe stick is valid.And there's also\na key, KCS, that'sgoing to be shared between\nthe client and the server.So that's what's in a ticket.And there's also this\nother weird data structurethat Kerberos introduces\ncalled an authenticator.And an authenticator goes\nwith a particular client C.And this thing is just\nthe client's name,the IP address of the\nclient, and the time stampwhen the client generated\nthis authenticator.And typically, both of\nthese things are encrypted.And authenticator is\ntypically scriptedwith the key between the\nclient on the server.So the authenticator\nsort of has to dowith a particular connection\nbetween a client and a server.And the Kerberos\nticket itself hereis typically encrypted with\nthe key for the service KS.So the subscript\nnotation denotes hereencryption with\na particular key.All right, so what does this--\nso using this sort of notationhere, let's try to figure\nout what is the protocol.By which the user initially\nlogs into this Kerberosand gets their TGS ticket.So as we saw here\nbefore, right, the planis the client is going to\nsend their username over", "start": 1200.0, "heat": 0.623}, {"text": "to the Kerberos server\nor that interface.And the response is\ngoing to be a ticket.And what precisely\nthe client actuallysends over-- both the username\nC of the client that'sissuing the request as well\nas the principal name-- well,the client is also\na principal name.But the client also\nsends the principal nameof the service for which it\nwould like to get a ticket.And typically, the service name\nis actually the service nameof this TGS guy over here.So you get a ticket for them.But you could get a ticket\nfor almost any serviceyou want in this way.And their response\nis going to bethis sort of interesting tuple.It's going to be your\nticket between the clientand the server encrypted\njust with that key KSas shown above.I guess we should\nwrite that down with KSAnd also, you get to\nthis shared key-- key CS.And this whole thing\nis encrypted with KC.So that's the wire protocol.So I guess let's try to\nfigure out a couple things.So first of all, how\ndoes the Kerberos serverauthenticate the client here?How does it know that this\nis the right user makingthis request?Yeah.STUDENT: It can make\nsure that the ticketthat it sent because it has KC.PROFESSOR: Yes, I think\nthat's what's going onis that the Kerberos server\nagain on some level actuallydoesn't know whether this\nis the right client or not.But it thinks oh, well,\nsure, it doesn't matterwho is making this request.I'll just send this blob\nout and the only personwho should be able to\nmake any use of this blobis the person that knows\nthis key KC over here.So that's actually kind\nof cool because the clientdoesn't have to\nsend their passwordover the network at all.So in some ways, this is\nactually better than the clientsending a password to\nthe Kerberos serverbecause even if the\nKerberos server here", "start": 1320.0, "heat": 0.906}, {"text": "was listening for\nthese passwordsand trying to record them, it\nwould never get your password.Or maybe if someone was\nimpersonating the Kerberosserver, they wouldn't get\na copy of your password.All right, yeah.STUDENT: [INAUDIBLE]\nadversary wants to [INAUDIBLE]your password offline without--PROFESSOR: Yeah, so this is\nactually not a great aspectof Kerberos, in fact, right?So does everyone see\nwhat the problem is?The problem is that the\nway the client couldtell if they got the\nright password or notor the workstation tells\nif the client suppliedthe right password is they\ntry to decrypt this ticketand they see if it works or not.And decryption is fairly cheap.This is symmetric\nencryption and youcan do probably\nmillions of decryptionsa second if you try\nhard on modern machines.And this means that\nyou can try millionsof potential\npasswords per secondto guess what the\nperson's password is.And you could do this\nfor any person at all.You could just send\ntheir principalto the Kerberos server.It'll very happily give you\nback this response encryptedwith the user's password.Then you can just try different\npasswords and just see whatworks or what doesn't.Yeah.STUDENT: But won't the\ncontent [INAUDIBLE]decrypted [INAUDIBLE] advantage?How can we be sure\nthat you directly--PROFESSOR: Yes, this is actually\nanother interesting aspectwhere the Kerberos 4\ndevelopers didn't quiterealize that the time they were\nbuilding this that they reallyshould have been very careful\nabout separating encryptionfrom authentication.So in the paper, there's\nthis implicit assumptionthat-- hopefully, that's not us.All right, sorry.So in the paper, there's\nthis implicit assumptionthat whenever you\nencrypt a piece of dataand you send it to someone\nelse, if that person can decryptthe data and it\nsort of looks OK,then no, they must have\ngotten the right keyand the data wasn't\ntampered with in flight.But it seems like a\ntotally bad plan nowthat we think of\nit 30 years later.But at the time,\nit wasn't so clear.So in order to do\nKerberos right,and in fact, what\nKerberos 5 does now,", "start": 1440.0, "heat": 0.856}, {"text": "is they both encrypt\nall the pieces of dataand they also\nauthenticate the messageby basically computing\na hash with a key.And then the result\nactually tells youthat, oh, that piece of data\njust wasn't tampered with.It was correctly signed\nwith this key, et cetera.And what actually\nhappens in Kerberosversion 4 is there\nare some extra bitsin this thing that was\nencrypted that should allbe some pattern like zeros.And typically, if you\nget the key wrong,that pattern will not look\nlike all zeros just by chance.It's not cryptographically\nguaranteed to be that.But most times, it will\nnot look like zerosand you will be able to decide\nwhether you got the correct keyor not.All right, so that's\nsort of the planfor how the clients\ntells, I guess,whether the ticket is valid.They just try to decrypt\nit and see how it works.So another interesting\nquestion iswhy is this key\nKCS included twicein the ticket in\nsome form, right?So it's included once here\nand another time actually sortof implicitly in\nthis ticket T. Whydo we have two copies\nof the same key KCS?Yeah.STUDENT: The client\ncan't decrypt that ticketbecause it's encrypted\nwith a service key.PROFESSOR: Yeah, so it's\nactually kind of cute, right?Like, there's this key\nthat the client can get to.But then there's another\ncopy of it in here.It's encrypted with KS.And the reason for this is that\nthe Kerberos server is actuallytrying to set up the\nclient and this other guyto talk to each other securely.So the Kerberos generates\nthis hopefully random key KCSand wants to give one copy\nto the client and one copyto the write other server\nthat you want to talk to.And one thing you could\nimagine doing naivelyis maybe the Kerberos will\njust go and say, hey service,this guy wants to talk to you.Here's the key for it.But that would be\nkind of unfortunate.You'd have to have the Kerberos\nserver call back to the serviceand so on.So instead, these guys have\nthis nice trick where they justto give the client does\nblob that the clientcan't actually do\nanything with other", "start": 1560.0, "heat": 0.624}, {"text": "than give to the right service.And if the service\nhas the right key KS,they'll decrypt it and say, aha.Well, here's the key I should be\nusing to speak to this client.And that's how these two guys,\nthe client and the service,are going to establish a\nshared key for protectingtheir communication.Yeah.STUDENT: So what exactly is TGS?PROFESSOR: So TGS\nis-- OK, so there'ssort of two sides to it.From the client's point of\nview, it's just another servicethat you can get a ticket for.And the kinds of\noperations it supportsis getting more tickets.It's a Ticket Granting Service.STUDENT: Sorry, I meant what\nis the ticket called TGS.PROFESSOR: Oh, yeah, sorry.This TGS is just shorthand\nfor this whole blobexcept where S is actually\nthe principal name of this TGSservice.So you can think of it as\nlike, well, there's a Kerberosserver, there's this\nTGS service out there,and then there's the real\nthing I want to get to.So you first ask\nthis guy to give mea ticket for some service.You could ask it to give you\ndirectly a ticket for the fileserver.And this would work.But you'd need your\nKC to decrypt itand then you'd need your\nKC around all the time.So instead, what\nyou do is you geta ticket for this special\nservice over here.It looks just like a service\nexcept that it happensto be provided by the same box.And then this guy will\nhappily give you more ticketslater without having to\npresent your initial KC again.Makes sense?All right, other questions?Yeah.STUDENT: So [INAUDIBLE] the idea\nis once you get the TGS ticket,you can just get rid of your KC?PROFESSOR: Yes,\nso that's actuallythe cool thing about\nit is that onceyou get this ticket-- well, this\nticket with the S being TGS,then you're going to get\nrid of the password and KC.So you log into Athena\nworkstation and a coupleof seconds into\nthe boot process,you already get\nyour ticket here.It scrubs the\npassword from memory.So even if someone, like,\ngrabs you and grab the machineand runs off, all they\ngot was your ticket.And OK, well, maybe they can\naccess your stuff for 10 hoursor whatever the\nticket lifetime was,", "start": 1680.0, "heat": 0.666}, {"text": "but not for longer than that.The password is gone.Yeah.So if the password's\ngone, then on that picturethere when Kerberos\nsends a replyencrypted with KC,\nhow does the client--Oh yeah, so this is the one\nplace you need your password.So you send this message,\nyou get this reply,you decrypt this, and then\nyou forget the password.So you can't forget\nabout the passwordbefore you use it for\ndecryption of course.STUDENT: [INAUDIBLE]PROFESSOR: Ah, no, so this is\njust this interface, right?So this is the thing\nyou do initially.And we'll talk in a second\nabout how you basically alsocan get any ticket you want\nfrom the second interfacewithout needing\nthe initial key KC.Right, make sense?All right, so I guess\nwe already talkedabout two particular problems\nthat the Kerberos protocol hadsort of baked into it, which\nis a little unfortunate.One is that they assumed\nthat encryption alsoprovides authentication\nor integrity of messages.So don't do that.And Kerberos\nversion 5 fixes thisby explicitly\nauthenticating messages.Another thing they sort\nof had a problem withis the ability for\narbitrary clientsto guess people's passwords.So any suggestions of\nhow we could fix this?How do you prevent\nguessing attacksin a protocol like this?What could we try?Yeah.STUDENT: Some sort of salting?I'm not sure.PROFESSOR: Well, so\nsalting would justmeans that the client\nhas to hash the passwordin different ways, maybe.But it still\ndoesn't prevent themfrom trying lots of things.So maybe it'll be more\nexpensive to build a dictionary.Yeah.STUDENT: You could [INAUDIBLE]\nderivation function?PROFESSOR: Yeah, so\nanother good ideais to make this hashing\nprocess super expensive.So that might be\nkind of nice, right?So if this hash function took\na second to compute like youguys did in lab two,\nthen OK, wow, thiswould be actually\nreally expensiveto try different passwords.So that seems like\na reasonable plan.So in combination\nwith salting, those", "start": 1800.0, "heat": 0.616}, {"text": "would be make it pretty\nexpensive to do passwordguessing attacks.Anything else?So another thing is,\nyeah, challenge respond.So you could actually hear\nin the initial protocol,the Kerberos server\ndoesn't have any ideaif this was the\nright client or not.But in fact, what\nyou could do is maybegive a little bit of a\nproof that, well, you'reprobably the right client.So maybe you could encrypt\nthe current time stampwith your hash\npassword or somethinglike this-- has them together.And then the Kerberos\nserver could justcheck if that's the right-- if\nthat matches, and if so, returnyou back a ticket.You probably don't want to\nnecessarily add more roundsbut this could work.So just to precise about\nwhat I'm sort of suggesting.OK, well, maybe you take\nthe current time stampand maybe you hash the current\ntime stamp and the KC together.And maybe you include\nthe timestamp as well.And then the server could\nsee, well, it has your KC.It could hash the current\ntimestamp as well.If it gets the same\nvalue, then yeah,it's probably the right\nuser requesting it.And I can send back the ticket.If not, then it wasn't\nthe right password at all.Question?STUDENT: [INAUDIBLE] you just do\n[INAUDIBLE] if the servers seetoo many requests [INAUDIBLE]PROFESSOR: That's right.So the problem is that\nwe could write limit.But there's no\nreason for the hackerto request this more than once.That hacker requests a\nparticular user more than onceand then it gets\nthis encrypted blob.And then it can try decrypting\nit offline as many timesas it wants with\ndifferent passwordswithout having to re request it.So I think the whole\npoint of includingsome sort of a\nchallenge response thinglike this in the particle\nis so that the server will--you'll have to actually\nask the server againand again to try to log in\nwith different passwords.And then you could rate\nlimit of the serverand get a much better defense.Yeah.STUDENT: [INAUDIBLE] Kerberos?PROFESSOR: So I think you could\ncertainly replay this message", "start": 1920.0, "heat": 0.561}, {"text": "so if I sent this message\nnow, you could probablylook at that message\nand send it as welland get a response back\nfrom the Kerberos server.I guess if you're\nwatching the network,you could observe this\nthing on the wire as well.So I think this is sort of a bit\nof a stopgap measure-- improvessecurity a bit.But certainly if you're\nwatching someone else's network,then you're going to see this\npacket coming back regardlessof what happened in this step.So coming back,\nyou'll see this guyand you can then\ntry to attack it.There's probably some\nmore elaborate schemesyou could design\nbut I didn't thinkKerberos 5 even\nimplements anything moreelaborate than roughly this\nplan, which seems good enoughto prevent arbitrary\npeople from tryingto break anyone's or brute\nforce anyone's password.Make sense?Yeah.STUDENT: So presume\nthat you coulddo authenticated [INAUDIBLE]\nor something hereto establish the shared key.And then you could\nencrypt this thingwith KC and the shared key.PROFESSOR: That's right, yeah.So if you're really\ndoing this right,there's all these nice\nparticles out therethat are basically called\npassword authenticated keyexchange particles, which is\nexactly what's going on here.So if you're actually\nbuilding a system,you should basically\nGoogle for SRP or PAKE.And these protocols\nand related particleswill actually do this in\na much better way whereyou can prove to both\nparties that you establisheda new key and both parties\nare convinced that it'sthe right other party\nand there's no wayto mount these offline\npassword guessing attackson the set of network packets\nthat you observe and so on.So these are the\nsort of protocols.And they're much more\nelaborate in termsof crypto they rely on.So it's hard to explain on a\nboard exactly why they work.Yeah.STUDENT: [INAUDIBLE]\npart of the reasonthey did it this\nway is because theywanted to maintain the ability\nof just sending the password.And protocols just allow\nyou to send a single thingas your authentication\n[INAUDIBLE].PROFESSOR: Well,\nyeah, there's lotsof sort of weird requirements\nthat these guys had in mind.I think they-- well,\ncertainly in practice,", "start": 2040.0, "heat": 0.436}, {"text": "these servers could accept\nboth Kerberos and non Kerberosconnections.And for non Kerberos\nconnections,you get-- like someone\nconnects to the mail serverbut they're not using\nan Athena workstation.They just want to\nsend their password.And then the mail\nclient here, let's say,is going to take\nyour password and isgoing to get a ticket on\nyour behalf just to check it.And then it's going to\nallow you to use it.So you certainly want conversion\nfrom Kerberos from passwordsinto checking against Kerberos.I don't think this precludes\nit because certainlyKerberos 5 deploys although\nthis hashes of timestamps,et cetera.STUDENT: Yeah but it's\nbecause they wouldn'twant multiple [INAUDIBLE].PROFESSOR: Yeah, well,\nI think that probablydoesn't matter quite as much.You could certainly have\nmultiple rounds in the back endbehind your library.But there's some downsides\nto these particles--probably not significant enough\nto stop you from using them.Other questions?All right, I guess\nthe other thingI want to mention that\nyou should watch outfor in the paper is that these\nguys, in designing Kerberos 4,they picked a single\nencryption scheme.And at the time,\nthey basically pickedDES, which was a popular\nencryption scheme of the time.It's a symmetric block cypher.It goes pretty fast.It was reasonably secure,\nnot necessarily the best,but certainly good\nenough at the time.And they just baked\nit into the protocol.Everything in Kerberos has\nto use single DES or at leasteverything in\nKerberos version 4.And this was a bit problematic\nbecause 25 years later,30 years later\nnow, it's actuallyvery cheap to brute\nforce DES encryptionbecause the keys are\nactually very small.They're 56 bits.So you could just search build\nsome custom hardware thatiterates over all the possible\n2 to the 56 combinationsand tries them all and figures\nout what someone's password is.So this is something\nalso you want to avoidin any protocol you design now.Kerberos version 5\nactually supportsmultiple different\nencryption schemes includingAES and other things as well.So that seems like a\nmuch better way to do it.On the other hand, MIT\nactually kept supporting DES up", "start": 2160.0, "heat": 0.388}, {"text": "until two years ago, which\nis a little unfortunate.But now they don't.So that's good.Your principal is secure at\nleast from this kind of attack.All right, so does\nthat make sense?This is the initial\nway you'd getany ticket at all in Kerberos.And typically, you'd get this\nticket from this TGS service.So now let's look at what's\ngoing on in this TGS service.So here, the interaction\nwith the TGS serviceis going to be a\nlittle different.On one hand, you're\ngoing to-- as a client,you're going to have\nto speak to it asif you're speaking to any\nother Kerberos enabled service.So we'll see how you\nauthenticate yourselfwith a ticket to some machine.But then the response\nyou're going to get backis just a ticket for\nsome other principlethat you're going to want to\ncommunicate with like your fileserver.So the protocol level messages\nthat show up here kind oflook like this.So here's your TGS service.And here's a client.The client already\ngot a ticket for TGSusing this protocol above.So what the client is\nactually going to send overis some combination\nof messages thatprove that this is\nthe right clientand they're issuing a request\nfor some particular principlethrough TGS.So what the client is going\nto send to TGS is this tuple.So first, it's\ngoing to say, well,here's the service that\nI want to talk to next.So this might be your mail\nserver or your file server.Then is going to\ninclude the ticket.It already got 4TGS.So this is going to be TC\nof TGS encrypted with KTGS.So this is just this\nthing where S is TGS.And then you're going to have\nto include this authenticatorblob.This is this AC\nthing from up there.And this thing is\ngoing to be encryptedwith a shared key between the\nclient and the TGS service.So this is the message that\nyou're going to send to TGS.It's going to look\nat this message,", "start": 2280.0, "heat": 0.4}, {"text": "do something with it that\nwe'll talk about in a second,and respond back with a\nticket for this new service S.So the response here looks\nalmost exactly like here.In fact, it is exactly\nthe same thing.It's going to be a\nticket between the clientand this new service\nS encrypted with KSand the shared key between the\nclient and this new serviceS encrypted-- well, now,\nhere's a little bit different.Instead of encrypting with KC,\nwhich the client has probablyforgotten since\nthen, now we're goingto encrypt it with this\nshared key between the clientand the TGS service.Makes sense?All right, so in this-- how does\nthe server actually figure outwhat the client wants to do?Or, how does server\nauthenticate the client?Well, in this case, it's\ngoing to-- TGS server actuallyknows its own key, KTGS.So it's going to first\ndecrypt this bloband look inside the ticket and\nfigure out what's going on.And there's all those\nnice fields in the ticket.So let's just double check.Why do we need all those\nfields in the ticket?So is it important to have the\nserver name S in the ticket?What would go wrong if you\ndidn't have S in there?Anything?Yeah.STUDENT: They could\npotentially getauthorized to use any server.PROFESSOR: Yeah, so it's\nin general a good ideato be very explicit\nin network protocolsand to say exactly\nwhat a message means.So in this case,\nif you omit an S,you might be relying\non the fact that, well,if it's the wrong S that you're\ntrying to use the ticket for,then maybe you'll have a\ndifferent key over hereand then it wouldn't decrypt\nor something like this.But it seems like a good idea\nto include it to make surethat the server that\nreceives this ticketsdecrypts and checks.Is that a ticket for\nme or for someone else?Yeah.STUDENT: What does the\nclient get KTGS on?PROFESSOR: Ah, good question.The client has no\nidea what this is.Because this is like\na super secret key.", "start": 2400.0, "heat": 0.581}, {"text": "If you knew this,\nyou'd probably beable to break all of Kerberos.So the client has no\nidea what KTGS is.STUDENT: [INAUDIBLE]PROFESSOR: Ah, yeah, yeah.And then the where\nyou get it fromis actually-- it's the\nKerberos server itselfthat generates this whole blob\nfor you where this is actuallyTGS and this is KTGS over here.So you don't construct\nthis yourself.You just copy it over.OKSo what is the client\nname there important for?That should be\nfairly easy, right?If you don't put the\nclient name in the ticket,then the server\ngets this nice blobbut it has no idea who\nit's trying to talk to.So it has no idea\nwhether it shouldissue a ticket for my\nprincipal or for someone else'sprinciple, et cetera.So what's the deal\nwith the other fields?Why do these guys stick\nan address in the ticket?This is the client's IP address.Does it matter?Yeah.STUDENT: Can they\nuse that addresswith the ticket to verify\nagainst the [INAUDIBLE]?PROFESSOR: Sort of.Well, so I think\nthe general planfor why there's\naddresses appearingeverywhere here,\nthese IP addresses,is that these guys at the\ntime were still slightlyconfused and--\nwell, in some ways--they were still\nthinking, OK, well,we're going to rely\non IP addressesfor a little bit of security.So they wanted to make sure\nthat if the client logged infrom some IP address, then\neverything else going onwith that ticket happen\nfrom that same IP address.So if you logged in\nfrom some IP addresson 18.26.4.9 or something,\nthen every connectionyou make to a file server\nor to a mail serverhas to be from the\nsame IP address.Otherwise, the server should\nreject your connectionas being stolen by-- or\nsomeone stole your ticket.So we're thinking,\nOK, well, maybe we'lldefend against ticket\ntheft this way.If you still a ticket,\nwell, but you'renot using the same IP address.So it won't work.It's probably a little bit\nmisguided at this pointbut-- that sort of gets in the\nway And Kerberos 5 still has itbut it's largely optional.Really, you should just rely on\ncryptography instead of any IPaddress security.", "start": 2520.0, "heat": 0.6}, {"text": "So what's the point of the\ntime stamp and lifetime thingsin the ticket up there?One are those guys good for?Are they useful?Yeah.STUDENT: Preventing\nreplay attacks.PROFESSOR: Well,\nso the syndicatoris the thing that's\ngoing to help us preventreplay attacks in a second.Because that thing gets\ngenerated every timeyou do a new request.On the other hand, the\nticket just stays the same.So it's certainly not\npreventing replay attacks there.Yeah.STUDENT: It prevents somebody\nfrom stealing your ticket thenusing it [INAUDIBLE]PROFESSOR: Oh, sorry, yes.This just bounds the time\nfor which a ticket is valid,meaning that the damage\nfrom disclosing itis hopefully reduced.So the plan is the timestamp\nis roughly the time whenyou initially got the ticket.And a lifetime in\nthe ticket representshow many hours,\nlet's say, it's validfrom that initial timestamp.So if you try to use it\ntoo early or too late,then every server should\nreject such a ticketin the Kerberos protocol.So this kind of means\nthat every serverhas to have a loosely\nsynchronized, clock whichis a bit of a-- well,\nmaybe you've run into this.Like, your laptop clock is off\nand you can't log into Kerberosanymore.Question?Yeah.STUDENT: You said before\nthat the client discards KCbut they're still\nkeeping KCS [INAUDIBLE]the TGS. [INAUDIBLE]PROFESSOR: That's right, yeah.So the client discards\nKC after logging in.But it still keeps KCS.You're exactly right.STUDENT: So if someone\nsteals the KCS,then they have access\nto [INAUDIBLE].PROFESSOR: Yeah, OK.So how bad is that?Like, why is it better\nto disclose this KCSfof-- actually, well,\nthis is TGS, right?Why is it better to\ndisclose KCTGS than KC?Yeah.STUDENT: Someone [INAUDIBLE]\nsomewhere [INAUDIBLE].PROFESSOR: It's\nthe kind of thingthat they're both keys, though.So neither of them are\nreally hashed, yeah.STUDENT: You would take\nKCS and you'd just stealthat session between those two.But if you steal KC, you\ncan impersonate the client.PROFESSOR: That's right.Yeah.So I guess one\nway to answer thisis that KCTGS, this is actually\na new key generated every time", "start": 2640.0, "heat": 0.443}, {"text": "you log in initially.And this thing is only good\nbecause you have this ticketthat goes along with it.If you lose this ticket or if\nthis ticket is no longer valid,then yeah, you have these\n56 bits in this key.But no one is going to assume\nanything from those bits.The only reason these\nbits are interestingis because this ticket talks\nabout this KCS being validright now.And there's a bound on it.STUDENT: Yeah, so if\nthey stole both of those[INAUDIBLE] be bounded.PROFESSOR: Yeah, if someone\nsteals both of these blogs,than they can impersonate you\nor, like, log into your fileserver, mail server for the\nlifetime of that ticket, whichis a couple of\nhours or 10 hours.Stealing this, there's no time\nbound on that until you changeyour password and maybe worse.Make sense?All right, so it\nseems like, yeah,all those fields are\nkind of important,IP address maybe less so.And now in response, right, we\ncan get this ticket finally.And because we know KCTGS,\nwe can decrypt the responsefrom this TGS server.And now we have a\nticket for any serverwe want-- a file server,\nmail server, whateverit is that we finally\ncare about connecting to.Make sense?All right, so let's look at\nhow you might sort of finallyuse this in some\napplication level protocol.So suppose that maybe I'm\ntalking to a mail serverto fetch my messages.So presumably, what my client\nworkstation is going to dois going to send a tickets\nrequesting for, I don't know,mail.po12.And it'll get back a ticket\nfor the principal mail.po12or something like this.And then inside of this ticket\nor inside of this response,now I have a shared\nkey between meand the mail server-- S is\nthe male server over here--and this ticket a blob\nthat I can to the mailserver to convince it\nthat I'm the right guyor anyone with this key\nis the right principle.", "start": 2760.0, "heat": 0.307}, {"text": "And then we can actually have\nan encrypted conversationwith the mail server\nusing this new key KCS.So what I might do as\na client is-- well,initially, I send some\nmessage to the mail serverthat includes this\nticket TC mail encryptedwith the key of the mail server.And then I can actually\nsend some message alongwith this request that maybe\nsays something like, well,delete some message-- delete 5.And I can encrypt\nthis with KC mail.Does that make sense?OK, so what happens in this\nprotocol on the mail serverside?The mail server is going to\nuse its secret key K mailto decrypt this ticket first.And then it looks\ninside there and findstwo important things-- the\nprincipal name C of whois it that's talking to it in\nthe first place and the key KCSthat it should be\nusing to decryptall the subsequent traffic\nand authenticate it ideallyin Kerberos 5, at least.And then you can decrypt this\nmessage and say oh, well, yeah.User C is trying to\ndelete message five.So I'll run this command.Make sense?You had a question?STUDENT: Yeah, so\nKerberos initiallysends the TGS ticket in KCTGS.Where's [INAUDIBLE]?PROFESSOR: So AC, those\nauthenticators are actuallygenerated by the client.Note that the client\nonly needs KCSto generate an authenticator.So the client can make\nthese up any time it wants.So the general plan for\nindicators or the reasonto use authenticators is roughly\nto prevent replay attack.So the client, or at least in\nthe way that the Kerberos 4developers were\nintending it, the client,every time it sends\na new request ,it would generate a new\nauthenticator to say OK, well,", "start": 2880.0, "heat": 0.547}, {"text": "this is a new request.I'm issuing it now.It's different from all\nthe previous requests.Go do it.And the general plan\nwas that the serverwould keep a cache of\nthese authenticators thatwere sent within the\nlast five minutes or so.So if it ever sees a\nduplicate authenticator,it says oh, that's\na replay request.I'm going to reject it.And if it sees an\nauthenticator that'soutside of a five\nminute boundary,it doesn't have it in the cache.But it will look at the time\nstamp in the authenticatorand say, well, this is a\nvery old authenticator.I'll just reject your\nrequest because it's too old.Send it again if\nyou really care.So that's the general\nplan for indicators.As with many things\nin Kerberos, theywere slightly broken--\nin Kerberos 4, at least.Because this\nauthenticator actuallysays nothing about the\nmessage you're sending, right?It's some blob.So the way you would\nuse it, for example,in this mail server protocol\nis-- or at least in Kerberos4-- well, you would\ngenerate some authenticatorand you would be to\ntake the authenticatorand you would encrypt\nit with also KC mail.And the mail server would\nkeep track of, well, yeah,you've sent this [INAUDIBLE]\nindicator before.No, you haven't.But there's nothing here that\nconnects the authenticatorto the message you are sending.So for the first\nmessage, this was great.But when you send\na second message,you're going to generate\na second authenticator.And someone on the\nnetwork can say, oh, yeah,I got your new authenticator.I can take your\nnew authenticatorand splice in the\nold delete message.So I'll force you to delete\nthe fifth message twice,even though the\nsecond command meantto send some other operation.So Kerberos 5 gets this\nright where you actuallystick something in the\nauthenticator that relatesto the command you're issuing.You could do this, of course,\nbut sort of took a whilefor people to realize\nthat, well, here'show you should design\na protocol correctly.Make sense?Yeah, other question.STUDENT: [INAUDIBLE]PROFESSOR: Ah, so the\nclient gets case email", "start": 3000.0, "heat": 1.0}, {"text": "from this response.So the client, when it wants\nto talk to the mail server,it's going to ask the TGS for\na ticket for the mail server.And here, S is basically this\nmail server's principal name.So when it comes back,\nthis says S equals mailand this server key\nS is equal to mail.And this KCS is\nactually KC mail.So this is how the client\nlearns of the shared keythat it has between it and the\nfiles and the mail server here.And there's a copy of\nit inside the ticket.Question back there?STUDENT: How does the\nmail server get KC mail?PROFESSOR: Ah, yes.So how does the mail\nserver get this shared key?Like, the mail server\nmight have never heardof your connection before,\nnever heard of you.Where does KC mail come from\non the mail server side?Yeah.STUDENT: Isn't it\npart of the ticket?PROFESSOR: Yeah, yeah, so\nthis is the cool thing.You send this ticket over to the\nmail server and the mail serverknows its own secret key K mail.And it uses that to decrypt the\nticket TC mail and the sharedkey is in there along\nwith the name of whoeverit is that you're\nsharing this key with.That's how it finds out,\noh, I'm talking to the guyand that's the shared\nkey we should use.Makes sense?All right, so that's\nthe sort of basic planfor how you use this protocol\nin some actual application.There's-- well, there's a\nbunch of problems with this.So Kerberos is-- it's\na nice paper to readbut then there's all these\nproblems these guys didn'tknow about 30 years ago.So it's sort of inevitable\nthat there's problemsyou have to go through.So one interesting\nproblem in the wayKerberos 4 encrypted and\nauthenticated messagesfor applications is that\nthey use the same keyfor encrypting messages from\nthe client to the serveras well as messages from the\nserver back to the client.So suppose that the client\nissues, I don't know,", "start": 3120.0, "heat": 0.791}, {"text": "a request to fetch a\nparticular message.So then I say, you know,\nfetch the message 7.And I encrypt this\nthing with KC mail.That seems all great.The mail server has\nthe shared key that'sgoing to decrypt this message.And it's going to send me back\nthe body of this email messagealso encrypted with KC mail.Does anyone see a\nproblem with this?Why is this is potentially\na bad thing to do?Anyone else?Sure.STUDENT: So there's\na chapter [INAUDIBLE]they can make [INAUDIBLE] look\nlike some other things theywant [INAUDIBLE]PROFESSOR: Yes, so\nthose are actuallyworrisome because I could send\nyou any email message I want.So suppose I really want\nto delete some message thatis sitting here in\nyour inbox and Idon't want you to read it.I know it's maybe\nmessage, I don't know, 23.So I'm going to send you an\nemail that says, delete 23.You're going to read it.You're going to fetch\nit and a responseis going to come from\nthe mail server saying,delete 23 encrypted\nwith this key.And so far, it's not being\nsent to the mail server.But if I look at the\nnetwork at the right timeand capture this packet,\nI can send the packet backto the mail server.It would look like a message\nsaying delete 23 encryptedwith the right key.And the mail server\nwill say, oh yeah, sure.You're trying to\ndelete this message.I'll do it.So this is a bit of\na problem because weare allowing an adversary\nto confuse the mailserver into whether our\nmessage was generated by itor was sent to it\nin the first place.So this is quite troublesome.So these are what's\ntypically calledin cryptography and\nprotocol literatureas reflection attacks.So you have any suggestions for\nhow we can avoid this problem?Yeah.STUDENT: Can't you just include\na header saying its origins?PROFESSOR: Yeah,\nso typically, youwant to have some very\nunambiguous way to state what'sgoing on.One way is to have a header\nin every message that says,this is going from the client\nto the server or from serverto the client.And even better plan\nin practice turns outto be just use\ntwo separate keys.Because you might want to\nhave a long stream of data", "start": 3240.0, "heat": 0.723}, {"text": "where you don't really have\nspace for this header bit.So instead, what Kerberos 5\ndoes is every time you establisha connection with some service ,\nyou actually negotiate two keysinstead of just one key.And the first key is going to\nbe used for encrypting stufffrom client to server and other\nfrom server back to the client.So that seems like a much\nbetter way to do it in practice.Make sense?All right, so I guess\nlet's now talk a little bitabout what happens with KDC.So the Kerberos server is\npretty important to the system.But what happens if\nthis KDC goes down?So how bad is it to our system.Like, in Athena,\nsuppose if KDC crashes,does this affect your life?Well, if you use Athena.STUDENT: Is that why\nyou can't log in?PROFESSOR: Yeah, so\nyou can't log in.I guess the other thing is\nyou also can't get ticketsto new things as well.But kind of the cool thing\nis that the KDC is largelyoff the critical path\nfor existing connection.So no data passes\nthrough the KDC.And if you already have\na ticket for something,you can keep using\nit and keep logginginto some service\nover the network.So in that way, it's actually\nquite nicely cacheable.I guess the other\nnice thing these guysdo is they actually have\na way of replicatingthe KDC potentially.So they have one\nmaster Kerberos serverthat stores the sort of primary\ncopy of this whole database.And then they can have\nread only replicas thathold a copy of this database.They don't allow\nany updates to thislike registering users\nor updating keys.But they do allow responding\nto login and TJS requests.So this way, these backup\nclones of this Kerberos databaseallow you to keep logging in\nand keep talking to serviceseven if the master\ncrashed and hopefullymake it possible to upgrade\nto master without breakingeverything at the same time.Makes sense?Any questions?Yeah.STUDENT: How hard\nis it to compromisethe KDC server and [INAUDIBLE]?", "start": 3360.0, "heat": 0.637}, {"text": "PROFESSOR: Well, yes,\nthis is a huge sortof target for any system\nthat runs Kerberos.Because if you\ncompromise this guy,you're in complete\ncontrol of the system.You can mint tickets for\nany service you want,pretending to be\nclient you want.So this is pretty bad.So you really want to\nkeep this guy secure.Now, how hard is\nit to compromise?Well, ideally, it's hard.And I don't know\nof any instanceswhere the MIT KDC has actually\nbeen compromised in, I guess,20 years or so.So it's , I think, possible to\nrun this reasonably security.But presumably, the things\nyou would worry aboutare just software\nimplementation securityof the things that's listening\non these two services, right?So if there's buffer\noverflows on this guysor some other vulnerability\nlike that, that's really bad.Or if there's an SSH server\nrunning on the Kerberos KDCand someone guesses the root\npassword on that SSH server,they'll just log in and\ncopy the database over.So I think you really want\nto be careful in minimizingthe attack surface there.Maybe be very careful\nwriting the KDC code.Don't allow you to\nlog into it directly.Maybe you even worry about\nphysical security, et cetera.Absolutely.Luckily, this is actually\none of the few placeswhere you have to be\nsuper paranoid, though.Right, so the servers,\nunlike in some other systemsthat do trust all the\nmachines, the serversare actually not that important.They of course store some data.But if someone compromises a\nmail server or a print server,you can probably\nrecover reasonably well.So actually, here's an\ninteresting question.Like, suppose someone\ncompromised the mail server.What should you do to\nrecover from this attack?Like, if someone\nstole your mail,I guess that's kind\nof unfortunate.But what do you do so that the\nattacker doesn't keep accessingyour mail in the future?Yeah.STUDENT: [INAUDIBLE]PROFESSOR: Yeah, so\nin Kerberos, there'sno sort of revoke operation.But what you could\ndo is you couldchange generate a new\nkey for the mail serverand stick it in this\ndatabase over here.And then you install a new mail\nserver, give it the new key,and then some attacker that\nhas the mail server's old key", "start": 3480.0, "heat": 0.46}, {"text": "has no way of-- like, no\ninfluence at all on this mailserver now, right?On the other hand, suppose you\ndidn't change the mail server'skey, K mail.How that is that?STUDENT: [INAUDIBLE] fine.PROFESSOR: OK, so suppose\nyou didn't change the mail.You, like, install\nthe new mail server.You patch whatever bug\nthat hacker exploited.But it still has\nthe same key K mail.And maybe it's taken a day so\nall the tickets are expired.Can that hacker do anything\ninteresting in the systemanymore?Yeah.STUDENT: [INAUDIBLE]PROFESSOR: Yeah, OK, so you give\nthe new mail server the old Kmail.Is that bad?Yeah.STUDENT: This is--PROFESSOR: Sure.STUDENT: [INAUDIBLE]\nmail server.And [INAUDIBLE] mail\nserver because you canencrypt that initial ticket.PROFESSOR: Right.So K mail is actually\nsuper important.And, OK, so you're saying you\ncan decrypt all the thingsgoing on to the mail server.So suppose the client now\nconnects to the mail serverafter it's been fixed up.But the attacker\nstill knows K mailfrom the last time they\ncompromised the system.They can now decrypt\nthis ticket k mailand they can now look inside the\nticket to get the session keyand they can use that to\ndecrypt all the messages yousend, all the responses\nyou get back, and so on.So it's pretty important\nto change this key K mail.And in many ways, it's\nactually even worsethan just looking\nat the traffic.Because if the attacker\nknow this key K mail,they can synthesize new\ntickets for the mail serverwithout talking to the key DC.So suppose that I\nknow K mail and Iwant to read your mail\nfrom the mail server.I'll just make up this ticket.I'll plop down all those five\nfields in the right order.I'll generate a new key.I'll encrypt it with K mail.It'll look like the real\nthing generated by the KDC.And I'll just connect\nto the mail server.And it'll decrypt it.It'll decrypt correctly and\nthen it'll think, oh, yeah,this is some particular user.And you can read all their mail\nand you know the shared keyand so on.So it's critically important\ntoo that no one knowsthe secret key of a service.", "start": 3600.0, "heat": 0.299}, {"text": "Because otherwise, not\nonly is the trafficto the service decryptable\nand observable,but also you could impersonate\nanyone to that service.So this is actually all\npretty important in Kerberos.Makes sense?Any questions?Yeah.STUDENT: So if the attacker\nhas to [INAUDIBLE],what's stopping him from\nchanging the [INAUDIBLE] key[INAUDIBLE]?PROFESSOR: Yeah, so presumably,\nhow you'd recover-- like,ISNT would, like, call up\nthe guy that runs this KDCand say, oh man, our mail\nserver got compromised.Why don't you go and, like,\ndelete this key from thereand put in this new key instead?So you'd probably want to\nhave some out of boundsmechanism for proving that\nyou're really the mail server.Because we'll look\nat a second on how doyou change keys-- like a\npassword changing protocol,for example.And you can in general\nchange passwords in Kerberos.So if you know the\nold password, youcan change the user's password\nto a new password here.So in order to recover, you\nprobably-- like the attacker,might get your key mail,\nchange it to something else.Someone with ISNT basically has\nto go to the Accounts officeand say, hey,\nwe're hear at ISNT.Could you please change the\npassword of the mail serverfor us?And they're going to\ngenerate some new passwordthe attacker doesn't know.So yeah, otherwise, if the\nattacker knows this key K mail,there's nothing differentiating\nthe attacker from you,from the real mail\nserver operator.In fact, the attacker probably\nchanged the key so now theyknow the new thing\nand you don't.It's like you're not on\nthe mail server anymore.So absolutely, you need\nsome out of band protocolfor initially registering\nprinciples in the databaseand for changing keys if you\nforget your password or someonechanges for you and\nyou lose it as well.So there's someone\nat MIT or there'sa group of people at\nMIT that help usersregister for accounts and\nchange their passwordsby, you know, you present your\nMIT ID and say, oh, well, OK.Well, whatever\nhappened, we'll beable to change your\nkey for you then.Make sense?So it's pretty\nimportant, of course,to do that right so\nif the person thatis allowing password resets does\nthe wrong thing when checking", "start": 3720.0, "heat": 0.477}, {"text": "your MIT ID, you'll be able to\ncompromise the system as well,right?So they are sort of part\nof the trusted computingbase in Kerberos, right?Like, anyone that can go\nand muck with the databaseis pretty important\nfor security here.All right, so let's look at\nanother sort of interesting useof Kerberos, right?So you could use Kerberos to try\nto log into some remote machineover SSH.And the way this would work\nis, of course, very similarto a mail server.You'd get a ticket\nfor the SSH serverand you'd send the ticket\nalong with your SSH connection.But what if you're SSHing\ninto Athena dot dial-upand you don't have a Kerberos\nclient on your machine?You just want to log\ninto Athena dot dial-upwith your regular password.So how would Athena dial-up\nauthenticate you, then,if you're just plugging into\nthis machine with a password?But you have no password\nfor Athena dot dial-up.It's on a Kerberos server.So which should\nthe dial-up machinedo when you log into\nit with a password?Yeah.STUDENT: You can\naccess the [INAUDIBLE].PROFESSOR: Yeah, so\nthe dial-up is thengoing to basically play the\nsame protocol logging you in.So it's going to send a request.This thing, right?It's going to send a request\nto the Kerberos service asking,give me a ticket for, I\ndon't know, this user Alice.And in response, it's going to\nget back this reply encryptedwith Alice's password.And then it's going to try\nthe password you just appliedand see if it\ndecrypts correctly.And if it decrypts\ncorrectly, it'sgoing to let you log in, right?Yeah.STUDENT: You don't\neven really haveto send your key\nto the SSH server.Because it could\nrelay this back--the dot encrypted thing with KC.It could relay that back to the\nuser over the SSH connection.PROFESSOR: Potentially, yeah.Right, so this requires\nsome fancy SSH clientthat you might not have.But-- so yeah, absolutely right.If you want to do\nthis right, youprobably want to have a\nKerberos client on your machineand get a ticket\nyourself or maybeproxy it somehow\nthrough the SSH serverbut not allow the SSH\nserver to have your key.That's probably a good plan.STUDENT: [INAUDIBLE]\njust, the server could get", "start": 3840.0, "heat": 0.372}, {"text": "through this wall [INAUDIBLE]PROFESSOR: That's right.Then you might decrypt\nit and send back.OK, but in either case,\nright, all we're doing hereis someone is going to try\nto decrypt this blob with KC.And then the server is\ngoing to get this resolvedand see if it looks right.It's going to allow you in.Seem like a good plan?So, turns out this is actually\na fairly dangerous thing to doand allows you to potentially\nlog into the SSH serveras anyone.And the reason is\nthat previously,when we were talking about\na client trying to log in,the client basically\nknew that itwas trying to supply\na legitimate password,it was getting a reply from\nthe right Kerberos server,and if it can decrypt it, then\nprobably the password works outcorrectly.However, there's nothing\nhere in this protocol thatauthenticates the fact\nthat this reply is comingfrom the right Kerberos server.So if I try to log into a\nmachine by typing in a passwordand the machine sends\nout this requestand some response\ncomes back that seemsto be encrypted with\nthe password I typed in,this response might not be\nfrom the Kerberos server.So suppose I have some\nmachine I want to log into.I type a password X into it.And then the machine\nsends out this response.And before the Kerberos\nserver can respond backwith the real reply, I'll\nsend my own reply thatlooks like this real response\nencrypted with my password X.And the workstation to which I\ntry to log in or the SSH serveris going to decrypt it\nwith my fake password.It's going to look OK\nbecause this response wasgenerated by me rather than\nthe real Kerberos server.And you'll be able to\nlog in This make sense?Why does this happen?Yeah.STUDENT: [INAUDIBLE]\nthere's no authenticationfrom the Kerberos\nserver [INAUDIBLE]PROFESSOR: Right,\nyeah, so there'snothing really here that's\ntying this to the real Kerberosserver.", "start": 3960.0, "heat": 0.262}, {"text": "So the way that\nKerberos fixes thisfor remotely accessible\nmachines like Athenadot dial-up is that\nthe dial-ups themselveshave some sort of a secret key\nthat they share with the KDC.So in order to log\nyou in into a dial-upor to any workstation that\nreally cares about checkingwhether you are\nreally the right user,it's actually going\nto do two things.It's going to first log you\ninto Kerberos like this.But then just because this\nreply decrypts correctly,it's not going to trust that.It's going to try\nto get a serviceticket for itself using TGS.So the dial-up machine here\nhas its own secret key.And it logs you in\nwith this round one.Then it talks to TGS\nsaying, oh, please give mea service ticket for\nmy own principle,from the dial-up\nprinciple, for this client.Then it gets the response back.And then it checks if it can\ndecrypt the response correctly.Because it knows the\ndial-up key for this KS.And if this decrpyts,\nthat it knows, oh yeah,I must have talked to the\nright Kerberos server.Because only the\nright Kerberos serverwould have sent me this\nsecond round ticket encryptedwith my secret key K dial-up.So this is actually\npretty important.And typically,\nAthena workstationsdon't do this extra step because\nAthena workstations don'thave any secret\nkey stored on themthat's shared with the KDC.Why is this OK for Athena\nworkstations to let youlog in in this one round\ntrip and not for dial-ups?Yeah.STUDENT: If you don't have\naccess to any servicesbecause the attacker\ncouldn't forge the ticket.PROFESSOR: That's right, yeah.So there's nothing interesting\non the dial-up machine itself--sorry, on the\nworkstation itself.So workstation, whenever-- you\nhave root access on it anyway.So if you log into it with\na fake password, who cares?It's not like you'll be\nable to do anything elseoutside of your workstation.Whereas on a dial-up, things\nare much more interesting.It might be that you have\nother processes runningon the dial-up from\nother login sessions.And there, the fact that you log\nin with a particular Unix UIDis actually pretty important.And there, they really\nwant to authenticate", "start": 4080.0, "heat": 0.269}, {"text": "that you are the right entity.So that's why they do this sort\nof 2-step process for logginginto some shared\ntime-sharing machine.Make sense?All right, so the last\nthing I want to talk aboutis how do we change keys.So we sort of talked about\nit briefly here with the ideathat the mail server's\nkey might get compromised.But as a user, you\nprobably also wantto change passwords as well.Like, maybe you're thinking, oh,\nthat password is not so greatanymore.Maybe I accidentally wrote it\non a piece of paper and someonelooked at it.So you probably\nwant to change it.So the way this\nworks is actuallyat some level fairly\nstraightforward.So there's an extra interface\nto this Kerberos server.In addition to Kerberos\nand TGS, there'sthis extra service\ncalled kpassword.And the service lets you\nchange your password.And the way it works is you\nget a ticket for this servicevery much like you'd get\na ticket for the mailserver or any other service.And then you send\nyour new passwordto this kpassword service\nencrypted with your sessionkey.And then if everything checks\nout, your key in the databaseis going to be updated\nto the new key.Question.STUDENT: [INAUDIBLE]\nif there was, like,no [INAUDIBLE] they wanted to\nhave them use a [INAUDIBLE] hadto go through this.PROFESSOR: That's right.OK, yeah, OK.So this is a good point.So for changing your\npassword, rememberthat we have this whole\ngoal that if someone stealsyour ticket, it shouldn't be\ngood enough to completely takeover your account.So for this reason, the key\npassword service actuallydoesn't accept just any ticket.It accepts a ticket that you\ninitially get from the Kerberosservice with your KC.So the way this actually works\nis that inside of every ticket,in addition to all the stuff\nI showed you there, there'san extra bit that tells you\nwhich of these two thingsgave you the ticket.So if you get the ticket\nfrom this Kerberos server,the bit has one.If you get the ticket from the\nTGS server, the bit is zero,let's say.And then the kpassword service,\nin addition to everythingthat any mail server or\nfile server would do,", "start": 4200.0, "heat": 0.325}, {"text": "it also looks at the\nbit on the ticketand says, well, if you got it\nfrom Kerberos, that's good.If you got it from\nTGS, that meansthat maybe you stole\nsomeone's ticketand you didn't know their\npassword right away.So I'm not going to accept this.So this is how a key password\nensures that you can onlychange the password if you just\nknew the password immediatelyprior to this.So you never actually supply\nthe old password to kpassword.You supply that to-- well,\nyou supply that in orderto decrypt the response\nfrom the Kerberosserver for the kpassword\npassword principal.Makes sense?All right, so let's\njust actually spell outthe interactions with\nthe key password servicebecause there'll be something\na little bit interesting there.So when you're going to\nchange your password, whatthe client is going\nto do is, of course,obtain this initial\nticket from Kerberos.So it sends a message to the\nKerberos service saying hereis my client ID and I want to\ntalk to the kpassword service.And the Kerberos server is\ngoing to send a response backincluding the ticket\nbetween the clientand the kpassword service\nencrypted with a key of kpassand the shared key\nbetween KC and kpass.Makes sense?This is exactly this thing\nup here encrypted with KC.Makes sense?Everyone's runs on board?And then very much like you talk\nto a mail server, you take thisand you send it to kpassword.You say, well, here's my\nticket-- tckpass encryptedwith kpass.And in addition, you\nsend your new passwordand you encrypt this\nwith the key kcpasswith shared key for\nyour interaction.I just separated these\ntwo things out here.Make sense?So this is the thing you\nsend to the kpassword servicewith a new password encrypted\nwith the session key.", "start": 4320.0, "heat": 0.292}, {"text": "Yeah.STUDENT: But in the [INAUDIBLE]PROFESSOR: So if the\nattacker knows your password,they can change your\npassword-- absolutely.So it seems reasonable, right?Like, there's no other way to\ntell whether it's you or not.If someone walks up to an\nAthena workstation, typesin your username and\npassword, runs password,change my password to this new\nthing, they know your password?They're going to be\nable to change it.So that's totally the\nsame in almost any systemyou could imagine.This is true for Gmail probably.This is true for any system\nthat uses passwords in general.The reason that we had to talk\nto the Kerberos server insteadof the TGS server here is that\nif someone steals your ticket,then we don't want them to be\nable to change your password.So if someone corrupts an Athena\nworkstation after you log in,your password is gone from\nmemory, the ticket remains.You could, in principle,\nuse the ticketto obtain more tickets for\nthe password changing service.But the password\nchanging servicesays that's not going\nto be good enough.It's going to look\nat this tickethere-- ticket between the\nclient and the password service.And if that was\nupdated through TGS,it's going to\nreject your request.It's only going to accept it\nif it was obtained directlyfrom the Kerberos\nservice using KC.Makes sense?Question.STUDENT: So if you [INAUDIBLE]\npassword with the [INAUDIBLE]Athena, right?PROFESSOR: Yeah.STUDENT: So if I would\nsteal your private key--PROFESSOR: Yeah,\nso actually, KC isbasically equivalent\nto your password here.As far as the Kerberos\nprotocol is concerned,that don't even think\nthat you have a password.It thinks you have\na private key KC.If someone knows KC, that's\nbasically your password.So you can change\nyour key from KCto something else so you\ndon't lose this thing, yeah.Uh, yeah, question?STUDENT: [INAUDIBLE]\ninitial message [INAUDIBLE]from changing the [INAUDIBLE]PROFESSOR: Oh, you\ncan certainly geta ticket for some other\nservice or an attackercould drop this message\naltogether or corruptthis exchange.And then you're not going\nto successfully changeyour password.STUDENT: [INAUDIBLE]PROFESSOR: Yeah, so\nthe client actuallyknows exactly what service\nit wants to talk to.", "start": 4440.0, "heat": 0.265}, {"text": "So if it-- it's going\nto make sure, well,there are some messages, some\nparts of this protocol I'm notshowing that allow the\nclient to make surethey actually got the\nticket for the right thing.But yeah, so the-- sorry.Question?STUDENT: [INAUDIBLE] very easy\nto denial of service attackwhen an attacker [INAUDIBLE]\nmodifying the encrypted versionof the new password.PROFESSOR: Yeah, so there's\nactually lot of things.Because, for example, Kerberos\ndoesn't do authenticationproperly of messages--\nit just doesencryption-- you could\ntotally corrupt this blob.And--STUDENT: [INAUDIBLE]PROFESSOR: Yeah, you\ncould flip it aroundand it'll decrypt\nto something else.The service was like, oh\nyeah, that's the new password,and set it.And then you're\nsort of locked out.So it seems really unfortunate.And this is yet\nanother reason whyyou want separate encryption and\nauthentication in the protocol.There's actually an even\nbigger problem here.But actually, yeah, question?STUDENT: What's the\npoint of having a one wayfunction to [INAUDIBLE] your\npassword in KC if they'reessentially [INAUDIBLE]?PROFESSOR: Basically because\nKC is a 56-bit ds keyand your password might\nbe of different lengths.And even if it's longer\nthan 56 bits, whichis seven bites or\nseven characters,you want to use all\nthose extra bytes too.So it's mostly just to condense\nit down to a fixed width blob,yeah.But there's actually a much\nmore interesting problem here,which is that suppose\nthat I change my passwordand then I decide, OK,\nwell, I change my password.A day goes by and I'm\nthinking, oh yeah, sure.I'll tell everyone what my\nstupid old password was.Is this a good idea in Kerberos?Yeah.STUDENT: [INAUDIBLE]\nimmediately expire until the--PROFESSOR: Yeah, OK.But someone's got to wait\nfor all my tickets to expire.I wait for, like, a week.And then no tickets\nare good anymore.Can I give out my\nold password now?Yeah.STUDENT: It might take\na while to replicate.PROFESSOR: Yeah,\nsuppose the replicasare all updated,\nyeah, all the stuff.Yeah.STUDENT: [INAUDIBLE] if someone\nsaves the initial transaction[INAUDIBLE] to get,\nlike, your old passwordnow that they have\nyour new password.PROFESSOR: Yeah,\nso this is actuallysuper worrisome\nin Kerberos, whichis that-- suppose\nsome attacker was", "start": 4560.0, "heat": 0.355}, {"text": "watching all of my\nprevious password changes.They didn't know what my\npassword was or is or anything.But they're just saving these\npackets very diligently.And then a month later, I\ngo and say, oh, my passwordwas poodle or something\nsilly like this.And then they go say ah, ha, ha.I can now decrypt\nthis initial thingbecause it was encrypted\nwith your old KC.And I can get this KC\nwith pass that you shared.Then I can use this to\ndecrypt the new passwordyou sent to the KDC.And even if you change\nthe password again,I can decrypt the\nnext round as well.And you can just keep going\nand get the newest password.So in this particular password,\nchanging protocol, if you everdisclose an old\npassword, then someonecould sort of unzip this whole\nchain of encrypted messagesand get your newest\npassword as well.This is actually very\ntroublesome in the design.Yeah.STUDENT: Doesn't the later\nversion of Kerberos [INAUDIBLE]PROFESSOR: Absolutely, yes.So there's actually\na solution to thisthat's not sort of fundamental.And this is\nsomething they didn'trealize in Kerberos version 4.There's actually this nice\nmechanism called Diffie-Hellmanthat I'll just sketch\nout in like one minutejust so that you guys know\nwhen to use it or et cetera.But it's basically a solution\nfor this kind of a problemwhere you want to stop this\nunzipping from happening.So what happens in\nthe Kerberos version5 password changing protocol\nis that actually youwant to establish a new secret\nthat will not be apparentif you happen to decrypt all\nthe messages on the wire.And the way this works\nis-- this is like some maththat you don't have\nto fully understand.But the client some random value\nX. And the kpassword server isgoing to pick some\nother random value Y.And what they send to each\nother are exponentiationsof these values.So the client sends\nG to the power Xto the server and the server\nsends G to the power Yback to the client.And it turns out\nthat mathematically,what we can do now is the\nclient can take G to the Y,raise it to X, and get\nthis value G to the XY.The server can take G to the\nX, raise it to the power Y,and get G to the XY as well.", "start": 4680.0, "heat": 0.285}, {"text": "They can now use this\nsecret value G to the XYto encrypt their\nsubsequent messages,including the new password.So you send the new password\nencrypted with this value Gto the XY, roughly speaking.But for some\nmathematical reasonsthat we're not going\nto cover right now,it turns out to be super\ndifficult for someone that justgets G to the X and G to the Y\nby examining your packets laterfrom figuring out\nwhat was G to the XY.So this is something called\nthe discrete log problem.Yeah, question?STUDENT: But they have to\n[INAUDIBLE] G at some point.PROFESSOR: Yeah, yeah.So G is some parameter\nyou could sort of sendat the beginning of a protocol\nor it could be just cookedinto Kerberos.It turns out to be\nrelatively less important.All right, so anyway, use\nDiffie-Hellman because thisis called-- well, what you\nshould Google for if you'rebuilding a protocol like this\nis this Diffie-Hellman keyexchange protocol.And Kerberos 5 actually\ndoes this correctly.But this is something\nto really watch outfor if you're designing any\nkind of new protocol yourself.All right, so that's\nit for Kerberos.Let's talk about SSL on Monday.", "start": 4800.0, "heat": 0.348}]