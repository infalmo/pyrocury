[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or to\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.eduPROFESSOR: In this\nclass, this semester,the other co-lecturer\nis going to beJames Mickens, who is a visiting\nprofessor from MicrosoftResearch.He'll lecture on some other\ntopics like web securitylater on.But we'll decide later what's\ngoing on exactly, in termsof the lecture split up.We also have four TAs this year,\nStephen, Webb, [INAUDIBLE],and James.And hopefully you'll meet them\nin office hours over the yearif you need help.So the plan for this\nclass is to understandhow to build secure systems,\nwhy computer systems sometimesare insecure and how we\ncan make them better,and what goes wrong.And in order to do this, there's\nnot really a great textbookabout this topic.So instead, what\nwe're going to dois, each lecture\nother than this one isgoing to be focused around some\nresearch, typically a paper,that we'll assign on\nthe website and you guysshould read ahead of time.And there are some\nquestion that youshould answer in the submission\nsystem about the paper.And submit your own question\nby 10:00 PM before the lectureday.And then when you\ncome to lecture,we'll actually discuss\nthe paper, figure out,what is the system?What problem does it solve?When does it work?When does it not work?Are these ideas any\ngood in other cases?Et cetera.And hopefully, through\nthese case studies,we'll get some appreciation\nof how do we actually buildsystems that are secure.And we have some preliminary\nschedule up on the website.If there's other topics you guys\nare particularly interested in,or if there's particular\npapers you're excited about,just send us email and\nwe'll see if we canfit them in or do something.We're pretty flexible.So if there's\nanything that you'd", "start": 0.0, "heat": 0.1}, {"text": "like to hear more\nabout, just let us know.And in a similar vein, if\nyou ever have a questionor if there's some mistake,\njust interrupt and askus what's going on\nin lecture, anytime.Security is, in many ways,\nall about the detailsand getting everything right.And I will inevitably\nmake mistakes.So if something\ndoesn't seem right,there's a good chance it's not.And you should just\ninterrupt and ask.And we'll figure\nout what's going onand what's the right\nway to do things.And I guess in terms of\nthe class organization,the other large\npart of the class,in addition to\nlectures, is goingto be a series of\nlab assignments.The first one is already\nposted on the website.And these lab\nassignments will helpyou go through understanding\nthe different range of securityproblems and how do you prevent\nthem in a simple web server.So in lab one, which\nis out right now,you'll actually\ntake a web serverthat we give you and find ways\nto exploit buffer overflowvulnerabilities in it and\ntake control of this websiteby just sending it\ncarefully-crafted requestsand packets.And in other labs,\nyou'll look at waysto defend the web server,\nto find bugs in the code,to write worms that\nrun in the user'sbrowser, and other kinds of\ninteresting security problems.One thing that\nsurprises many studentsis that every lab uses\na different language.So lab one is all\nabout C and Assembly.Lab two involves a\nlot of Python coding.Lab three will be\nsomething else.Lab five will be JavaScript.And so on.This is sort of inevitable.And I sort of\napologize ahead of timethat you're going\nto have to learnall these languages if you\nhaven't seen them already.In some ways it's useful,\nbecause the real worldis like this.All the systems are\ncomplicated and composedof different parts.And in the long run,\nit'll be useful for you,for your moral\ncharacter or somethinglike that, to learn this stuff.But it will take\nsome preparation,especially if you haven't\nseen these languages before.It might be helpful\nto start early.In particular, lab\none is going to rely", "start": 120.0, "heat": 0.1}, {"text": "on a lot of subtle\ndetails of C and Assemblycode that we don't really\nteach in other classeshere in as much detail.So it's probably a good\nidea to start early.And we'll try to get the TAs\nto hold office hours next weekwhere we'll do some sort\nof a tutorial sessionwhere we can help you get\nstarted with understanding whata binary program looks\nlike, how to disassemble it,how to figure out what's\non the stack, and so on.All right.And I guess the one other\nthing, we're actuallyvideotaping lectures this year.So you might be able\nto watch these online.We'll post them as soon\nas we get them ourselvesfrom the video people.And the last bit\nof administriviais you should, if you\nhave questions online,we're using Piazza,\nso I'm sure you'veused this in other classes.All right.So before we dive into security,\nI need to tell you one thing.There is a sort of rules\nthat MIT has for accessingMIT's network when you're,\nespecially, doing securityresearch or playing\nwith security problems,you should be aware that not\neverything you can technicallydo is legal.And there's many things that you\nwill learn in this class thatare technically possible.We'll understand how systems\ncan be broken or compromised.Doesn't mean you should go\nout and do this everywhere.And there's this link\nin the lecture noteswe'll post that has some rules\nthat are good guidelines.But in general, if\nyou're in doubt,ask one of the lecturers or a\nTA as to what you should do.And hopefully it's not too\npuzzling, what's going on.All right.So any questions about\nall this administriviabefore we dive in?Feel free to ask questions.OK.So what is security?So we'll start with\nsome basic stuff today.And we'll look at just\nsome general examplesof why security is hard\nand what it means to tryto build a secure system.Because there's\nnot really a paper,this will not have sort of deep\nintellectual content, maybe,but it'll give you some\nbackground and context for how", "start": 240.0, "heat": 0.1}, {"text": "to think about secure systems.So security, in\ngeneral, is all aboutachieving some goal when\nthere is an adversary present.So think of it as there's some\nbad guy out there that wantsto make sure you don't succeed.They want to steal your files.They want to delete your\nentire hard drive contents.They want to make\nsure nothing worksand your phone doesn't connect,\nall these things, right?And a secure system is\none that can actuallydo something, regardless\nof what the bad guy istrying to do to you.So it's kind of cool that we\ncan actually potentially buildsystems that are\nresilient to a whole rangeof bad guys,\nadversaries, attackers,whatever you want to call them.And we can still build\ncomputer systems thatallow us to get our work done.And the general way to\nthink about securityis sort of break it\nup into three parts.One part is roughly\nthe policy that youwant your system to enforce.This is roughly the goal\nthat you want to achieve.Like well, maybe,\nonly I should beable to read the\ngrades file for 6.858.Or maybe the TAs as well,\nand all the co-lecturers,et cetera.But there is some statement\nabout what I want my systemto be able to do.And then, if you\nwant sort of thinkabout what kinds of\npolicies you might write,typical ones have to do with\neither confidentiality of data,so the grades file is only\naccessible to the 6.858 coursestaff.Another example of\na security policyhas something to\ndo with integrity.For example, only\nthe course staffcan also modify the grades file.Or only the course staff\ncan upload the final gradesto the registrar's office.That'll be great.Then you can also think about\nthings like availability.So for example, a website\nshould be available,even if the bad guys try\nto take it down and mountsome sort of a DOS-- Denial\nof Service-- attack on it.So this is all well and good.So these are the policies\nthat we might actually", "start": 360.0, "heat": 0.1}, {"text": "care about from a system.But because it's security,\nthere's a bad guy involved.We need to understand,\nwhat are we thinkingthe bad guy is going to do?And this is typically what\nwe call a threat model.And this is basically\njust a set of assumptionsabout the bad guy or adversary.And it's important to have\nsome sort of assumptionsabout the bad guy because,\nif the bad guy is omnipresentand is everywhere at once and\nyou can do anything they want,it's going to be hard to achieve\nsome semblance of security.So for example,\nyou probably wantto assume the bad guy doesn't\nexactly know your password,or they don't actually have\nphysical access to your phoneand your keys and your laptop.Otherwise, it's going to be hard\nto make some sort of progressin this game.And turns out that while\nthis is actually quite trickyto come up with, but I guess\none general rule is it'smuch better err on\nthe side of cautionand being conservative in\npicking your threat model,because bad guy might\nalways surprise youin terms of what they might\nbe able to do in practice.And finally, in order to\nachieve security, in orderto achieve our goal under\nthe set of assumptions,we're going to look\nat some mechanism.And this is the, basically,\nsoftware or hardwareor whatever part\nof system design,implementation,\net cetera, that'sgoing to try to make sure\nour policy is followedas long as the bad guy\nfollows the threat model.So the end result\nis that, as longas our threat model was\ncorrect, hopefully we'llsatisfy our policy.And it has to be the case that\nthe mechanism doesn't screw up.Make sense?Fairly high level\nstory about howto think about\nthis kind of stuff.So why is this so hard, right?It seems like a simple plan.You write down\nthese three things,and you're off and running.But in practice, as you, I'm\nsure, have seen in the world,", "start": 480.0, "heat": 0.1}, {"text": "computer systems are\nalmost always compromisedin some way or another.And break ins are\npretty commonplace.And the big reason\nwhy security tendsto be a difficult problem\nis because what we have hereis sort of, this will be\nfamiliar to those of youtook 6.033, this\nis a negative goal,meaning that we have to make\nsure our security policy isfollowed regardless of\nwhat the attacker can do.So just by contrast, if you\nwant to build a file system,and you want to make sure that\nmy TAs can access the gradesfile, that's pretty easy.I just ask them, hey, can\nyou guys test and see?Can you access the grades file?And if they all can\naccess it, done.The system works.But if I want to say that\nno one other than the TAscan access the grades file,\nthis is a much harder problemto solve, because now\nI have to figure outwhat could all these non TA\npeople in the world to tryto get my grades file, right?They could try to just\nopen it and read it.Maybe my file system\nwill disallow it.But they might try all\nkinds of other attacks,like guessing the\npassword for the TAsor stealing the TAs laptops\nor breaking into the roomor who knows, right?This is all stuff that\nwe have to really putinto our threat model.Probably for this class,\nI'm not that concerned aboutthe grades file to worry about\nthese guys' laptops beingstolen from their dorm room.Although maybe I should be.I don't know.It's hard to tell, right?And as a result,\nthis security gameis often not so\nclear cut as to whatthe right set of\nassumptions to make is.And it's only after the\nfact that you often realize,well should have\nthought of that.All right.And sort of, as a\nresult, this is very muchan iterative process.And the thing you end up\nrealizing at every iterationis, well, here's the\nweakest link into my system.Maybe I got the\nthreat model wrong.Maybe my mechanism had some bugs\nin it because it's a softwareand it's going to\nbe large systems.They'll have lots of bugs.And you sort of fix them up.You change your\nthreat model a bit.And you iterate and try\nto design a new system,", "start": 600.0, "heat": 0.1}, {"text": "and hopefully,\nmake things better.So one possible interpretation\nof this class-- well,one danger-- is that you come\naway thinking, man, everythingis just broken.Nothing works.We should just give up\nand stop using computers.And this is one\npossible interpretation.But it's probably not\nquite the right one.The reason this is\ngoing to come upor you're going\nto think this wayis because,\nthroughout this class,we're going to look at all\nthese different systems,and we're going to sort\nof push them to the edge.We're going to see, OK,\nwell, what if we do this?Is it going to break?What if we do that?Is it going to break then?And inevitably,\nevery system is goingto have some sort\nof a breaking point.And we'll figure out, oh hey.This system, we can break\nit in if we push this way.And this system doesn't work\nunder these set of assumptions.And it's inevitable\nthat every systemwill have a breaking point.But that doesn't mean that\nevery system is worthless.It just means you\nhave to know whento use every system design.And it's sort of useful to\ndo this pushing exerciseto find the\nweaknesses so that youknow when certain ideas work,\nwhen certain ideas are notapplicable.And in reality, this is a little\nmore fuzzy boundary, right?The more secure you make\nyour system, the less likelyyou'll have some embarrassing\nstory on the front page of NewYork Times saying,\nyour start up companyleaked a million people's\nsocial security numbers.And then you pay less money\nto recover from that disaster.And I guess one sort of actually\npositive note on securityis that, in many ways, security\nenables cool things that youcouldn't do before, because\nsecurity, especiallymechanisms, that\nallow us to protectagainst certain classes of\nattacks, are pretty powerful.As one example, the browser used\nto be fairly boring in termsof what you could do with it.You could just view\nweb pages, mayberun some JavaScript code in it.But now there's all\nthese cool mechanismswe'll learn about\nin a couple of weeksthat allow you to run arbitrary\nx86 native code in the webbrowser and make\nsure it doesn't doanything funny to your machine.", "start": 720.0, "heat": 0.1}, {"text": "And it can send-- and\nthere's a technique or systemcalled Native Client\nfrom Google that actuallyallows us to do this securely.And before, in order to run some\nnative game on your machine,you'd have download and install\nit, click on lot's of dialogueboxes, say yes, I allow this.But now, you can just\nrun it in a browser,no clicking required.It just runs.And the reason it's\nso easy and powerfulis that our security mechanism\ncan sandbox this programand not have to assume anything\nabout the user choosingthe right game and not\nsome malicious game to playin their computer, or\nsome other program to run.So in many ways, good\nsecurity mechanismsare going to enable constructing\ncool new systems that weren'tpossible to construct before.All right.Make sense?Any questions about this story?All right.So I guess in the\nrest of the lecture,I want to go through a bunch\nof different examples of howsecurity goes wrong.So, so far, we've seen\nhow you can think of it.But inevitably, it's\nuseful to see examplesof what not to do so that you\ncan have a better mindset whenyou're approaching\nsecurity problems.And in this sort of breakdown\nof a security system,pretty much every one of\nthese three things goes wrong.In practice, people\nget the policy wrong,people get the\nthreat model wrong,and people get the\nmechanism wrong.And let's, I guess, start\nwith policies and examplesof how you can screw\nup a system's policy.Maybe the cleanest or sort\nof simplest example of thisare account recovery questions.So typically, when you\nsign into a website,you provide a password.But what happens if\nyou lose your password?Some sites will send\nyou email if youlose your password with a\nlink to reset your password.So it's easy enough, if you\nhave another email address.But what if this is\nyour email provider?So at least, several\nyears ago, Yahoo", "start": 840.0, "heat": 0.1}, {"text": "hosted email, webmail, for\nanyone on the internet.And when you forgot\nyour Yahoo password,they couldn't really\nsend you emailbecause you couldn't get it.So instead, they\nhad you registera couple of questions with them\nthat hopefully only you know.And if you forget your password,\nyou can click on a linkand say, well, here's the\nanswers to my questions.Let me have my password again.And what turns out to\nbe the case is-- well,some people failed to realize is\nthat this changes your policy,because before, the\npolicy of the systemis people that can log\nin are the people thatknow the password.And when you introduce\nthese recovery questions,the policy becomes,\nwell, you can log inif you know either the password\nor those security questions.So it strictly weakens the\nsecurity of your system.And many people have actually\ntaken advantage of this.One sort of well known example\nis, I think a couple years ago,Sarah Palin had an\nemail account at Yahoo.And her recovery questions\nwere things like, well,where'd you go to school?What was your friend's name?What's your birthday?Et cetera.These were all things written\non her Wikipedia page.And as a result, someone\ncan quite easily,and someone did, actually, get\ninto her Yahoo email accountjust by looking up on Wikipedia\nwhat her high school wasand what her birthday was.So you really have\nto think carefullyabout the implications\nof different securitypolicies you're making here.Perhaps a more intricate and,\nmaybe, interesting example,is what happens when you have\nmultiple systems that startinteracting with one another.So there's this nice story\nabout a guy called Mat Honan.Maybe you read this\nstory a year or two ago.He's a editor at this\nwired.com magazine.And had a bit of a problem.Someone basically got\ninto his Gmail accountand did lots of bad things.But how did they do it, right?So it's kind of interesting.So all parties in\nthis story seemto be doing reasonable things.But we'll see how they add\nup to something unfortunate.", "start": 960.0, "heat": 0.159}, {"text": "So we have Gmail.And Gmail lets you\nreset your passwordif you forget, as do pretty\nmuch every other system.And the way you do\na reset at Gmailis you send them\na reset request.And what they say\nis, well, you weren'tgoing to do this recovery\nquestions, at leastnot for this guy.What they do is they send you a\nrecovery link to a backup emailaddress, or some other\nemail address that you have.And helpful, they actually\nprint the email address for you.So for this guy's\naccount, someonewent and asked Gmail\nto reset the password.And they said, well, yeah.Sure.We just sent the recovery\nlink to this email,foo@me.com, which was\nsome Apple email service.OK, but the bad guy doesn't\nhave access to me.com, either.But they want to get\nthis password resetlink to get access to Gmail.Well, the way things\nworked was that,in Apple's case,\nthis me.com site,allowed you to actually reset\nyour password if you knowyour billing address and the\nlast four digits of your creditcard number.So it's still not clear how\nyou're going to get thisguy's-- well, home address,\nmaybe you could look it upsomewhere.This guy was a well\nknown person at the time.But where do you get the last\nfour digits of his credit cardnumber?Well, not clear, but\nlet's keep going further.So you need to send these\nthings to me.com to get accessto his email account there.Well, it turns out this guy\nhad an account at Amazon, whichis another party in this story.Amazon really wants\nyou to buy things.And as a result, they actually\nhave a fairly elaborate accountmanagement system.And in particular, because they\nreally want you to buy stuff,they don't require\nyou to sign inin order to purchase some\nitem with a credit card.So I can actually go on Amazon,\nor at least at the time,I was able to go on Amazon\nand say, well, I'm this user.And I want to buy this\npack of toothbrushes.And if I wanted to use\nthe saved credit card", "start": 1080.0, "heat": 0.169}, {"text": "number in the guy's account, I\nshouldn't be able to do this.But if I just was providing a\nnew credit card, what Amazonwould do is, they can\nactually add a new creditcard to some guy's account.So that seems not\ntoo bad, right?I'm basically\nordering toothbrushesthrough one of your\nAmazon accounts.But it's not your\ncredit card anyway.It's just my credit\ncard number being used.So it's not clear how\nthings go wrong yet.But Amazon had\nanother interface.All these are\ncomplicated systems.And Amazon had an interface\nfor password reset.And in order to reset\na password in Amazon,what you had to provide is just\none of the user's credit cardnumbers.So I can order stuff and\nadd a credit card numberto your account.And then I can say, hey, I\nwant to reset my password.This is one of my\ncredit card numbers.And this, in fact, worked.So this is where the bad guy\ngot a hold of this guy's, Mat's,Amazon account.But OK.How do you fish out\nthe credit card numberfor resetting Apple's site?Well, Amazon was\nactually very careful.Even if you break into\nsomeone's Amazon account,it will not print you\nthe saved credit cardnumbers from that person.But it will show the\nlast four digits.Just so you know which credit\ncard you're talking about.So you can list all the credit\ncards, other than the oneyou added.You can then go and\nbreak into me.com.You can click on this\nlink and get accessto the guy's Gmail account.This is all very subtle stuff.And in isolation,\neach system seemsto be doing somewhat\nsensible things.But it's actually\nquite hard to reasonabout these vulnerabilities\nand weaknessesunless you have this whole\npicture explained to youand you've sort of put\nall the pieces together.So this is actually\nfairly tricky stuff.And unfortunately, well,\nmuch like for every oneof these three categories, the\nanswer for how to avoid thisis often think hard\nand be careful.I guess the one general plan\nis, be conservative in termsof what you set\nyour policy to be,to maybe not depend on things\nother sites might reveal.", "start": 1200.0, "heat": 0.175}, {"text": "So well, I'm not sure if any\nreally great advice wouldhave prevented this problem.But now you know.And now you'll make\nother mistakes.There's many other\nexamples of policiesgoing wrong and allowing a\nsystem to be compromised.That's interesting enough.But let's look at how people\nmight screw up threat models.So let me turn off\nthis blue square.OK.So what are examples of\nthreat models that go wrong?Well, probably a big one in\npractice is human factors.So we often make\nassumptions about whatpeople will do in\na system, like theywill pick a good,\nstrong password,or they will not click\non random websitesthat they get through email\nand enter their password there.So these are-- well, as\nyou probably suspect,and in practice,\nhappens to be the case,these are not good\nassumptions in all cases.And people pick bad passwords.And people will click\non random links.And people will\nenter their passwordon sites that are actually\nnot the right site at all.And they will not be\npaying a lot of attention.So you probably don't want\nto have threat models thatmake very strong\nassumptions about whathumans will do because\ninevitably, somethingwill go wrong.Make sense?Any questions?All right.Another sort of good thing\nto watch out in threat modelsis that they sometimes\nchange over time.Or whether something is\na good assumption or notchanges over time.One example of this is actually\nat MIT in the mid '90s-- mid'80s, actually--\nProject Athena developedthis system called Kerberos.And we'll read about this in a\ncouple of weeks in this class.And at the time, they were sort\nof figuring out, well, Kerberosis going to be based\non cryptography.So we need to pick\nsome size keysto make sure they're\nnot going to be", "start": 1320.0, "heat": 0.184}, {"text": "guessed by arbitrary people.And they said, OK.Well you know, 56-bit\nkeys, at the time,for this cypher called DES,\nseemed like a plausible size.Maybe not great, but certainly\nnot entirely unreasonable.And this was in the mid '80s.But then you know, this system\ngot popular and got used a lot.MIT still uses it.And they never really went\nback to seriously revisitthis assumption.And then, a couple years ago,\na group of 6.858 studentsfigured out that actually, yeah,\nyou can just break this, right?It's easy enough to enumerate\nall the 256 keys these days.Computers are so fast,\nyou can just do it.And as a result,\nthey were able to,with the help of some\nhardware from a particular webservice-- we'll have some links\nthe lecture notes-- they wereable to get, basically, anyone's\nKerberos account key in roughlya day.And so this assumption\nwas good in the mid 1980s.No longer a good\nassumption today.So you really have to\nmake sure your assumptionssort of keep up with the times.Maybe a more timely example\nis, if your adversary--or if you're worried\nabout government attacks,you might realize that you\nshouldn't trust hardware eventhese days, right?There was all these\nrevelations about whatthe NSA is capable of doing.And they have\nhardware back doorsthat they can insert\ninto computers.And maybe up until a couple\nyears ago, well, who knows?I guess we didn't\nknow about this stuff.So maybe it was a\nreasonable assumptionto assume your\nlaptop is not goingto be compromised physically,\nthe hardware itself.But now you know.Actually, if you're worried\nabout the governmentbeing after you, you probably\nhave a much harder problemto deal with because\nyour laptop mightbe compromised\nphysically, regardlessof what you install in it.So we really have to be\ncareful with your threat modeland really sort of\nbalance it against whoyou think is out to get you.I think it's going to be a very\nexpensive proposition if you'regoing to try to protect\nyourself from the NSA, really.On the other hand, if you're\njust protecting yourselffrom random other\nstudents that are,I don't know, snooping around\nin your Athena home directory", "start": 1440.0, "heat": 0.215}, {"text": "or whatnot, maybe you\ndon't have to worryabout this stuff as much.So it's really a balancing game\nand picking the right threatmodel.Another example of a bad threat\nmodel shows up in the waysecure websites these days\ncheck certificates of a websitethat you're connecting to.So in this SSL protocol or TLS,\nwhen you connect to a websiteand it says HTTPS-- we'll\ntalk much more about thisin later lectures--\nbut what happensis that the site you're\nconnecting to presents youa certificate signed by one\nof the certificate authoritiesout there that attests\nthat, yep, this keybelongs to Amazon.com.And architecturally,\nthe sort of mistakeor the bad threat model\nthat these guys assumedis that all these CAs are\ngoing to be trustworthy.They will never make a mistake.And in fact, the\nway system worksis that there's hundreds\nof these CAs out there.The Indian postal authority,\nI think, has a CA.The Chinese government has a CA.Lots of entities are certificate\nauthorities in this design.And any of them can\nmake a certificatefor any host name\nor a domain name.And as a result, what\nhappens if you're a bad guy,if you want to compromise Gmail\nor if you want to impersonateGmail's website, you\njust have to compromiseone of these\ncertificate authorities.And it turns out the\nweakest link is probablysome poorly run authority\nsomewhere in some,you know, not particularly\nup to date country.Who knows, right?And as a result, it's\nprobably a bad assumptionto build a system--\nor it's a bad ideato build a system\naround the assumptionthat you'll manage to\nkeep all 300 certificateauthorities spread out around\nthe globe perfectly secure.But yet, that's the\nassumption underpinningthe security mechanism of\ntoday's SSL protocol usedby web browsers.And there's sort of many\nother, I guess, examplesthat are things you might\nnot have thought of.Another sort of amusing example\nfrom the 1980s was DARPA.", "start": 1560.0, "heat": 0.1}, {"text": "This defense\nagency, at the time,really wanted to build\nsecure operating systems.And they actually\nwent so far as to geta bunch of universities\nand researchersto build secure OS prototypes.And then they actually\ngot a red team,like a team of bad guys\npretending to be the attackers,and told them, well, go break\ninto these secure operatingsystems any way you can.We actually want to\nknow, is it secure?And it's kind of amusing,\nsome of the surprising waysthey compromised the systems.One was that there\nwas this OS researchteam that seemed to have\na perfectly secure OS,but it got compromised.And the way it happened is that\nthe server in which the sourcecode of the operating\nsystem was storedwas some development\nmachine in someone's officethat wasn't secured at all.But that had all\nthe source code.So the bad guys broke\ninto that server.It was not protected very well.Changed the source code\nof the operating systemto introduce a back door.And then, when the researchers\nbuilt their operating systems,well, it had this back door.And the bad guys were\nable to break in.So you really have to think\nabout all the possible sortof assumptions\nyou're making aboutwhere your software\nis coming from,about how the bad\nguy can get in,in order to make sure your\nsystem is really secure.And there's many other examples\nin lecture notes, if you want.So I'm using anecdotes.You can page through those.Probably the most pervasive\nproblem that shows up,of course, is in\nmechanisms, though.And in part, it's\nbecause mechanismsare the most complicated\npart of the story.It's the entirety of all\nthe software and hardwareand all that sort\nof system componentsthat make up what is trying to\nenforce your security policy.And there's no end of ways\nin which mechanisms can fail.And, partly as a result,\nmuch of this classwill focus pretty\nheavily on mechanismsand how do you make\nmechanisms that are secure,", "start": 1680.0, "heat": 0.1}, {"text": "that provide correct enforcement\nof security policies.And we'll talk about threat\nmodels and policies as well.But turns out it's much\neasier to make clean,sort of crisp statements\nabout mechanisms and waysthey work and don't work, as\nopposed to policies and threatmodels which, really,\nyou have to figure outhow to fit them into\na particular contextwhere you're using a system.So let's look at some examples\nof, I guess, mechanism bugs.One that you might have heard\nin the last couple of dayswas a problem in the security\nmechanism in Apple's cloudinfrastructure called iCloud.Well actually, any one\nof you that has an iPhonemight be using this\niCloud service.They basically provide\nstorage for filesand let you find your iPhone\nif you lose it, and probablylots of other useful features.And I think it's some relative\nof this me.com servicethat was implicated in this\nscheme a couple years back.And the problem that\nsomeone discoveredin this iCloud\nservice is that theydidn't enforce the same sort\nof mechanism at all interfaces.OK, so what does\niCloud look like?Well, it basically provides lots\nof services for the same sortof set of accounts.So maybe you have your\nfile storage on iCloud.Maybe you have\nyour photo sharing.Maybe you have other interfaces.And one of the\ninterfaces into iCloud--these are all sort\nof at different APIsthat they provide-- was this\nfeature to find my iPhone,I think.And all these interfaces\nwant to make surethat you are the right user,\nyou're authenticated correctly.And unfortunately,\nthe developersall this iCloud system, you know\nit's a giant piece of software.I'm sure lots of\ndevelopers worked on this.But on this\nparticular interface,the find my iPhone\ninterface, whenyou tried to log in with\na username and password,they didn't keep track of how\nmany times you tried to log in.", "start": 1800.0, "heat": 0.1}, {"text": "And the reason is important is\nthat, as I mentioned earlier,humans are not that great\nat picking good passwords.So actually building a system\nthat authenticates userswith passwords is pretty tricky.We'll actually read a whole\npaper about this later on.But one good strategy\nis, there's probablya million passwords out\nthere that will accountfor 50% percent of accounts.So if you can guess,\nmake a million attemptsat someone's\naccount, then there'sa good chance you'll get\ntheir password because peopleactually pick\npredictable passwords.And one way to\ntry to defeat thisis to make sure that\nyour system doesn'tallow an arbitrary\nnumber of attemptsto log in to an account.Maybe after three\nor 10 tries, youshould say, well,\nyou've had enough tries.Time out.You can try again in 10\nminutes or in an hour.And this way you really\nslow down the attacker.So they can only make a\nhandful of guesses a day,instead of millions of guesses.And as a result, even if\nyou have not the greatestof passwords, it's going to\nbe pretty hard for someoneto guess it.What would happen is that iCloud\nhad this password guessingprevention or, basically,\nback off, on some interfaces,like if you tried to log\nin through other interfacesand you failed 10 times,\nit would say, well, sorry.You have to wait\nuntil you try again.But on this find my\niPhone interface,they forget this check.That's probably, you\nknow, some guy justforgot to call this\nfunction on this API.But the result is that, for\nthe same set of accounts,a bad guy would be able\nto now guess your passwordthrough this interface at\nmillions of attempts per dayeasily, because this is just\nlimited up to how fast theycan send packets to\nthis iCloud thing.And they can probably\nguess your passwordwith pretty good accuracy, or\nwith pretty good success rate,after making many guesses.And this led to some\nunfortunate break ins.And people's confidential\ndata got stolenfrom this iCloud service.So this is sort of an example\nof you had the right policy.Only the user and\nthe right password", "start": 1920.0, "heat": 0.1}, {"text": "would get you\naccess to the files.You even had the\nright threat modelthat, well, the bad guy might\nbe able to guess the password.So we'll have to break limit\nthe number of guess attempts.But he just screwed up, like\nthe mechanism had a bug in it.He just forgot to enforce this\nright policy and mechanismat some interface.And this shows up again\nand again in systems,where just made a mistake and\nit has pretty drastic effectson the security of\nthe overall system.This make sense?Any questions so far?All right.OK.So another example-- this\nis sort of an example of youforget to check for\npassword guessing attempts.There's many other\nthings you can forget.You could forget to check for\naccess control altogether.So one example is, Citibank\nhad a website-- actually, stillhas a website that allows you\nto look at your credit cardaccount information.So if you have a credit\ncard with Citibank,you go to this\nwebsite, it tells you,yeah, you have this credit card.Here's all the charges,\nall this great stuff.And the workflow a couple\nof years ago was that you goto some site, you provide a\nlog in username and password,and you get redirected\nto another URL,which is something like, I\ndon't know, I'm guessing,but basically like\nciti.com/account?id= you know,whatever, one two three four.And it turns out that some\nguy figured out, well,if you change this\nnumber, you justget someone else's account.And it's not clear quite\nhow to think of this.One possibility is that these\nguys were just thinking right,but they, again, forgot to\ncheck a function in this accountpage that, not only do I\nhave a valid ID number,but it's also the ID\nnumber of the guy that'scurrently logged in.It's an important check to me.But it's easy to forget.Another thing is, maybe\nthese guys were thinking,no, no one could hit URLs.Maybe they had a bad\nthreat model, right?Maybe they're\nthinking, the URL--", "start": 2040.0, "heat": 0.102}, {"text": "if I don't print this URL,\nno one can click on it.It's like a bad threat model.So maybe that's-- well, it's\nhard to tell exactly what wentwrong.But anyway, these\nmistakes do happen.And they show up a lot.So easy to have\nsmall, seemingly, bugsin your mechanism lead to\npretty unfortunate consequences.Another example that's not\nso much in missing checksis a problem that\nshowed up on Androidphones a couple of months ago.Maybe I'll use this\nboard over here.So the problem was related to\nBitcoin, which is this-- well,I'm sure you've heard--\nthis electronic currencysystem that's pretty\npopular these days.And the way that Bitcoin\nworks, at a very high level,is that your balance\nof Bitcoins isassociated with a private key.And if you have\nsomeone's private keyyou can, of course,\nspend their Bitcoins.So the security of Bitcoin\nrelies quite heavilyon no one else knowing\nyour private key.It's kind of like a password,\nexcept it's even moreimportant, because people can\nprobably make lots of guessesat your private key.And there's no real server\nthat's checking your key.It's just cryptography.So any machine can try\nto make lots of guessesat your private key.And if they guess it, then\nthey can transfer your Bitcoinsto someone else.And as a result, it's\ncritically importantthat you generate\ngood, random keysthat no one else can guess.And there are people\nusing Bitcoin on Android.And the Android applications\nfor Bitcoin were getting randomvalues for these keys using this\nJava API called SecureRandom(),which sounds great, but as\npeople figured out, well, OK.So what it is, right, it doesn't\nreally get real random numbers.Inside of it, there's\nthis construction", "start": 2160.0, "heat": 0.113}, {"text": "called Pseudorandom\nNumber Generator,or PRNG that, given\na particular seedvalue, like you get\nmaybe a couple of hundredbits of randomness and you\nshove it into this PRNG,you can keep asking it for more\nrandomness and sort of stretchthese random bits into as\nmany random bits as you want.So you see them\ninitially, and then youcan generate as many\nrandom bits as you want.And for various cryptographic\nreasons I won't go into here,it actually works.If you give it a couple of\nhundred really good random bitsinitially, it's going to\nbe very hard for anyoneto predict what the pseudorandom\nvalues it's generating are.But the problem is\nthat this Java libraryhad a small bug in it.In some set of\ncircumstances, it forgotto initialize the\nPRNG with a seed,so it was just all zeros, which\nmeans that everyone could justfigure out what your\nrandom numbers were.If they start with\nzeros, they'llproduce the same\nrandom numbers as you,which means they'll produce\nthe same private key as you.So they can just generate\nthe same private keyand transfer your Bitcoins.So this is, again, a\nsmall or not small bug,depending on, I\nguess, who is asking.But nonetheless, right?Another example of small\nprogramming mistakesleading to pretty\ncatastrophic results.Lot's of people got their\nBitcoin balances stolenbecause of this weakness.Of course, the fix is\npretty simple at some level.You change the\nJava implementationof SecureRandom() to always\nseed this PRNG with random inputbits.And then, hopefully,\nyou're in good shape.But still, that's yet another\nexample of mechanism failure.Yeah?AUDIENCE: Just to be clear,\nis this a different attackfrom the DSA\nsignature randomness?PROFESSOR: Well yeah.So the actual problem\nis a little bit morecomplicated, as\nyou're hinting at.The problem is, even\nif you didn't generateyour key on the Android\ndevice in the first place,the particular signature\nscheme used by Bitcoinassumes that every time you\ngenerate a new signaturewith that key, you\nuse a fresh, what's", "start": 2280.0, "heat": 0.1}, {"text": "called a nonce, for\ngenerating that signature.And if you ever generate two\nsignatures with the same nonce,then someone can figure\nout what your key is.The story is pretty similar.But the details are\na little different.So yeah, even if you actually\ngenerated your key somewhereelse and your key was great,\nit's just that every time yougenerate a signature,\nyou would--and you generated two signatures\nwith exactly the same nonce,or random value, someone\ncould apply some clever mathto your signatures and sort\nof extract your public key outof it.Or private key,\nmore importantly.All right.Other questions about these\nproblems, examples, et cetera?All right.So I guess, one thing I wanted\nto point out is that actually,well, as you're\nstarting to appreciate,is that in computer security,\nalmost every detail hasa chance of really mattering.If you screw up almost something\nseemingly inconsequential,like forgetting to check\nsomething, or this,or forgetting to\ninitialize the random seed,it can have pretty\ndramatic consequencesfor the overall system.And you really have to\nbe very clear about,what is the specification\nof your system?What is it doing?Exactly what are all\nthe corner cases?And a good way to sort of\nthink of breaking a systemor, conversely, figure out\nif your system is secure,is to really push\nall the edge cases,like what happens if my\ninput is just large enough?Or what is the biggest\nor the smallest input?What is the sort\nof strangest setof inputs I could\nprovide to my programand push it in all\nthese corner cases?One example of this ambiguity,\nsort of a good exampleto keep in mind, is how\nSSL certificates, again,encode names into the\ncertificate itself.So this is a different\nproblem than the problemabout the certificate\nauthorities being trusted.So these SSL certificates\nare just sequences of bytesthat a web server sends to you.And inside of this\nSSL certificate", "start": 2400.0, "heat": 0.1}, {"text": "is the name of the server\nyou're connecting to,so something like Amazon.com.You know, you can't just\nput down those bytes.You have to encode it\nsomehow and specify, well,it's Amazon.com.And that's the\nend of the string.So in SSL certificates, they\nuse a particular encoding schemethat writes down Amazon.com\nby first writing downthe number of bytes\nin the string.So you first write down, OK.Well, I'm going to have a 10\nbyte string called Amazon.com.That's actually 10 bytes.Great.OK.So this is like-- in the\nSSL certificate, somewherein there, there is this byte\n10 followed by 10 bytes sayingwhat the host name is.And there's other stuff\nafterwards, right, and before.And when a browser takes\nit, well, the browseris written in C. And the\nway C represents stringsis by null terminating them.So in C, a string doesn't\nhave a length count.Instead, it has all the bytes.And the end of the string\nis just the byte zero.And in C, you write it with\na backslash zero character.So this is in memory\nin your browser.Somewhere in memory\nthere's this stringof 11 bytes, now, with\nan extra zero at the end.And when a browser\ninterprets this string,it just keeps going until\nit sees an end of stringmarker, which is a zero byte.OK.So, what could go wrong?Any guesses?Yeah?AUDIENCE: You have a zero\nin the middle [INAUDIBLE]?PROFESSOR: Yes.This is great.All right.So, this is actually a\nbit of a discontinuityin terms of how\nthis guy representsstrings and this guy.So suppose that I own\nthe domain foo.com.So I can get certificates\nfor anything dot foo dot com.So what I could do is ask for\na certificate for the nameamazon.com0x.foo.com.That's a perfectly valid string.It has a bunch of bytes.", "start": 2520.0, "heat": 0.1}, {"text": "I guess it's 10, 11\n12 13, 14, 15, 16,there's another four, 20, right?So this is 20 byte name\nwith these 20 bytes.So it used to be that if you\ngo to a certificate authority,in many cases, you could\nsay, hey, I own foo.com.Give me a certificate\nfor this thing.And they'd be perfectly\nwilling to do it because it'sa subdomain of foo.com.It's all yours.But then, when a browser\ntakes this stringand loads it in memory, well,\nwhat it does is the same thingit did here.It copies the string.amazon.com0x.foo.com.It'll dutifully add the\nterminating zero at the end.But then, when the rest\nof the browser softwaregoes and tries to interpret the\nstring at this memory location,it'll keep going up until it\ngets to zero and say, OK well,that's the end of the string.So this is Amazon.com.That's it.So this sort of disconnect\nbetween how C softwareand how SSL certificates\nrepresent namesled to some unfortunate\nsecurity problems.This was actually\ndiscovered a number of yearsago now by this guy,\nMoxie Marlinspike.But it's a fairly\nclever observation.And these kinds of encoding\nbugs are actually alsopretty common in\nlots of softwarebecause, unless you're very\ndiligent about exactly how youencode things, there might be\ndifferent ways of encoding.And whenever there's\ndisagreement,there's a chance the bad guy\ncan take advantage of this.One system thinks\nthat's a fine name.Another thinks that's\nnot, something else.So these are good places\nto sort of push a systemto see how it might break.That make sense?All right.So maybe the last example\nof mechanism failureI'm going to talk about today\nis a reasonably popular one.It's this problem\nor buffer overflows.So some of you have seen this\nin, or at least at some level,in 6.033, if you did\nthe undergrad course.", "start": 2640.0, "heat": 0.1}, {"text": "But for those of you that have\nforgotten or haven't takenoh three three, we'll sort\nof go over buffer overflowsin more detail.And this will be, actually,\nquite critical for you guys,because lab one is all\nabout buffer overflows.And you're going\nto be exploitingthese vulnerabilities in a\nsomewhat real web server.So let's figure out,\nwhat is the setting?What are we talking about here?So the setting we're\ngoing to be consideringis a system which has,\nlet's say, a web server.So what we have is, we have\nsome computer out therethat has a web server on it.And the web server\nis a program thatis going to accept connections\nfrom the outside world,take requests-- which are\nbasically just packets--and somehow process them, and\ndo some checking, probably.If it's an illegal\nURL or if they'retrying to access a file they\nare not authorized to access,the web server is going\nto return an error.But otherwise, it's going\nto access some files,maybe on disk, and\nsend them back outin some sort of a reply.So this is a hugely common\npicture, almost any systemyou look at.What's the policy?Or what's the threat model?So this is a bit of a problem\nin many real world systems,namely that it's\nactually pretty hardto pin down what is the\nexact policy or threat modelthat we're talking about.And this sort of imprecision\nor ambiguity about policies,threat models, et\ncetera, is what sometimesleads to security problems.Not in this particular\ncase, but we'll see.But maybe just to give\nyou a sense of howto think of a typical web server\nin the context of this policy,threat model kind of stuff, is\nthat well, probably the policyis, the web server should do\nwhat the programmer intendedit to do.It's a little vague.But that's probably what's\ngoing on because anything morespecific, as well,\nthe web server shoulddo exactly what the\ncode does, is goingto be a bit of an [INAUDIBLE]\nAnd if your code has a bug,well, your policy\nsays, well, that's", "start": 2760.0, "heat": 0.122}, {"text": "exactly what I should do.I should follow the bug.So it's a little hard to\nstate a policy precisely,but in this case, let's\ngo with some intuitiveversion of, well, the\nweb server should do whatthe programmer wanted it to do.And the threat\nmodel is probably,the attacker doesn't have\naccess to this machine,can't log in to it remotely,\ndoesn't have physical accessto it, but can send\nany packet they want.So they're not restricted\nto certain kinds of packets.Anything you can\nshape and sort ofdeliver to this web\nserver, that's fair game.Seems like a reasonable\nthreat model, in practice,to have in mind.And I guess the goal is that\nthis web server shouldn'tallow arbitrary stuff\nto go wrong here.I guess that sort of\ngoes along with whatthe programmer intended.The programmer probably\ndidn't intend any requestto be able to access\nanything on the server.And yet, it turns out if you\nmake certain kinds of mistakesin writing the web server\nsoftware, which is basicallythe mechanism here, right?The web server software is\nthe thing that takes a requestand looks at it and\nmakes sure that it's notgoing to do something bad, sends\na response back if everything'sOK.The web server in\nthis mechanism.It's enforcing your policy.And as a result, if the web\nserver software is buggy,then you're in trouble.And one sort of common\nproblem, if you'rewriting software in\nC which, you know,many things are\nstill written in Cand probably will continue to\nbe written in C for a while,you can mismanage your\nmemory allocations.And as we saw in this SSL\ncertificate naming example,even sort of a single\nbyte can reallymake a huge difference,\nin terms of what goes on.And I guess for\nthis example, we'lllook at a small piece of code\nthat's not quite a real webserver.In the lab, you'll have this\nwhole picture to play with.But for lecture, I\njust want to give youa simplified example\nso we can talkabout what's sort of at the\ncore of what's going wrong.And, in particular, if\nthis system wakes up,I will show you sort of\na very small C function.And we can sort of\nsee what goes wrongif you provide different\ninputs to that piece of code.", "start": 2880.0, "heat": 0.152}, {"text": "All right.So the C function that I\nhave in mind is this guy.Somewhere here.Oh, yeah.It's coming on.All right.So here's the sort of\nprogram I'm talking about,or I want to use\nas an example here.So this program is just\ngoing to read a request.And you can sort of\nimagine it's going to reada request from the network.But for the purposes\nof this example,it's just going to read\na request from whateverI'm typing in on the keyboard.And it's going to store\nit in a buffer here.And then it's going to\nparse it is an integerand return the integer.And the program will then print\nwhatever integer I get back.It's like far from a web server.But we'll at least\nsee some basicsof how buffer overflows\nwork and what goes wrong.So let's see actually what\nhappens if we run this program.So I can compile it here.And actually, you\ncan sort of seethe-- it's already telling me\nwhat I'm screwing up, right?The get function is dangerous\nand should not be used.And we'll see in a second\nwhy the compiler isso intent on telling me this.And it actually is true.But for now, suppose\nwe're a happy go luckydeveloper that is willing\nto ignore this warning.So OK.I run this redirect function,\nI provide some input,and it works.Let's see if I\nprovide large inputs.If I type in some\nlarge number, well,at least it gives me\nsome large number.It basically maxes out to\ntwo to the 31 and prints thatand doesn't go any higher.So that's maybe not\ndisastrous, right?Whatever.You provided this\nridiculously large number.You got something\ndidn't quite work.It's not quite a problem yet.But if we provide some\nreally large input,we might get some\nother problem, right?So suppose I provide\nin a lot of by 12", "start": 3000.0, "heat": 0.19}, {"text": "I just provided things\nthat are not numbers.It prints zero.That's not so bad.But suppose I'm going to\npaste in a huge number of As.OK, so now the program crashes.Maybe not too surprising.So if it was the case that if\nI send a bad request to the webserver, it just doesn't get back\nto me or doesn't send a reply,that would be fine.But we'll sort of\nlook inside and seewhat happens, and try to\nfigure out how we can actuallytake advantage of this crash\nto maybe do something much moreinteresting, or, well, much more\nalong with what a hacker mightbe interested in doing.So to do this, we're\ngoing to run this programunder a debugger.You'll get super familiar\nwith this in lab one.But for now, what\nwe're going to dois set a breakpoint in\nthat redirect function.And we're going to sort of run\nalong and see what happens.So when I run the\nprogram, it's goingto start executing\nin the main function.And pretty quickly,\nit calls redirect.And the debugger is now stopped\nat the beginning of redirect.And we can actually see what's\ngoing on here by, for example,we can ask it to print\nthe current CPU registers.We're going to look at\nreally low level stuffhere, as opposed to at the\nlevel of C source code.We're going to look at\nthe actual instructionsthat my machine is\nexecuting because that'swhat really is going on.The C is actually maybe\nhiding some things from us.So you can actually\nprint all the registers.So on x86, as you\nmight remember.Well, on [INAUDIBLE]\narchitecture,there's a stack pointer.So let me start maybe drawing\nthis diagram on the boardso we can try to reconstruct\nwhat's happening.So what's going on is that\nmy program, not surprisingly,has a stack.On x86, the stack grows down.So it sort of is\nthis stack like this.And we can keep\npushing stuff onto it.So right now, the\nstack pointer pointsat this particular\nmemory location FFD010.So some value.So you can try to figure\nout, how did it get there?", "start": 3120.0, "heat": 0.209}, {"text": "One way to do it is to\ndisassemble the codeof this redirect function.Is this going to work better?Really?Convenience variable\nmust have integer value.Man.What is going on\nwith my debugger?All right.Well, we can disassemble\nthe function by name.So this is what the\nfunction is doing.So first off, it starts\nby manipulating somethingwith this EBP register.That's not super interesting.But the first thing\nit does after that issubtract a certain value\nfrom the stack pointer.This is, basically, it's making\nspace for all those variables,like the buffer and the integer,\ni, we saw in the C source code.So we're actually,\nnow, four instructionsinto the function, here.So that stack\npointer value that wesaw before is actually already\nin the middle, so to say,of the stack.And currently,\nthere's stuff above itthat is going to be the\nbuffer, that integervalue, and actually,\nalso the return addressinto the main function\ngoes on the stack, as well.So somewhere here, we'll\nhave the return address.And we actually\ntry to figure out,where are things on the stack?So we can print the address\nof that buffer variable.So the buffer variable\nis at address D02C.We can also print the\nvalue of that integer, i.That guy is at D0AC.So the i is way up on the stack.But the buffer is a bit lower.So what's going on is that\nwe have our buffer hereon the stack, and then\nfollowed above by i and maybesome other stuff, and\nthen finally, the returnaddress into the main\nfunction that called redirect.And the buffer\nis-- this is going,", "start": 3240.0, "heat": 0.162}, {"text": "the stack is growing down.So these are higher addresses.So what this means is that\nthe buffer-- we actuallyhave to decide, where is the\nzeroth element of the buffer,and where is the 128th\nelement of this buffer?So where does the zeroth\nelement of the buffer go?Yeah?Should be at the bottom,\nright, because yeah,higher elements\njust keep going up.So buff of zero is down here.It just keeps going on.And buff of 127 is\ngoing to be up there.And then we'll have\ni and other stuff.OK.Well, let's see what\nhappens now if weprovide that input that seemed\nto be crashing it before.So I guess one thing\nwe can actuallydo before this is to see\nwhether we can actuallyfind this return address.Where it actually happens to\nlive is at the EBP pointer.This is just a convenient thing\nin the x86 calling convention,that the EBP pointer,\nor register, actuallyhappens to point to something\non the stack which is goingto be called the saved EBP.It's a separate location, sort\nof after all the variablesbut before the return address.And this is the\nthing that's beingsaved by those first couple\nof instructions at the top.And you actually\nsort of examine it.In GDB you can say, examine x,\nsome value, so the EBP pointervalue.So that's the location\nof the stack, D0B8.Indeed, it's actually\nabove even the i variable.So it's great.And it has some other\nvalue that happensto be the EBP before\nthis function was called.But then, sort of one\nmore memory locationup is going to be\nthe return address.So if we print EBP plus four,\nthere's something else there,this 0x08048E5F.And let's actually see\nwhere that's pointing.So this is something you're\ngoing to do a lot in the lab.So you can take this address.And you can try\nto disassemble it.So what is this guy?", "start": 3360.0, "heat": 0.117}, {"text": "Where did we end up?So GDB actually helpfully\nfigures out which functioncontains that address.So 5F.This is the guy that our\nreturn address is pointing to.And as you can see, this\nis the instruction rightafter the call to redirect.So when we return\nfrom redirect, thisis exactly where we're going\nto jump and continue execution.This is, hopefully,\nfairly straightforwardstuff from double oh four,\nsome standard OS class.OK.So where are we now?Just to recap, we can try to\ndisassemble our instructionpointer.So we're at the beginning\nof redirect right now.And we can run for a bit, and\nmaybe run that getS() function.So OK, we run next.What this does is it runs getS()\nand it's waiting for getS()to return.We can provide our bad input\nto getS() and try to get itto crash again and see what's\ngoing on, really, there, right?So we can paste a\nbunch of As again.OK.So we got out of getS() and\nthings are actually still OK,right?The program is still running.But we can try to figure out,\nwhat is in memory right nowand why are things\ngoing to go wrong?Actually, what do\nyou guys think?What happened, right?So I printed out a bunch of As.What did getS()\ndo to the memory?Yeah, yeah.So it just keeps\nwriting As here, right?All we actually passed to\ngetS() was a single pointer,the start of this\naddress, right?So this is the\nargument to getS(),is a pointer to this memory\nlocation on the stack.So it just kept writing As.And it doesn't actually\nknow what the length is,so it just keeps going, right?It's going to override As\nall the way up the stack,past the return address,\nprobably, and into whateverwas up the stack above us.So we can check whether\nthat's the case.So we can actually\nprint the buffer.And in fact, it\ntells us, yeah, wehave 180 As there,\neven though the buffershould be 128 elements large.So this is not so great.And we can actually,\nagain, examine what'sgoing on in that EBP pointer.", "start": 3480.0, "heat": 0.153}, {"text": "Dollar sign, EBP.So in fact, yeah.It's all 0x41, which is the\nASCII encoding of the letter A.And in fact, the return\naddress is probably goingto be the same way, right?If we print the return\naddress, it's also all As.That's not so great.In fact, what's going to\nhappen if we return now isthe program will jump to\nthat address, 41414141.And there's nothing there.And it'll crash.That's the segmentation\nfault you're getting.So let's just step up to\nit and see what happens.So let's run next.So we keep stepping\nthrough the program.And we can see where we are.OK.We're getting close to\nthe end of the function.So we can step over\ntwo more instructions.nexti.And now we can\ndisassemble again.OK.We're now just at the return\ninstruction from this function.And we can actually figure out.So as you can see, at\nthe end of the function,it runs this leave\nx86 instruction,which basically restores the\nstack back to where it was.So it sort of pushes\nthe stack pointerall the way back to the return\naddress using the same EBP.That's what it's basically for.And now, the stack is\npointing at the return addressthat we're going to use.And in fact, it's all A's.And if we run one\nmore instruction,the CPU is going to jump to\nthat exact memory addressand start executing\ncode there and crash,because it's not a valid address\nthat's in the page table.So let's actually see, just to\ndouble check, what's going on.Let's print our buffer again.Our buffer-- well, that's\nactually kind of interesting,right?So now, buffer,\nfor some reason itonly says A repeats 128 times.Whereas if you remember before,\nit said A repeated 180 timesin our buffer.So what happened?Yeah?AUDIENCE: [INAUDIBLE].PROFESSOR: Yeah, yeah.Exactly.So there's actually\nsomething going onafter the buffer\noverflow happensthat changes what's going on.So actually, if\nyou remember, we dothis A to i conversion of\nthe string to an integer.", "start": 3600.0, "heat": 0.186}, {"text": "And if you provide\nall As, it actuallywrites zero to this\nmemory location.So a zero, if you remember,\nterminates strings in C.So GDB now thinks, yep, we have\na perfectly well-terminated128 byte string of all As.But you know, it\ndoesn't really matter,because we still have\nthose As up top thatalready corrupted our stack.OK.That was actually kind\nof an important lessonthat-- it's actually a\nlittle bit tricky, sometimes,to explore these buffer\noverflows because, eventhough you've already changed\nlots of stuff on the stack,you still have to\nget to the pointwhere you use the value\nthat you have somehowplaced on the stack.So there's other\ncode that's goingto run after you've\nmanaged to overflowsome buffer and corrupt memory.You have to make sure that\ncode doesn't do something sillylike, if it's A to i,\njust exited right away,as soon as it saw a\nnon-integer value,we might not get to jump to\nall this 41414141 address.So you have to massage\nyour input in some cases.Maybe not so much in this case.But in other\nsituations, you'll haveto be careful in\nconstructing this input.OK, so just to see what happens,\nwe can jump one more time.Well, let's look\nat our register.So right now, our EIP, the\nsort of instruction pointer,is pointing at the\nlast thing in redirect.And if we step one more\ntime, hopefully we'lljump to, finally, that\nunfortunate 4141 address.Over here.And in fact, yep.The program now seems\nto be executing there.If we ask GDB to print the\ncurrent set of registers,yep, the current instruction\npointer is this strange value.And if we exclude\none more instruction,it's going to crash\nbecause that's finallytrying to execute an instruction\npointer that doesn't correspondto a valid page in the\noperating system's page tablefor this process.Make sense?Any questions?All right.Well, I've got a question\nfor you guys, actually.So what happens-- you know,\nit seems to be exploitable.Or well, OK.Maybe let's first figure out\nwhy this is particularly bad,", "start": 3720.0, "heat": 0.182}, {"text": "right?So why is it a problem?So not only does\nour program crash,but presumably we're\ngoing to take it over.So I guess, first\nsimple question is, OK,so what's the problem?What can you do?Yeah?AUDIENCE: You can do\nwhatever you want.PROFESSOR: Yeah.So I was actually pretty silly\nand just put in lots of As.But if you were\ncareful about knowingwhere to put what\nvalues, you mightbe able to put in\na different valueand get it to jump\nsomewhere else.So let's see if we can\nactually do this, right?We can retrace this whole thing.OK.Re-run the program again.And I guess I have to\nreset the breakpoint.So I can break and\nredirect again.And run.And this time,\nI'll, again, next,supply lots of As\nand overflow things.But I'm not going to try\nto carefully construct--you know, figure out which\npoint in these As correspondsto the location in the stack.That's something\nyou guys are goingto have to do for lab one.But suppose that I\noverflow the stack here.And then I'm going\nto manually tryto change things on the stack to\nget it to jump to some point Iwant to jump to.And in this program, OK,\nso let's again-- nexti.Where are we?We're at, again, at the\nvery end of redirect.And let's actually look\nat the stack, right?So if we examine esp here,\nwe see our corrupted pointer.OK.Where could we jump to?What interesting\nthings could we do?Unfortunately, this\nprogram is pretty limited.There's almost nothing\nin the program's codewhere you could jump and\ndo anything interesting.But maybe we can do a little\nbit of something interesting.Maybe we'll find\nthe printf in mainand jump directly there, and\nget it to print the x value,or x equals something.So we can do this.We can actually disassemble\nthe main function.And main does a\nbunch of stuff, youknow, initializes, calls\nredirect, does some more stuff,and then calls printf.So how about we jump to\nthis point, which is,it sets up the\nargument to printf,which is x equals percent d,\nand then actually calls printf.So we can actually\ntake this valueand try to stick\nit in the stack.", "start": 3840.0, "heat": 0.112}, {"text": "And should be able to do\nthis with the debuggerpretty easily, at least.So you can do this set\n[? int ?] esp equals this value.So we can examine esp again\nand, indeed, it actuallyhas this value.So if we continue now,\nwell, it printed out xequals some garbage,\nwhich I guesshappens to be just whatever\nis on the stack thatwas passed to printf.We didn't correctly set\nup all the argumentsbecause we jumped in the middle\nof this calling sequence.But yeah, we printed this value.And then it crashed.Why did crash?Why do you think?What actually happens, right?So we jump to printf.And then, something went wrong.Yeah?Well, we changed\nthe return addressso that when we\nreturn from redirect,we now jump to this new address,\nwhich is that point up there,right after printf.So where's this\ncrash coming from?Yeah?AUDIENCE: Is it\nrestricted because your iis supposed to be some\nsort of integer, but--PROFESSOR: No, actually,\nwell the i is like,well it's a 32-bit register.So whatever's in the\nregister, it'll print.In fact, that's the thing\nthat's in the register.So that's OK.Yeah?AUDIENCE: [INAUDIBLE]\nmain returns.PROFESSOR: Yes.Actually, yeah.What's going on is, you\nhave to sort of-- OK,so this is the point\nwhere we jumped.It's set up some arguments.It actually calls printf.printf seems to work.\nprintf is going to return.Now actually, that's fine,\nbecause this call instructionput a return address on the\nstack for printf to use.That's fine.Then main is going\nto continue running.It's going to run the sleeve\ninstruction, which doesn'tdo anything interesting.And then it does another return.But the thing in\nthis-- up to the stack,it doesn't actually have\na valid return address.So presumably, we\nreturn to some otherwho knows what memory location\nthat's up on the stackand jump somewhere else.So unfortunately,\nhere, our pseudoattackdidn't really work.It ran some code.But then it crashed.That's probably not\nsomething you want to do.So if you really\nwanted to be careful,you would carefully plant not\njust this return address upon the stack, but\nmaybe you'd figure out,where is this second red going\nto get its return address from,", "start": 3960.0, "heat": 0.13}, {"text": "and try to carefully\nplace somethingelse on the stack\nthere that will ensurethat your program cleanly\nexits after it gets exploitedso that no one notices.So this is all\nstuff you'll sort oftry to do in lab one in\na little bit more detail.But I guess one thing we\ncan try to think about nowis, we sort of understand\nwhy it's bad to jump to the--or to have these\nbuffer overflows.One problem, or one sort\nof way to think of thisis that, the problem is just\nbecause the return address isup there, right?So the buffer keeps\ngrowing and eventually runsover the return address.What if we flip\nthe stack around?You know, some machines actually\nhave stacks that grow up.So an alternative design\nwe could sort of imagineis one where the stack\nstarts at the bottomand keeps going up\ninstead of going down.So then, if you\noverflow this buffer,you'll just keep\ngoing up on the stack,and maybe there's nothing\nbad that will happen.Yeah?AUDIENCE: [INAUDIBLE].PROFESSOR: So you're right.It might be that,\nif you have-- well,so let me draw this\nnew stack diagram.And we'll sort of try to figure\nout what it applies to and not.But OK.So we'll basically just\ninvert the picture.So when you call redirect on\nthis alternative architecture,what's going to happen\nis the return addressis going to go\nhere on the stack.Then we'll have our i variable,\nor maybe the saved EBP.Then we'll have our i variable.And then we'll have buff.So we'll have buff of zero,\nbuff 127, and so on, right?So then when we do the overflow,\nit overflows up there and maybedoesn't hit anything bad.I guess what you're\nsaying is that,well, maybe we had\na buffer down there.And if we had a buffer\ndown there, then yeah,that seems kind of unfortunate.It could overrun\nthis return address.So you're right.So you could still\nrun into problems", "start": 4080.0, "heat": 0.187}, {"text": "on this stack growing up.But what about\nthis exact program?Is this particular\nprogram safe on machineswhere the stack grows up?So just to recap what the\nprogram read is this guy.Yeah?AUDIENCE: Still\ngoing to overwrite[INAUDIBLE] as a return value.PROFESSOR: Yeah.So that's actually\nclever, right?So this is the stack\nframe for redirect.I guess it actually spans\nall the way up here.But what actually happens\nwhen you call getS() is thatredirect makes a function call.It actually saves its return\naddress up here on the stack.And then getS() starts running.And getS() puts its\nown saved EBP up here.And getS() is going to post\nits own variables higher up.And then getS() is going\nto fill in the buffer.So this is still problematic.Basically, the buffer is\nsurrounded by return initialson all sides.Either way, you're going to\nbe able to overflow something.So at what point-- suppose we\nhad a stack growing up machine.At what point would\nyou be able to takecontrol of the program's\nexecution then?Yes, and that is actually\neven easier in some ways.You don't have to wait\nuntil redirect returns.And maybe there was like, stuff\nthat was going to mess you uplike this A to i.No.It's actually easier, because\ngetS() is going to overflowthe buffer.It's going to change\nthe return addressand then immediately\nreturn and immediatelyjump to wherever you sort\nof tried to construct,makes sense.So what happens if we\nhave a program like thisthat's pretty boring?There's like no real\ninteresting code to jump to.All you can do is get it to\nprint different x values here.What if you want to do\nsomething interesting that youdidn't-- yeah?AUDIENCE: I mean, if you\nhave an extra cable stack,you could put\narbitrary code that,for example, executes a shell?PROFESSOR: Yeah yeah yeah.So that's kind of clever,\nright, because you actuallycan supply other inputs, right?", "start": 4200.0, "heat": 0.144}, {"text": "So at least, well-- there's\nsome defenses against this.And we'll go over these\nin subsequent lectures.But in principle, you could\nhave the return address herethat you override on either the\nstack up or stack down machine.And instead of pointing\nit to some existing code,like the printf\ninside of main, wecan actually have the return\naddress point into the buffer.So it's previously just\nsome location on the stack.But you could jump there\nand treat it as executable.So as part of your\nrequest, you'll actuallysend some bytes of\ndata to the server,and then have the return address\nor the thing you overwrite herepoint to the base of the\nbuffer, and you'll justkeep going from there.So then you'll be able\nto sort of providethe code you want\nto run, jump to it,and get the server to run it.And in fact, traditionally,\nin Unix systems,what adversaries would often\ndo is just ask the operatingsystem to execute the\nbinsh command, whichlets you sort of type in\narbitrary shell commandsafter that.So as a result, this\nthing, this pieceof code you inject\ninto this buffer,was often called, sort of for\nhistorical reasons, shell code.And you'll try to construct\nsome in this lab one as well.All right.Make sense, what\nyou can do here?Any questions?Yeah?AUDIENCE: Is there a separation\nbetween code and data?PROFESSOR: Right.So is there a separation\nbetween code and data here?At least, well,\nhistorically, many machinesdidn't enforce any\nseparation of code and data.You'd just have a flat\nmemory address space.The stack pointer\npoints somewhere.The code pointer\npoints somewhere else.And you just execute wherever\nthe code pointer, instructionpointer is pointing.Modern machines try to\nprovide some defensesfor these kinds of attacks.And what modern\nmachines often do is,they actually\nassociate permissionswith various memory regions.And one of the\npermissions is execute.So the part of your\n32-bit or 64-bit addressspace that contains code\nhas the execute permission.So if your instruction\npointer points there,the CPU will actually\nrun those things.And the stack and other data\nportions of your address spacetypically don't have\nthe execute permission.", "start": 4320.0, "heat": 0.154}, {"text": "So if you happen to somehow\nset your instruction pointerto some non-code memory\nlocation, you can set it,but the CPU will\nrefuse to execute it.So this is a reasonably\nnice way to defendagainst these kinds of attacks.But it doesn't prevent\nquite everything.So just a question.OK.So how would you\nbypass this if youhad this non-executable stack?You actually saw this\nexample earlier, right,when I actually jumped\nto the middle of main.So that was a way of sort\nof exploiting this bufferoverflow without having to\ninject new code of my own.So even if the stack\nwas non-executable,I would still be able to\njump in the middle of main.In this particular case,\nit's kind of boring.It just prints x and crashes.But in other\nsituations, you mighthave other pieces of\ncode in your programthat are doing interesting\nstuff that you reallydo want to execute.And that's sort of called return\nto libc attacks for, again,somewhat historical reasons.But it is a way to bypass\nthe security measures.So in the context\nof buffer overflows,there's not really\na clear cut solutionthat provides perfect protection\nagainst these mistakesbecause, at the end of the\nday, the programmer didmake some mistake in\nwriting this source code.And the best way to fix it\nis probably just to changethe source code and make sure\nyou don't call getS() verymuch, like the\ncompiler warned you.And there's more subtle\nthings that the compilerdoesn't warn you about.And you still have to\navoid making those calls.But because it's\nhard, in practice,to change all the\nsoftware out there,many people try to\ndevise techniquesthat make it more difficult\nto exploit these bugs.For example, making the\nstack non-executable,so you can't inject the\nshell code onto the stack,and you have to do something\nslightly more elaborate.And next couple of\nlectures, next two lectures,actually, we'll look at\nthese defense techniques.They're not all perfect.But they do, in\npractice, make itmuch more difficult for that\nhacker to exploit things.Question?AUDIENCE: I just have a general\nadministrative question.PROFESSOR: Yeah?AUDIENCE: I was wondering\nif there was a final?And also if there are\nquizzes, and what dates--PROFESSOR: Oh yeah.", "start": 4440.0, "heat": 0.186}, {"text": "Yeah, I think if you go\nto the schedule page,there's two quizzes.And there's no final\nduring the final week,but there's a quiz\nright before it.So you're free for\nthe final week,but there's still something\nat the end of the class.Yeah.All right.OK.So I think that's probably\nit for buffer overflows.I guess the one\nquestion is, so whatdo you do about\nmechanism problems?And the general answer is to\nprobably have fewer mechanisms.So as we saw here,\nif you're relyingon every piece of software to\nenforce your security policy,you'll inevitably\nhave mistakes thatallow an adversary to bypass\nyour mechanism to exploitsome bug in the web server.And a much better\ndesign, and one butyou will explore\nin lab two, is onewhere you structure\nyour whole systemso the security of\nthe system doesn'tdepend on all the\npieces of softwareenforcing your security policy.The security policy\nis going to beenforced by a small\nnumber of components.And the rest of\nthe stuff actuallydoesn't matter, for\nsecurity purposes,if it's right or wrong.It's not going to violate\nyour security policy at all.So this, kind of minimizing\nyour trusted computing baseis a pretty powerful technique\nto get around these mechanismbugs and problems that we've\nlooked at today, at leastin a little bit of detail.All right.So read the paper for Monday.And come to Monday's lecture.And submit the questions\non the website.See you guys then.", "start": 4560.0, "heat": 0.1}]