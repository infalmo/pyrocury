[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: All right\neveryone let's get started.All right good afternoon on\nthis rainy, rainy sad afternoon.So-- I'm glad we're\ninside though-- all rightso Lecture 4 of 6.0001 in 600.Quick, quick recap of\nwhat we did last time.So last time we did a little\nbit more string manipulations,and then we saw how you can\nuse for loops over stringsdirectly.So instead of having for\nloops that iterate overrange-- so 0, 1, 2,\n3, 4, and so on--you saw that it was more\npowerful to sometimes usefor loops that iterate over\nstring objects directly.So that was the first\nhalf of the lecture.In the second half, we started\nlooking at different waysthat you can implement the\ndifferent implementationsto the same problem.So we saw the problem of\nfinding the cube root,and we saw some implementations.We saw the Guess\nand Check method,and the approximation method.And then we looked\nat what I thoughtwas the most powerful method,\nwhich was the bisection method.And this one, if you\nremember, I played a gamewith someone in the\naudience where I guesseda number between 0 and 100.And we saw that I was able\nto guess that number really,really quickly using\nthe bisection method.And that's the\nmethod that you'regoing to implement-- that you\nare currently implementing--in your problem set.OK so today-- so that sort\nof finishes introduction", "start": 0.0, "heat": 0.1}, {"text": "to some of the more basic\nmechanisms in Python.And today we're going\nto talk about howto structure your programs\nsuch that you writenice, coherent code-- reusable\ncode-- by hiding away someof the details in your code.And to do that we're going\nto look at these thingscalled functions.All right so just\nstepping back and sortof getting a high-level view of\nhow we write the code so far.So so far the way that\nyou've been writing codefor your programs\nis you open a file,you type some code to solve\na particular problem given,like in your problem\nsets, each filecontains some piece of code, you\nhave sequences of instructionsthat contain maybe assignments,\nloops, conditionals,and so on and so on.But really you have one\nfile that contains each codeand you write everything\nin that particular file.But this is OK for\nsmaller problemsthat we've been seeing\nso far, but whenyou're starting to write\nlarge pieces of codeit's going to get really\nmessy, really quickly.So think about if you\nwant to use a for loopin one part of\nyour code, and youfind it useful to use\nthat same for loopin another part of your code.Some point in the future as\nyou're debugging your code,you might want to change\nyour original for loop,you have to figure out\nall the other placeswhere you've used that type\nof for loop for example.So as you're scaling\nyour code, you'llfind it harder to keep\ntrack of these details.So this is where functions\nwill come into play in today'slecture-- will help you out.So if you want to be\nconsidered a good programmer,a good programming style would\nbe to not necessarily addlots and lots of lines\nof code, but reallyto add more functionality\nto your programs.So how many different things--\nhow many different features--can your program do, rather\nthan how long can your code be.", "start": 120.0, "heat": 0.124}, {"text": "And that'll help you\nlater on look at your codeif you need it for\na future class,and it'll help others if they\nwant to look at your codelater on if they find it useful.So today we're introducing\nthis idea of functions.And functions are\nmechanisms to achievedecomposition and abstraction.So these are two\nkey words here thatare going to pop up\nin today's lectureand also in future lectures.So before I introduce\ndecomposition and abstractionin the context of\nfunctions, let'sfirst take a look at just\nsort of a real-life example.So let's take a projector.I'm using one right now.Quick show of hands.If I give you all of the\nelectronic componentsthat are part of a projector--\nresistors, a fan, a light bulb,a lens, the casing, all of\nthe different parts in it.Who here would be able\nto build a projector?Do I see a hand?No?Ooh oh yeah nice!You can also lie.I won't know the difference.But if you can do that,\nI'd be very impressed.All right so you can't really\nput together a projector right?Another show of hands.If I gave you a projector\nthat's fully assembledand I gave you a\ncomputer, for example,who would be able to maybe\nfigure out within let's sayan hour how to make\nthem work together?Good, a fair bit of the class.That's perfect.That's exactly the answers\nI was trying to get at here.So none of us really\nknow how a projectorworks-- the internals--\nbut a lot more of usknow how to work a\nprojector, just given maybea set of basic instructions\nor just intuitively speaking.So you see the projector\nas sort of a black box.You don't need to know how\nit works in order to use it.You know maybe what inputs\nit might take, what's itsupposed to do at a high level.Take whatever's on my screen and\nput it up on the large screen", "start": 240.0, "heat": 0.1}, {"text": "there, just magnify\nit, but you don'tknow how it does it-- how\nthe components work together.So that's the idea\nof abstraction.You don't need to know how\nthe projector works in orderto use it.OK that's abstraction.The other half of that\nwas decomposition.So let's say that now,\ngiven a projector,I want to project a very,\nvery large image downon a very large stage.For example, this is\nfrom one of the Olympics.It's a stage of what,\nlike 10 football fields,something like that?Something massive.You could build one\nprojector that'sable to project a\nvery large image,but that would be\nreally expensiveand you'd have to build\nthis one projector that'sused for this one time.So instead what\nyou could do is youcan take a bunch of\nsmaller projectorsand feed different inputs\nto each one of them.And as you're feeding\ndifferent inputs,each one's going to\nshow a different output.And then you're going\nto be able to haveall of these different\nprojectors working togetherto solve this larger\nproblem of projectingthis really cool image\non a very large stage.So that's the idea\nof decomposition.You take the same projector,\nfeed it different inputs,it does the exact same\nthing behind the scenes,but it will produce\na different outputfor each one of these\ndifferent inputs.So these different devices\nare going to work togetherto achieve the same\ncommon goal, and that'sthe idea of decomposition.So these is where I apply\nto the problem of projectinglarge image, or a\nprojector in general,but we can apply these exact\nsame concepts to programming.So decomposition is\nreally just the problemof creating structure\nin your code.In the projector example,\nwe have separate devicesworking together.In programming, to\nachieve decomposition", "start": 360.0, "heat": 0.1}, {"text": "you're dividing your code\ninto smaller modules.These are going to\nbe self-contained,and you can think of them as\nsort of little mini-programs.You feed in some input to\nthem, they do a little task,and then they give\nyou something back.They go off and do\ntheir thing and thenthey give back a result.These modules can be used\nto break up your code,and the important thing\nis that they're reusable.So you write a module once--\na little piece of codethat does something\nonce-- you debug it once,and then you can reuse it\nmany, many times in your codewith different inputs.Benefit of this is it\nkeeps your code organizedand it keeps your code coherent.So functions are going to be\nused to achieve decompositionand to create\nstructure in our code.We're going to see functions\ntoday in this lecture,and in a few weeks, you're\ngoing to actually see--when we talk about object\noriented programming-- howyou can achieve\ndecomposition with classes.And with classes you can\ncreate your own object typeslike adding some floats.You can create your own object\ntypes for whatever you want,but that's later.OK so decomposition is creating\nstructure in your code.And abstraction is the idea\nof suppressing details.So in the projector example,\nremember, abstractionwas you didn't need to know\nexactly how the projectorworked in order to use it.And it's going to be the\nsame idea in programming.So once you write a piece of\ncode that does a little task,you don't need to rewrite\nthat piece of code many times.You've written it\nonce, and you writethis thing called a function\nspecification for it,or a docstring.And this is a piece of\ntext that tells anyoneelse who would want to use it\nin the future-- other people,maybe yourself-- it tells\nthem how to use this function.What inputs does it take?What's the type of the inputs?What is the function\nsupposed to do?And what is the output that\nyou're going to get out of it?So they don't need to know\nexactly how you implementedthe function.They just need to know\ninputs, what it does,what's the output.", "start": 480.0, "heat": 0.1}, {"text": "Those three things.OK so these functions are\nthen reusable chunks of code.And we'll see in a few\nexamples in today's lecturehow to write some and\nhow to call functions.And as we're going\nthrough today's code,I want you to sort of\nthink about functionswith two different hats on.The first hat is from someone\nwho's writing the function.So in the projector\nexample, someonehad to build the\nfirst projector.Someone had to know how to put\nall these components together.So that's going to be\nyou writing a function,so you need to know how\nto make the function work.And then the other hat\nis you as someone--as a programmer-- who is\njust using the function.You're assuming it's already\nbeen implemented correctly,and now you're just\nusing it to do something.So these are some of the\nfunction characteristicsand we'll see an example\non the next slide.So a function's\ngoing to have a name.You have to call it something.It's going to have\nsome parameters.These are the inputs\nto the function.You can have 0 inputs or\nas many as you'd like.Function should\nhave a docstring.This is how you\nachieve abstraction.So it's optional, but\nhighly recommended,and this is how you\ntell other peoplehow to use your function.Function has a body, which\nis the meat and potatoesof the function-- what it does.And a function's going\nto return something.It computes its thing and\nthen it gives back-- spitsback some answer.OK here's an example of\na function definitionand a function call.Function definition is up here.I'll just draw it here.This is the function\ndefinition up here.And this is the\nfunction call down here.So remember, someone has\nto write the function thatdoes something to begin with.So this is how you\nwrite the function.", "start": 600.0, "heat": 0.136}, {"text": "The first is\nwhoops-- the first isgoing to be this def keyword.And def stands for--\nit tells PythonI'm going to define a function.Next is the name\nof the function.In this case, I'm calling\nthe function is_even.And the function\nname should reallybe something descriptive.Whereas someone who is\njust using this functionor looking at it can\npretty much tell whatit's supposed to do without\ngoing a lot farther than that.They're just\nlooking at the name.And then in parentheses you give\nit any parameters, also knownas arguments.And these parameters are\nthe inputs to the function.And then you do colon.OK so this is the first line\nof the function definition.And after this,\neverything that'sgoing to be part of the function\nis going to be indented.The next part is going\nto be the docstring,or the specification,\nand this ishow we achieve abstraction\nusing functions.Specification, or the docstring,\nstarts with triple quotesand ends with triple\nquotes, and you can sort ofthink about this as\na multi-line comment.It's just going\nto be text that'sgoing to be visible to\nwhoever uses the function,and it should tell them\nthe following things: Whatare the inputs to the function?What is the function\nsupposed to do generally?And what is the function\ngoing to give backto whoever called it?The next part is going to\nbe the body of the function.We'll talk about what's\ninside it in the next slide.And that's it.That's all for the\nfunction definition.def blah, blah, blah, indented,\neverything inside the function.So this is you writing\nthe function definition.Once the function\ndefinition's written,", "start": 720.0, "heat": 0.227}, {"text": "you can call the function.And that's this part down here.And here, when\nyou call function,you just say its name, and\nthen you give it parameters.And you give it\nas many parametersas the function is expecting--\nin this case, only oneparameter.So what's inside\nthe function body?You can put anything\ninside the function body.You remember,\nthink of a functionas sort of a small procedure\nor a little mini-programthat does something.So you can do anything\ninside the functionthat you can do in the regular\nprogram-- print things,do mathematical\noperations, and so on.The last line is the most\nimportant part of the functionthough.And it's this return statement--\nthat's what we call it.So it's a line of code\nthat starts with return,which is a keyword.And then it's going\nto be some value.Notice this is an\nexpression here--i%2 == 0 is an expression\nthat's going to evaluate to somevalue.And as long as this\npart is somethingthat evaluates some value,\nit can be anything you want.And this line here return\nsomething tells Python, OKafter you have finished\nexecuting everythinginside the function, what\nvalue should I return?And whoever called\nthe function isgoing to get back that\nvalue, and the functioncall itself will be\nreplaced by that value.OK so let's look at an example.I'm going to introduce\nthe idea of scope now.And scope just means-- is\nanother word for environment.So if I told you that you\ncould think of functionsas little mini-programs,\nthe scope of a functionis going to be a completely\nseparate environment", "start": 840.0, "heat": 0.129}, {"text": "than the environment\nof the main program.So as soon as you\nmake a function call,behind the scenes\nwhat Python says is,OK I'm in the main program\nbut I see a function call.I'm going to step out\nof this main program.I'm going to go off into\nthis new environment.I'm going to create entirely\nnew set of variables that justexist within this environment.I'm going to do\nsome computations.When I see the return, I'm going\nto take this one return value.I'm going to exit\nthat environment,and then I'm going to come\nback to the main program.So as you're entering\nfrom one scope to another,you're sort of passing\nthese values back and forth.So when you're entering a scope,\nyou're passing a variable backinto the function.And when the\nfunction's finished,you're passing a value\nback to whoever called it.So once again, this top part\nis the function definition.And any arguments for\nthe function definitionare called formal parameters.And they're called\nformal parametersbecause notice they don't\nactually have a value yet.In the function\ndefinition, you'resort of writing the function\nassuming that, in this case,x is going to have some value.But you don't know\nwhat it is yet.You only know what\nvalue x takes when youmake a function call down here.So this is your\nfunction definition,and then later on in\nyour main program,you might define some\nvariable x is equal to 3.And then you make\na function call.f of x here is\nyour function call.And it says, OK I'm\ncalling f with the value 3,because x takes the value 3,\nand then I'm going to map 3into the function.The values that are passed\ninto the function callare called actual parameters,\nbecause they're going actuallyhave a value.So let's step through this\nprogram-- this small program--", "start": 960.0, "heat": 0.1}, {"text": "and see what exactly happens\nbehind the scenes in the scope.And if you're just\nstarting to program,I think it would be\nhighly valuable if youtake a piece of paper as you're\ndoing some of these exercisesand you write down\nsomething similar to whatI'm going to go through here.I think it'll help\na lot, and you'llbe able to see exactly\nstep-by-step what variablestake what values and\nwhich scope you're in.So here we go.When the program\nfirst starts, we'recreating this global scope.It's the main program scope.In the main program\nscope, the first thingthat Python is going\nto see is this parthere-- def f of x and\nthen some stuff inside.This tells Python I\nhave a function named x,but I don't care what's\ninside the code yet.I don't care what's inside\nthe function definitionyet, because I haven't\ncalled the function yet.So to Python it's\njust some code justsitting in the global scope.So whenever you see\ndef, you're justputting some code in there.Then you go onto the next\nline-- x is equal to 3.So in the global scope, you now\nhave also a variable x is 3.And then the next\nline-- z is equal to fof x is a function call.As soon as you hit\na function call,you create a new scope--\na new environment.So we're temporarily leaving\nthe global scope and sortof portaling into a\nnew scope, where we'regoing to try to figure out what\nthis function's going to doand what it's going to return.So the first thing you do\nis you map the parameters.So x here-- I'm\ncalling f of x with 3--so first thing I'm\ndoing is I'm mappingevery one of the parameters in\nthe definition to their values.So first thing I'm doing\nis x gets the value 3.Next line here is x\nis equal to x plus 1.", "start": 1080.0, "heat": 0.108}, {"text": "So we're still inside\nthe function call f,so x gets the value 4.We're printing this and\nthen we're returning x.So in the scope of\nf, x is equal to 4,so we're returning\nthat value backto whoever called it,\nwhich was this functioncall within the global scope.So this part right here-- f\nof x, which was the functioncall-- gets replaced with 4.So inside the main\nprogram, z is equal to 4.And that's how we pass\nparameters into the function,and we got a parameter\nback from the function.As soon as the function\nreturns something,the scope that you were in\nfor the function gets erased.You forget about every variable\nthat was created in there,delete that scope, and\nyou're back to whereveryou started calling it.One warning though.So what happens if there's\nno return statement?I said that every function\nhas to return something.If you don't explicitly\nput a return statement,Python is going to\nadd one for you.You don't have to do this.And it's going to actually\nhave return None-- N-o-n-e.And None is the\nspecial type-- Noneis the value for a special\ntype called NoneType,and it represents the\nabsence of a value.What's that?Not a string.Not a--None is not a string.None is not a string, exactly.It's a special type.OK so before we go on, I wanted\nto go through a small exercisein Spyder just to show\nyou the differencethat None and printing\nand returning makes.So here are two\nfunctions that I wrote.One is is_even_with_return.That's its name, so\npretty descriptive.It's pretty much the same\ncode we saw in the slides.", "start": 1200.0, "heat": 0.332}, {"text": "It just has this extra\nlittle print thing.It gets the remainder\nwhen i is divided by 2.And it returns whether the\nremainder is equal to 0.So it'll either return a\ntrue or a false-- a Boolean.OK so my function call is this:\nI'm saying is_even_with_returnwith a value 3.When I make this\nfunction call, this 3gets mapped into here--\nthis variable here--so i is equal to 3.I'm going to print with\nreturn, and then I'mgoing to say remainder\nis equal to 3 percent2, which comes out to value 1,\nbecause there's a remainder 1.And I'm going to\nreturn whether 1is equal to 0, which is false.So this line here\nreturns false, but am Idoing anything with the false?Not really.It's just sort of\nsitting in the code here.So this gets evaluated to false.I'm not printing it.I'm not doing any\noperations with it.It's just sitting there.So it won't show up anywhere.If I want the result\nto show up somewhere,then I have to print it.So that's what this\nnext line is doing.So that one should\nbe straightforward.is_even_without_return's\na little bit trickier,but not too bad.I have print,\nwithout_return inside here,and then I'm going\nto get a remainder isequal to i percent 2.And notice that I'm not--\nI don't have any return.So implicitly, Python's going\nto add a return None for me,like that.You don't have to add it.So when I make the\nfunction call here,it's going to do the same thing,\nexcept that return in this caseis not going to be a Boolean.It's going to be\nthis special None.So this is going to\nget evaluated to None.Again I'm not printing it out.It's just sitting there.If I were to print out\nthe result of that,", "start": 1320.0, "heat": 0.171}, {"text": "you'd be printing out this\nvalue None, which if I run it,you'll see here it just\nprints it out right there.So as you're doing your next\np set, it's about functionsand you're seeing these Nones\npopping out in some places.Check to make sure that you've\nactually returned something,as opposed to just printed\nsomething inside the functionlike we did here.All right so that's\nthe difference.And the last thing I want to\nmention about this is_evenfunction is how\nuseful it can be.So notice this is the\nfunction as in the slides,and once you write the\nfunction once, you can use itmany, many times in your code.So here I'm using\nthe function is_evento print the numbers\nbetween 0 and 19, includingand whether the\nnumber is even or odd.So notice this\npiece of code here,once I've written\nthis function is_even,looks really, really nice right?I have for all the numbers in\nthis range if the number i iseven, this is going to\nreturn a true or falsefor all the numbers\n0, 1, 2, 3, 4.If it's true, then I'm\ngoing to print out even,and otherwise I'm\ngoing to print out odd.So if I run this,\nit's going to do this.0 even, 1 odd, 2\neven, and so on.So notice using functions makes\nmy code really nice looking.If I wasn't using\nfunctions, I'd haveto put these two lines\nsomewhere inside hereand it would look a\nlittle bit messier.So I've said this\nmaybe once or twicebefore: in Python\neverything is an object.Might not have meant\nanything back then,but I think you're\ngoing to see what I mean", "start": 1440.0, "heat": 0.273}, {"text": "using this particular example.So if in Python everything's an\nobject-- integers are objects,floats are objects, even\nfunctions are objects.So as you can pass objects\nas parameters back and forthas function parameters, you\ncan also pass other functionsas parameters.Let's see what this means.So we have three function\ndefinitions here-- func_a,func_b, and func_c.And then I have three lines of\ncode here in my main program.So I have one called a\nfunc_a, one called a func_b,and one call to func_c.Let's trace through, just\nlike in the previous example,and see what exactly happens.First thing I create\nis my global scope.And I have three\nfunction definitions.Again I don't care\nwhat's in the codeyet, because I haven't\ncalled the functions yet.Python just knows there's these\nfunctions with these names thatcontain some code.After these definitions, I\ncome to this line here-- printfunc_a.As soon as I make\na function call,I'm going to create\na new scope and I'mgoing to hop into there.Inside func_a, I'm going to go\nand look at what func_a does.It doesn't take\nin the parameters,it just prints out\nthis message here.And then it leaves; it's done.There's no return,\nso we return None.So func_a returns\nNone to whoevercalled it, which\nwas that line there,so that is going to be None.Next line.This one right here-- print\n5 plus some function call.Again I'm going to hop\ninto func_b's scopeand see what to do there.So first I'm going\nto map my parameters.So 2-- whoops-- 2\ngets mapped to y.", "start": 1560.0, "heat": 0.175}, {"text": "So inside func_b's scope, y\nis going to get the value 2.That's the very first\nthing I'm doing--mapping all the parameters.Then I'm going to\nprint this thing here,and then I'm going to return y.So inside func_b,\ny has the value 2,and I'm returning 2 back\nto whoever called me.So this is the value\n2 and I'm goingto print 5 plus 2, which is 7.Last one.This is the trickiest.Oop, that popped up.If you think you've got\nit, try that exercise.But otherwise follow along.print func_c func_a.So I see that I am going\nto enter func_c's scope.So I'm going to look\nat what func_c does.First thing I do is I'm\nmapping all the parameters.Don't even worry about\nthe fact that thisis a function right now.Just pretend it's\nx or something.So you say func_a\nis going to getmapped to the variable\nz inside func_c.So z is func_c.Just mapping parameters\nfrom actual to formal.Then what do we\ndo inside func_c?We print out inside func_c,\nand then we return z.This is the cool part.Inside func_c, z is func_a.So if you replace z\nwith func_a, this herebecomes return func_a\nopen close parentheses.Look familiar?We did that function\ncall right there right?So that's just\nanother function call.So with that being\nanother function call,you're going to\ncreate another scope,and you're going to\npop into that one.So we're one, two, I\nguess two scopes deep,and we're trying to figure\nout where we're going.So func_a's scope is\ngoing to be up here.", "start": 1680.0, "heat": 0.241}, {"text": "So what does func_a do?It just prints out this,\nand it returns None.So we're going to\nreturn None to whoevercalled us, which was func_c.So this line here\nbecomes return None.And so this line here\nis going to return Noneto whoever called it, which\nwas this line down here.Oops, I didn't mean\nto cross that out.So that line here is\ngoing to print None.So if you just go\nstep-by-step, itshouldn't be too\nbad to try to mapwhat happens with variable\nnames and formal parametersand actual parameters.That's why I highly recommend\npieces of paper and pens.One last thing I want\nto mention about scopebefore we do another example.So there are three\nsort of situationsyou might find yourself in.The first one is probably\nthe most typical,and this is when you\ndefine a function.And it's using a\nvariable named xin this case that's also\ndefined outside of the function.And that doesn't matter\nbecause of the idea of scopes.So inside the global scope,\nyou can have variables x.When you're inside\na different scope,you can have whatever\nvariable names you want.And when you're\ninside that scope,Python's going to use\nthose variable names,so they don't interfere\nwith each other at all.So in this example, I've defined\na variable x is equal to 1,and then I incremented, and that\ndoesn't interfere with the factthat we have a\nvariable x outside.This one's a little\nbit trickier.I define this function\ng, and all g doesis access a variable x.But notice inside g, I've\nnever actually declaredor initialized a variable x.In this f, I said\nx is equal to 1.", "start": 1800.0, "heat": 0.39}, {"text": "But in here, I'm\njust sort of using x.So this does not\ngive you an error.In fact it's OK for you\nto do this in Python.Python says, OK\nI'm in this scope,but I don't have\na variable namedx, so let me just go into the\nscope of whoever called me.So I'm going to just\ntemporarily hop out of the scopeand see is there\nvariable x outside of me?And it'll find this\nvariable x here,and it's going to\nprint out its values.So that's OK.This last example here\nis actually not allowedin Python-- similar to\nthis one-- except that I'mtrying to increment\na value of x,but then I'm also\ntrying to reassign itto the same value of x.The problem with that is I\nnever actually initializedx inside h.So if I said-- if inside\nh, I said x is equal to 1,and then I did x\nplus equals to 1,then it would be this\nexample here-- f of y.But I didn't do that.I just tried to access\nx and then incrementedand then tried to reassign it.And that's actually\nnot allowed in Python.There is a way around it\nusing global variables.But it's actually frowned\nupon to use global variables,though global variables\nare part of the readingsfor this lecture.And the reason why\nit's not a great ideato use global variables is\nbecause global variablessort of give you this\nloophole around scopes,so it allows you to write code\nthat can become very messy.So using global variables,\nyou can be inside a functionand then modify a\nvariable that's definedoutside of your function.And that sort of defeats\nthe purpose of functionsand using them in writing\nthese coherent modules thatare separate.", "start": 1920.0, "heat": 0.193}, {"text": "That said, it might sometimes be\nuseful to use global variables,as you'll see in a\ncouple lectures from now.OK cool.So let's go on to the\nlast scope example.OK this slide is here,\nand notice I've bolded,underlined, and italicized\nthe Python Tutor,because I find it\nextremely helpful.So the Python Tutor--\nas I've mentionedin one of the assignments--\nit was actually developedby a grad student here,\nor post-grad studentslash post-doc here.And it allows you to go\nthrough Python, paste a code,go through it step-by-step.Like with each\niteration, it'll show youexactly what values\neach variable has,what scope you're in,\nwhen scopes get created,when scopes get destroyed,\nvariables within each scope.So pretty much\nevery single detailyou need to sort of\nunderstand functions.As we're starting to-- you can\nsee we've had couple questions,and these were great questions.So if you're still trying to\nunderstand what's going on,I would highly suggest\nyou take a piece of codeand just run it in\nthe Python Tutorand you should be able to\nsee exactly what happens,in sort of a similar way\nthat I've drawn my diagrams.In all of the codes for\nthis particular lecture,I've put links to\nthe Python Tutorfor each one of those exercises.So you can just copy\nand paste those,and it'll automatically\npopulate itwith that particular\nexample, so you justhave to click, step, step, step.OK so having made my plug for\nPython Tutor, let's go on.OK so here's an example.It's going to show\ncouple things.One is print versus return,\nand also this idea of youcan nest functions.So just like you could\nhave nested loops,nested conditionals-- you\ncan also nest functionswithin functions.", "start": 2040.0, "heat": 0.256}, {"text": "So let's draw some diagrams\njust like before of the scopes.First thing we're going to\ndo is when we have a program,we're going to create\nthe global scopeand we're going to add\nevery variable that we have.And then when we\nreach a function call,we're going to do\nsomething about that.So the first thing\nin the global scopeis this function definition.Again in my global scope,\nI just have g as some codebecause I have\nnot called it yet.I only go inside a function\nwhen I make a function call.So g contains some code.So we're done with\n75% of that code.Next line is x is equal to 3.So I'm making x be a variable\ninside my global scopewith value 3.And then I have this\nz is equal to g of x.This is a function call.When I see a function call, I'm\ngoing to create a new scope.So here is the scope of g.With the scope of g, I'm mapping\nvariables to actual parametersto formal parameters.So the first thing\nI'm doing is I'msaying inside g what is the\nvalue of actual parameter x?And x is going to be the\nvalue 3, because I've calledg of x with x is equal to 3.Next, what I see\ninside this function--so this is the inside of the\nfunction-- is this bit here.It's another\nfunction definition.Again since I'm just\ndefining the functionand I'm not calling it, all\nPython sees is h is some code.I haven't called\nthe function h yet,because I'm just defining\nit here with def.So that finishes this part here.", "start": 2160.0, "heat": 0.368}, {"text": "The next line is x\nis equal to x plus 1.So inside the scope of g,\nI'm incrementing x to be 4.Then I'm printing out this line.And then I've reached here-- h.This is actually a function\ncall, and I'm calling h.As soon as I make\na function call,I'm creating another scope.So I'm temporarily going\nout of the scope of gand going into the scope of h.So Python knows that\nh contains some code,and now I can go inside h\nand do whatever I need to do.So the first-- so h doesn't\nhave any parameters,so I don't need to populate\nanything like that in there.h does define a variable called\nx, which is abc; it's a string.And then that's all h does.What does it return?None.I heard murmuring,\nbut I think Nonewas what you guys were saying.So since there's no\nreturn statement,h is going to return None.So h returns None.Back to whoever called it,\nwhich was this code inside g.So that gets\nreplaced with None--the thing that I've--\nthis circled red h here.As soon as h\nreturns, we're goingto get rid of that scope--\nall the variables createdwithin it-- and\nwe're done with h.So now we're back into g.And we just finished\nexecuting thisand this got replaced with None.We're not printing it out, so\nthis doesn't show up anywhere;it's just there.So we're finished\nwith that line.And the next line is return x.So x inside g is 4,\nso 4 gets returnedback to whoever called it, which\nwas in the global scope here.So this gets replaced with 4.So once we've returned x,\nwe've completely exited out", "start": 2280.0, "heat": 0.425}, {"text": "of the scope of g,\nand we've come backto whoever called us,\nwhich was global scopeand we've replaced\nz is equal to gof x and that completely\ngot replaced with 4-- thereturned value.So that's sort of\nshowing nested functions.All right just circling back\nto decomposition-abstraction.This is the last slide.You can see if you look\nat the code associatedwith today's lecture, there\nare some other exampleswhere you can see\njust how powerful itis to use functions.And you can write really\nclean and simple codeif you define your own functions\nand then just use them later.And the beauty of defining\nyour own functionsthat you can use\nmultiple times lateris you only have to debug\nthe function once right?I know debugging is not\nyour favorite thing,but you only have to\ndebug this one thing once,and then you can know that\nit's right and it works well,and you can just use\nit multiple times.All right thanks everyone.", "start": 2400.0, "heat": 0.274}]