[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help MIT\nOpenCourseWare continue tooffer high quality educational\nresources for free.To make a donation or view\nadditional materials fromhundreds of MIT courses, visit\nMIT OpenCourseWare atocw.mit.edu.PROFESSOR: Good morning.AUDIENCE: Good morning.PROFESSOR: Thank you.OK.So we're about to launch into\nlearning some basic elementsof Python today.The elements I'm going to talk\nabout are common to everyprogramming language that I\nknow, at least in concept, andof course slightly different\nin detail.But as I said last time,\neverything you're going tolearn about Python should\nbe readily transferable.I'll be using, for all of the\nexamples I present, somethingcalled an integrated development\nenvironment, andin particular, one that's built\nfor Python called IDLE.Usually we talk about these\nthings as IDEs.I'm told, I don't know if it's\ntrue, that the IDE for Pythonis called IDLE after Eric Idle\nof Monty Python, which wasalso, I'm told, the inspiration\nfor the name ofthe programming language.So what is an integrated\nprogramming environment?", "start": 0.0, "heat": 0.138}, {"text": "In this case, it includes a\nspecialized text editor thatprovides highlighting,\nauto-completion, smart indent,and you'll see shortly why all\nthat's very important, and afew other amenities that make it\neasier to use this to typePython than typing it into\na generic text editor.It includes something called\na shell, which is theenvironment that actually\ninterprets the Python code.And the nice thing about it\nis it includes syntaxhighlighting.So the shell gives you some\ninformation about the syntax,as does the text editor\nof course.And finally, it includes\nan integrated debugger.This could be useful in the\nunlikely event that yourprograms have errors when\nyou write them.Though truth be told, I've been\nprogramming in Python foryears and I don't know that I've\never used the debugger.It's not that I don't make\nmistakes, it's just that I'mkind of a Luddite, and I\ntypically use print statementsfor debugging.And in fact, almost every\nprogrammer that I know, whenpush comes to shove, ends up\nusing print statements.But the debugger is there,\nshould you care to take a try.All right.So you'll see on the screen\nhere an IDLE shell.In the shell, we can\ntype things.What are we going to type?Well the first thing to\nunderstand is that at the coreof Python, and probably the\nmost important thing to", "start": 120.0, "heat": 0.179}, {"text": "understand, are something\ncalled objects.Everything in Python\nis an object.So every kind of entity that you\ncan create in Python is anobject, and in fact, Python\ncode itself is an object.You'll remember, we talked about\nstored program computerslast time, and the concept that\na program is data, justlike a number is data.Each object has a type that\ntells us the kind of object itis, and in particular, what\nwe can do with it.And then there's a built-in\nfunction, called type, thatcan be used to find out\nthe type of an object.As we'll see, there are two\nfundamental kinds of types.Scalar and non-scalar.We'll start with talking\nabout scalar types.And the key thing to think about\nthere is that they areindivisible.Think of them as the atoms of\nthe programming language.Now, I know that some of you\nhave studied physics and knowthat atoms are in principle\ndivisible, but of course, onlyat great expense and with\nserious consequences.And we've seen the\nsame thing here.You can, if you're desperate,\nchop up these scalar types,but it almost always leads\nto something bad.", "start": 240.0, "heat": 0.152}, {"text": "All right.Well let's look at some.Well, the first one you'll see\nis used to represent integers,and that's called int.For every type, or every\nbuilt-in type, there's thenotion of a literal, which\nis how we type it.So for example, we can type 3,\nand that will now tell us itis the value 3.You'll note it's typed\nit in blue.And I can ask what\nthe type of 3 is.So you'll notice as I type\nthings into the shell, it'susing colors to give\nme a hint.So it's this fuchsia color for\nthe word type, telling methat's a built-in function.And now if I ask it, it will\ntell me that the type of theliteral 3 is \"int\".So it's an integer.And I can use other\nsorts of things.All right.There's also a type float.So those correspond to\nthe real numbers.So I can do something\nlike that.And we'll talk about this in a\nsecond, but you'll notice if Ido type of 3.2, it tells\nme it's a float.And for that matter, I can do\ntype of 3.0, and it will tellme it's a float.So there's a difference\nbetween 3 and 3.0.One is an int, and\none is a float.Now you'll notice something\nkind of weird here.When the interpreter printed\nback the value of the literal3.2, it gave me 3.2 and a bunch\nof zeroes, and then thisfunny 2 standing at the end.", "start": 360.0, "heat": 0.182}, {"text": "In a few lectures, I'll explain\nwhy it does this, butfor now, you should just take\nthis as a warning that floatsare not the same thing\nas real numbers.You learned about reals,\npresumably in middle school orhigh school.Floats are a computer\nscientist's approximation toreals, but they're not\nquite the same.The good news is almost all the\ntime, you can pretend thata floating point number is a\nreal, but as we'll see in afew lectures, every once in a\nwhile it can really sit up andbite you, if you believe that.But for now, we'll just pretend\nthat they're reals.There's Booleans, a nice scalar\ntype of which there areonly two values.One of them is true, and what\ndo you think the otherBoolean value is?AUDIENCE: False?PROFESSOR: Thank you.So somebody said false.I have no idea who, but\nwhoever it is, there'sprobably some candy to be had.Oh, I managed to find the one\nplace in the room where therewas an empty.I'm hoping that people will now\nscramble and fight for it,like a foul ball at\na baseball game.No, people are too\npolite thus far.All right.So we have true and false\nas the type Booleans.And then we can do operations\non them.So for example, true and false\nis false, as you might guess.Finally, there's this funny\nvalue, none, which doesn'tprint anything when I type it.And if I look at the type\nof none, we'll seeit's the none type.Not very interesting.", "start": 480.0, "heat": 0.333}, {"text": "Fundamentally, as we'll see,\nthat gets used when you wantto put in something temporary.When you don't yet know what its\nvalue is going to be, youknow it's going to eventually\nhave one, so maybe you startout calling it none.And then you can check,\nand we'll seehow we might do that.So those are the fundamental\nscalar types,the indivisible ones.Interestingly enough, Python\ndoes not have what is a commonscalar type in every other\nlanguage called char, shortfor character.Instead, what it has is strings\nthat can be used torepresent strings\nof characters.So for example, I can write the\nstring \"a\", and if I askfor the type of it, it\ntells me it's anstr, short for string.Happens to be a string of\nlength 1, which we mightusually think of as\na character, butthere is no type char.So it's not a problem.We just have to remember it.Literals of type string can be\nwritten with single quotes orwith double quotes.There's no difference.Just convenient that you can do\nit either way, and we canbuild strings of things.It's worth noting that the type\nof, say, the string 123is str, whereas the type of 123\nwithout the quotes is int.", "start": 600.0, "heat": 0.284}, {"text": "So we have to be a little bit\ncareful sometimes as towhether we're dealing with\nstrings or ints when we lookat these literals.You can only get so far with\nliterals, things you can type.So of course, Python has in\nit something called anexpression.Again, this shouldn't\nsurprise anybody.And an expression\nis a sequence ofoperands and operators.The operands are objects.So for example, we can write\nthe expression 3 plus 2.And when we type an expression\ninto IDLE, it automaticallyevaluates it and prints the\nvalue of the expression.In this case, of\ncourse it's 5.One thing to be a little careful\nabout is if I type theexpression 3/2, slash is the\ndivide operator, I get 1.Whereas if I type the expression\n3.0 dividedby 2.0, I get 1.5.So dividing two integers\nin Python 2.x gives youessentially a floor operator.In 3.0, by the way, integer\ndivision is not allowed.It always converts it to floats\nand does a floating", "start": 720.0, "heat": 0.249}, {"text": "point division.But for many of you this will\nbe something that will tripyou up as a bug.If you want to get real\ndivision, writefloating point numbers.Otherwise, unpleasant\nthings may happen.Some other interesting things\nI can type, just as I couldtype 3 plus 2, I can\ntype a plus b.What do you think\nI'll get there?It does concatenation.So what we see here is that\nthe operator plus isoverloaded.So overloaded operators have a\nmeaning that depends upon thetype of the operands.And of course, we've already\nseen that with the slashoperator, which means one thing\nfor ints and anotherthings for floats.And of course, we see the\nsame thing with plus.What do you think will\nhappen here?3 blank 3?Any guesses?I get a syntax error.Remember, we talked about\nthat on Tuesday.It's not a valid Python\nexpression,so we get an error.", "start": 840.0, "heat": 0.294}, {"text": "How about this one?That is syntactically valid.It's got operand, operator,\noperand.What do you think it will do\nwhen I hit Return here?Somebody?AUDIENCE: A static\nsemantics error?PROFESSOR: Pardon?AUDIENCE: A static\nsemantics error?PROFESSOR: A static\nsemantics error.And because of these--Wait, I can't see\nwho said that.Raise your hand?Oh, come on.All the way back there?All right.I have the most chance of\ncarrying with one of these.I'm going to lie.Those of you who are watching\nOpenCourseWare, it was aperfect throw.OK.So indeed, we get a static\nsemantic error of a particularkind, called the type error,\nsaying you cannot concatenatean str and an int.Type errors are actually\ngood things.The language does type checking\nin order to reducethe probability that a\nprogrammer will write aprogram with a meaning that\nwill surprise its author.So it looks at it and says,\nsomebody might have a weirdguess what this means, but just\nto be safe, we're goingto disallow it rather than--it could, of course, make\nup some funny meaningif it wanted to.But it doesn't.And I think you'll find type\nchecking saves you from a lotof careless programming\nerrors as you go on.All right, let's continue.Let's look at some\nother things.I can write this.", "start": 960.0, "heat": 0.347}, {"text": "Because that's just two\nstrings, and it justconcatenates them, the string\na and the string 3.Or interestingly,\nI can do this.So now what we're seeing is\nthat you can take any typename, use it as a conversion\nfunction to attempt to convertone type to another.So this has now converted the\nint 3 to the str \"3\".Similarly, I can do something\nlike this.And here, it's converted the\nstr \"3\" to the int 3.On the other hand,\nI could do this.And it will tell me it's a\nstatic semantic error.It can't convert 0.0\ninto an int.Similarly, it can't\nconvert 2.1.Or can it?So now I've given it the float\n2.1, and I've tried toconvert it to int.Not the string 2.1,\nbut the float.And it succeeds.And it succeeded by essentially\ntruncating it.Is this a good thing\nor a bad thing?To me, it's kind\nof a bad thing.", "start": 1080.0, "heat": 0.368}, {"text": "If I've typed something like\nthat or I've evaluated someexpression that happened to\nwork that way, more likelythan not, I'm confused.And I would probably have\npreferred to get a type error,rather than it deciding\nhow to do it.It's one of the things I don't\nlike about Python.It's too generous.It lets me get away with\nstuff it shouldn'tlet me get away with.Other languages, for example\nJava, are much stricter.This is a design decision and\nit is the way it is, and wehave to live with it.AUDIENCE: Professor?Yes?AUDIENCE: Is that the same\nreason that 3 divided by 2turned into 1 up top?PROFESSOR: Yeah.Exactly.If it's the same reason that\nthat happens, this will nevergo that far.[UNINTELLIGIBLE].Yeah, exactly.It's the same reason.The question was, is it the same\nreason that 3 divided by2 doesn't give you the\nanswer you would getwith floating point.And it's because Python\nhas tried to help you.Again, Python 3.0 is a little\nstricter about these things.We'll talk much more about\nthis during the term.This is close to the last time\nyou'll see me typing thingsdirectly into IDLE.For the most part, as you write\nprograms, you'll use thetext editor to produce them\nand then go to theshell to run them.But you want to--obviously, if I had a 100 line\nprogram, I wouldn't want tosit here and retype it every\ntime I needed to change it.So instead, I use the editor\nin IDLE to produce theprograms, and then\nI can run them.And that's what I wanted\nto start doing.I should probably mention that\nwhat most people call aprogram, some Python programmers\ncall a script.", "start": 1200.0, "heat": 0.339}, {"text": "Think of those two things\nas synonyms.But you will see people\nuse both of them.I will typically call\nthem a program.All right.Let's look at an example.So the first thing to say is\nthat things look a little bitdifferent when they're executed\nfrom a script thanwhen you execute them directly\nin the interpreter.So I happen to have\na script here.If a line in a script starts\nwith a sharp sign or a numbersign, that makes it a comment.So it's not executed.So I've started here just by\ncommenting out everything.But now--whoops--what happens if I just put\nthe number 3 here?We saw when I typed it into\nIDLE, it echoed it in somesense and gave me what it was.Or just to be clear, I'm\ngoing to put in theexpression type of 3.I'll save it, and then I'll\nhit F5 to run it.And it does nothing.Right?You saw it move.It didn't print anything.So when you type an expression\ninto the shell,it prints the value.But when it executes a script\nwith an expression, itevaluates the expression\nbut does notdisplay it on the screen.Well, so what do we\ndo about that?There is something called\na print command.So I can do this, Print type of\n3, and now if I run it, it", "start": 1320.0, "heat": 0.329}, {"text": "will actually appear.So whenever you want to get\nsomething to appear, you haveto use the Print command.Not a very complicated\nconcept.A program, or a script, is\na sequence of commands.Each one tells the interpreter\nto do something.So a command is Print,\nfor example.OK.So that's there.That's kind of boring.I'll get rid of that.The next command is a really\ninteresting one.It's an assignment statement.A key concept in almost every\nprogramming language is thatof a variable.Different languages have\ndifferent notions of what avariable means.In Python, a variable is simply\na name for an object.And what an assignment statement\ndoes in Python, isit binds the name\nto an object.", "start": 1440.0, "heat": 0.351}, {"text": "So the assignment stetement you\nsee here binds the name xto the object 3.The next statement rebinds the\nname x to the value of theexpression x times x.So it takes the old value of x,\nevaluates the expression,and then binds the name\nx to the new value.So at the end of the\nsecond statement, xwill be bound to 9.By the way, these are really\nstupid commentsI've written here.I put them in just to\nshow you what thesestatements are doing.For goodness sake, when you\nwrite comments in yourprograms, assume that the reader\ncan read Python, andyou don't have to explain\nthe programminglanguage in your comments.That's not to say you shouldn't\nwrite any comments.The purpose of a comment\nis to make theprogram easier to read.And so typically, comments are\nthere to explain things.Not to explain the language or\nits semantics, but to explainyour thinking when you\nwrote the program.What is the algorithm\nyou've used?And we'll see some useful\nexamples of comments, probablynot today, but later.All right.So let's execute this script.Sure enough, it printed 9.Just what we would have hoped.All right.Now let's try some\nother things.Print lets us output things.", "start": 1560.0, "heat": 0.186}, {"text": "Raw input lets us\ninput things.Get things from the keyboard,\nessentially.So this statement here is making\na request to whoever isusing the program to\nenter a number.There are two kinds of input\nstatements in Python 2.x.There's raw input, which is the\nonly one you will see meuse, and input.Raw input, by the way, is the\nonly one that exists in 3.0.So please, just use raw input.The difference is, raw input\nalways expects, interpretswhat the user types\nas a string.So it will see here, it says,\ny equals float of raw input.Enter a number.So let's run it.So it's taken the argument to\nraw input, the string enter anumber asked me to\nenter a number.I'll enter a number.And then it's converted\nit to a float.Suppose I get rid of that.Suppose I do this.That should work.", "start": 1680.0, "heat": 0.1}, {"text": "So now something has happened.It's printed both\nof them as 3.0.It looks like they're\nthe same, but infact, they're not.And this is something\nto beware of.What we've seen here is when\nit prints a string, it doesnot print the quotation marks.So even though, if I were to put\nthis in here, I'll put intwo print types of y.And I'll comment this out\nbecause I'm getting kind oftired of seeing 9.You'll note that one\nis a string andthe other is a float.Again, I point this out because\nthis is something thatcan confuse people when they're\ndebugging programs.Because you think it's\na float, whenin fact it's a string.OK.Nothing deep, but these are the\nthings that sort of getpeople in trouble.Now the kinds of programs we've\nbeen looking at so farare what are called straight\nline programs.What distinguishes a straight\nline program is it's asequence of commands you execute\none after another.You execute every command\nwithout making any deviations,without going back with any\nloops to execute a command", "start": 1800.0, "heat": 0.1}, {"text": "more than once.So in a straight line program,\nevery command gets executedexactly once.There is a very elegant, and\neven useful theory that talksabout different layers of,\nlevels of complexity ofprograms and says, for\nexample, what kind offunctions can you compute with\nstraight line programs.We'll talk more about that\nfield, which is calledcomplexity theory, later\nin this semester.But for now, the thing to\nrealize is that straight lineprograms are just dead boring.You can't compute anything\ninteresting with one.Last time we talked about\na recipe as ananalogy for a program.Imagine a recipe\nwith no tests.So every recipe, or almost\nevery recipe Iknow, has some decisions.Taste it and add salt\nif you need it.Or poke at the meat and\nsee if it's done.Or cook it until the\nthermometer sayssome degree on it.Those are the kinds of\ntests we need tomake interesting programs.The most primitive kind of test\nwe see is what's called aconditional statement.And those are written using the\nword if, and optionally aswe'll see, the words else or\nelif, standing for else, if.So let's look at an\nexample here.Where'd my mouse,\noh there it is.", "start": 1920.0, "heat": 0.108}, {"text": "Yes?Somebody has a question?Shout it out.AUDIENCE: Sorry.I was wondering, when the user's\nprompted to put in theraw input, instead of putting\nin a float, puts in string,could you define it as\na floating integer?How would you interpret\nthat input?PROFESSOR: I didn't\nget the question.So this is an argument to\nraw input, or theirresponse to raw input.AUDIENCE: So yeah, for the\nraw input where youdefine it as a quote--PROFESSOR: Yeah.AUDIENCE: It usually\nputs in a string.How does Python interpret\nthat?PROFESSOR: It will interpret\nit as a string containingquotation marks.AUDIENCE: OK.PROFESSOR: So typically you\ndon't type a string, becauseit interprets everything you\ntype as if it were a string.So don't bother typing\nstrings.Good question.Thank you.All right.So let's look at this.So here I'm going to get an\nint, or at least a string.I'll convert it to an int.Then I'll say, if x remainder\ntwo, that's what the percentsign is, it's a remainder\nor a mod operator,is equal equal zero.That's important.You'll notice that we used an\nequal sign to do assignments.If we want to do a comparison,\nwhether two objects have thesame value, we don't write\na single equal.We write a double equal.So whenever you're testing for\nequality of objects, you usedouble equal.So it says, if the object x mod\n2 has the same value asthe object zero, print even.Else, print odd.And then, just for fun, I'm\ngoing to see whether or not", "start": 2040.0, "heat": 0.204}, {"text": "it's divisible by three.Why did I do that?Just to show you that I can\nnest conditionals insideconditionals.So in one of the branches of\nthe conditionals, I'm nowdoing a test.So what this does, is if comes\ndown, it does the test.If the value of the test is\ntrue, it executes the block ofcode following the if, in\nthis case, just print.And then it skips the else.It does not execute the else.So it executes one\nor the other.If the test is false, it skips\nthe block of code followingthe if and executes the block\nof code following the else.So it does a or b,\nbut not both.The indentation is important.Python is very unusual in that\nthe way you indent thingsactually affects the\nmeaning of them.And you can tell that, if I\nwere to type this in theeditor, you'll note here it's\non that line, but if I hitReturn, it automatically\nindents it.That's the auto indent feature\nI mentioned earlier in theeditor of IDLE.And this tells me how these\nthings line up.So the fact that this is here\ntells me I execute it only aspart of the else clause.The program would mean something\nquite different if Iwrote this.Then it would mean, if x mod\n2 is zero, print even.Otherwise, print odd.And whether or not it was\neven or odd, do this", "start": 2160.0, "heat": 0.325}, {"text": "test in the if statement.So the indentation actually\naffects themeaning of the program.Now a lot of other languages,\nalmost all other languages,don't do that.They have some punctuation.For example, c uses set braces\nto designate what's called ablock of code.If you look, however, at a\nwell-written piece of C code,or Java code, or any other\nlanguage that I know,programmers are trained to use\nindentation to show thestructure of the program.Even though you don't need, it\nyou could line up everythingright at the left edge and\njust use the punctuation.People don't do that.And the reason they don't do\nthat is programs are intendedto be read, not just executed.Why are they intended\nto be read?Because the only reason, the\nonly way you can debug aprogram is reading\nthe code in it.Typically, you want to write\nyour program so that if youlook at it from a distance, the\nvisual structure of theprogram reflects the semantics\nof the program.And that's why people use\nindentation when they don'tneed to, so that you can see the\nstructure of the programby looking at it on your screen\nand not having to parseeach symbol.The authors of Python made what\nI think is a very gooddesign decision.They said, well, if that's the\nway you ought to write yourprograms, let's force people to\nwrite their programs that", "start": 2280.0, "heat": 0.173}, {"text": "way and guarantee that the\nvisual structure of theprogram actually matches\nthe semantic structure.The problem with languages like\nC and Java is that youcan indent things and fool the\nreader of the program bymaking it look like something is\nunder something else, whenin fact it really isn't, because\nof the punctuation.So here we have a guarantee\nthat the visual structurematches the semantic structure,\nand I think thatwas one of the really good\ndesign decisions in Python.OK, people see that?So we could execute\nthis program.Let me get back to what\nit was before.Control z is the go back.And now we can enter an integer,\nsay 14, and it willtell us it's even.I can run it again, and now I'll\nput 15 in, and it willtell me it's odd.We'll try it once more.We'll put in 17.It was odd and it's not\ndivisible by three.These kinds of programs are\ncalled branching programs.And that's because the structure\nof them, as you godown you execute some\nstatements, and then there's abranch which says execute these\nstatements or executethose statements.And then typically it comes back\ntogether and continues.", "start": 2400.0, "heat": 0.223}, {"text": "Of course, branches can\nhave sub-branches.We could do this and then\njoin further down,as we've seen here.Now branching programs are much\nmore interesting thanstraight line programs.We can do a lot of things with\nthem, but fundamentallynothing really interesting.And we can think about that by\nthinking about how long ittakes a branching\nprogram to run.So let's first ask the question,\nhow long does ittake a straight line\nprogram to run?14 seconds?No, that's not the way\nto think about it.How would we think about how\nlong it takes it to run?What governs the length\nof time a straightline program can take?AUDIENCE: [INAUDIBLE].PROFESSOR: Exactly.The number of statements or\ncommands in the program.Since it executes every command\nexactly once, if youhave 100 command, it will\nhave 100 steps in it.Now there's some variation on\nhow long each step will be.Some commands might take longer\nthan others, but thelength of time it can take\nto run has nothingto do with its input.It has to do only with the\nnumber of lines of code.And that tells us it's not very\nuseful because, well, wecan only type so many lines\nin our lifetime.Well branching programs\nhave the same problem.In a branching program,\neach command isexecuted at most once.So again, the length of time\nit takes to execute theprogram is governed strictly\nby the size of the program.Why isn't that good enough?", "start": 2520.0, "heat": 0.188}, {"text": "Well, think about a program,\nsay, to compute the GPA of allthe students at MIT.Well how long is that\ngoing to take?Think instead about a program to\ncompute the GPA of all thestudents at the University of\nMichigan, which is probably 10times bigger than MIT.Well you would expect that\nto take longer, right?Because you have to look\nat more students.And in fact, it's true.Most programs that are\ninteresting, the amount oftime they take to run should\ndepend not on the length ofthe program, but on the size of\nthe data that you want toevaluate using the program.So you would argue that the\namount of time taken tocompute the GPA of the students\nat MIT should beproportional to the number of\nstudents, not proportional tothe length of the program\nused to do it.We'll talk a lot more about that\nlater in the term in amuch more thorough way.But it's important to get that\nas something you think about.So the fact that branching\nprograms are not proportionalin time to the input means that\nthey're limited in whatthey can do.So that gets us to the final\nconcept we need to write everyprogram that could ever be\nwritten, or at least tocompute every function that\ncould ever be computed.And that's some sort of\na looping construct.Once we add loops, we get to a\nclass of programming languages", "start": 2640.0, "heat": 0.117}, {"text": "or programming constructs that's\ncalled Turing Complete.And I mentioned this\nlast time.Any program that can be written,\nor any function thatcan be computed, rather, can\nbe computed in a TuringComplete language.So let's look at an\nexample here.This concept, by the way,\nis called iteration.And if we look at languages with\niteration, what we'll seeis a more complicated\nflow of control.You execute some statements,\nmaybe you do somebranching if you want.But then you're allowed to go\nback and execute statementsyou've already executed.Typically what you have\nis another branch.One branch goes back\nand one continues.So now we see we can execute\na statement more than once.Suddenly we have enormous\npower at our disposal.So let's look at an\nexample of that.By the way, I'm skipping some\nof the code in your handout,but that's probably fine because\nit's there for you tobe able to read.And what I would recommend by\nthe way, is that we will postthe handouts on the web, but\nat the end of every lecture", "start": 2760.0, "heat": 0.1}, {"text": "within a few hours or a few days\nat least, go through thehandouts and make sure you\nunderstand everything in.Because if you don't, you're\nprobably missing somethingyou'll need to understand\nto do the problem sets.So here's a little program that\nfinds the cube root of aperfect cube.This, by the way, is a useful\ncomment here, right?Tells you what the program\nis intended to do.So we get an integer.We set the variable\nans to zero.And then while ans times ans\ntimes ans is less than theabsolute value of x,\nwe're going to setans to ans plus 1.We could print where we are.I put those sort of things in\nas debugging statements.If ans times ans times ans is\nnot equal to the absolutevalue of x when I finish the\nloop, then I'll print x is nota perfect cube.Otherwise I have to do something\nto deal withpositive and negative values.Now I know that this was fast\nand that most of you probablydon't fully assimilate\nthis program.Do not worry.It will be discussed in\nrecitations tomorrow.So tomorrow, the recitations\nwill review the Pythonconcepts we've discussed today,\nbut we'll start byemphasizing how these\nloops work.OK.Thanks for coming.Enjoy recitation tomorrow.", "start": 2880.0, "heat": 0.132}]