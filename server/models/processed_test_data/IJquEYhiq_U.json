[{"text": "WOMAN: The following content\nis provided under a CreativeCommons license.Your support will help\nMIT Open Coursewarecontinue to offer high quality\neducational resources for free.To make a donation or to\nview additional materialsfrom hundreds of\nMIT courses, visitmitopencourseware@ocw.mit.edu.NEHA NARULA: OK, so\nlet's get started.OK?So great.We're here to talk\nabout cryptocurrencyengineering and design.I think the first question that\ncomes up that's very obviousis what is a cryptocurrency?So this word was kind of\ninvented 10 years ago when--I don't know how many of you\nknow the origin story of wherebitcoin came from, but basically\na pseudonym on the internetdropped a paper and\nsome open source codein a forum on an email\nlist, and said, hey,I have this idea for this\nthing called bitcoin.It's kind of like\nelectronic cash.Here's how I think\nit could work,and here is some code if you\nwant to run it and become partof this peer-to-peer network.We don't know who\nthis person is.This person has basically\nvirtually disappearedfrom the internet\nand from the world.But it's created something\nthat has capturedso many people's imaginations\nand has sort of, dependingon how you measure\nit, created billionsand billions of dollars\nof economic valueand inspired a lot of\npeople to think about howto use this technology to solve\na myriad of different problems,not just electronic payments.So cryptocurrencies and\nthe technology behind themare inspiring people to think\nabout how to bank the unbanked,add more auditability and\ntraceability to our world,get rid of trusted\nintermediaries and institutionsin certain situations,\nand basically solveevery problem, if you read\nabout what blockchainscan do on the internet.Now that's not exactly\nwhat this class is about.This class is not going\nto be about applications.", "start": 0.0, "heat": 0.13}, {"text": "This class is going to be about\ntechnology and infrastructure.You're going to learn how to\ncreate a cryptocurrency, whatgoes inside a cryptocurrency,\nwhat's important,what are the techniques.And what application you choose\nto apply that to down the line,that's kind of up to you.But we're not going to be doing\ndigital identity or health carerecords or something like that.We're going to be talking\nabout the technology.So a big question is\nhow are cryptocurrenciesdifferent from\nregular currencies?And another thing that I\nwant to make really clearis that the terms in this\nspace are still being defined.So you will hear\npeople throw aroundall sorts of terms--\ncryptocurrency, blockchain,consensus.And these words kind of have\nfloating, evolving meaningsright now.Part of that is because bitcoin,\nthe first cryptocurrency,didn't come from academia,\nas far as we know.It came from a community of\nenthusiasts on the internet.And so it doesn't necessarily\nhave the same basis and rigorthat we might expect from\nmost of our academic fieldsof study.It's totally OK.We're figuring it\nout as we go along.And academia is really\nembracing this topic.So if any of you are\ngraduate students whoare looking for an area\nin which to do research,I think basically,\nthe number of paperspublished on cryptocurrencies\nand blockchain technologyin respected academic venues\nis doubling every year.So there's huge\nopportunity here.So cryptocurrencies are\nnot regular currencies.They're not $1.00 or\na pound or a euro,what we normally\nthink of as currency.They're something different.Bitcoin was sort of\ncreated out of nowhere.And what does it mean to\ncreate a cryptocurrency?Who says you can create\na cryptocurrency?What backs a cryptocurrency?Why is it valuable?Well, first, before we\nanswer that question,I just want to make\nit really clear whatthis course is not about, OK?We are not going\nto help you ICO.", "start": 120.0, "heat": 0.136}, {"text": "If you are interested\nin ICO'ing, just go.That's not what this class\nis going to be about.We are not going to\noffer any trading advice.We have zero opinions on\nwhether you should buy bitcoinnow or sell or\nwhatever, or zen cash,or whatever all\nthese things are.So none of that.Don't even ask us.We're not interested.And this class is\nnot really goingto be about permissioned\nblockchains either.Now you might not know\nwhat this term means yet,and that's totally\nOK, but I justwant to make it clear that\nwhat we're talking about hereare cryptocurrencies.They're open permission with\nsystems in which there isa token which has some value.So that's what we're not\ngoing to do in the class.So going back to--and let me just pause\nthere for a moment.Let me pause and ask you if\nthere are any questions so farabout what I've said.Yeah.AUDIENCE: Do they always\nhave to have value?NEHA NARULA: No, not at all.And let's start\nto get into that.So the question was do tokens\nalways have to have value?So I think, really,\nto understandwhat are cryptocurrencies, what\nare tokens, what do they mean,we have to talk about money.And we have to talk about what\nmoney is and what it means.So this is going to\nbe very hand-wavyand I'm sure not very satisfying\nto a real monetary economist.But money developed-- there\nare a few different theoriesabout how money developed.There is this thing called\nthe coincidence of wants.So maybe I have a sheep\nand Tadge has some wheat.I am hungry and would\nlike to make bread.Tadge would really\nlike to make a sweater.And so we can\nbarter, we can trade.I have one set of goods\nthat is useful to Tadge.Tadge has another set of\ngoods that are useful to me.We can get together\nand make an exchange.So that's fantastic.Barter is incredibly important.Barter has existed\nfor a long time.But what if Tadge doesn't have\nwheat, Tadge has vegetables,and I don't want vegetables.", "start": 240.0, "heat": 0.1}, {"text": "I want wheat.But Tadge still wants\nthe wool from the sheep.How do we execute this trade?We don't have a\ncoincidence of wants.We don't actually want the exact\nsame thing from each other.So some theories are that money\nevolved out of this problem.And money can be represented\nin so many different ways.Money, I think, was first\ncreated around 5000 BC,so it's really,\nreally, really old.The things that\nrepresented money usuallyhad certain properties.They were rare.They were not\neasily reproducible.People, at times, used things\nlike shells or beads for money.The first coins-- this is\nlike a really interesting cointhat was developed.Precious metals were\noften used for money.And then eventually\nwe sort of evolvedinto what we think\nof as money now,which is paper bills, currency.Another theory of\nhow money came aboutis this idea of receipts,\ndebt and credit.So maybe I have a sheep,\nand I shear all of my sheepand collect a lot of wool.What I can do is I can\nstore that wool somewhere.And I can get a\nreceipt from someonefrom having stored that wool,\nand that receipt is of value.It entitles the person who holds\nthe receipt to the good thatis being stored.And so another\ntheory of money isthat money evolved\nout of these receipts,trading these receipts\nback and forth.Instead of taking all\nthat wool with you,you leave it in one\nplace in a depository,and the receipt acts\nas a bearer instrument.Whoever owns it has access to\nthe wool in the depository.And so you can kind of\nsee two different ideasabout what money is\ndevelop from this.One is, well, it's\na bead or a coin,or something that\nI hold, somethingphysical that we've\ndecided to assign value toin and of itself.And another idea is I'm going\nto use a trusted institution.", "start": 360.0, "heat": 0.1}, {"text": "I'm going to deposit something\nwith that institution,and they are going to ensure\nthe validity of that depositand manage who has\naccess to that deposit.So this doesn't really\nget at the questionthat was originally asked, which\nis why do tokens have value.But one thing I want\nto point out is--well, a question I want\nto ask you guys, actually,is why do these\nthings have value?Does anyone have any ideas?Yes.AUDIENCE: Because everyone\nagrees that they do.NEHA NARULA: Because\neveryone agrees that they do.Any other thoughts on why\nthose things have value?Yeah.AUDIENCE: They're also\nbacked by institutionslike the government.NEHA NARULA: They're\nbacked by institutions.Say a little bit\nmore about that.What does that mean?AUDIENCE: So the\ngovernment's kindof promising you to\nrespect the value of that.NEHA NARULA: OK.The government's promising\nto respect the value of that.Does anyone want to add to\nthat or have another reason?Yes.And say your name.I'm sorry, yeah.AUDIENCE: Jared Thompson.In the example of the\ndollar, the governmentis willing to accept it\nas payment for taxes.NEHA NARULA: Payment for taxes.OK.So that kind of connects\nthe government thing.AUDIENCE: Even if it had\nno value of any other sort,it has value in that sense.It's the last thing\nthat holds up its value.NEHA NARULA: OK, great.Anybody else?Yes.AUDIENCE: I'm Paul.I think those the three on\nthe front of the dollar,those have inherent\nvalue because theymight be more rare.NEHA NARULA: They have\nvalue because they're rare.OK.Interesting.All right.So those are all really\ninteresting ideas.I think that those are\nall sort of propertiesof what makes things valuable.There are definitely things that\nare rare that are not valuable,right?I can think of some things that\nmight be extraordinarily rare.There's only one or two\nof them in the universe,and you would have no interest\nin owning them whatsoever.You wouldn't assign\nvalue to them.", "start": 480.0, "heat": 0.1}, {"text": "Certainly it's really important\nthat you can pay taxeswith this stuff because taxes\nis pretty much a requirementof living in any country.There are things that have\nvalue that you don't necessarilyuse for taxes.So that's a little confusing.And then there's this\nidea that it's backed,that it's backed by something.And the dollar used to\nbe backed by something.And actually, if\nyou look at $1.00,I think it still\nsays this, right?It's backed by the full faith\nand credit of the United Statesgovernment.TADGE DRYJA: They\ndon't say that anymore.NEHA NARULA: They\ndon't say that anymore?They used to say that.But that's what a lot of\npeople say about money.It's backed by the full faith\nand credit of the United Statesgovernment.What does that really mean?I think what it\nall goes back to isthese things are\nvaluable because wethink they're valuable.We've all decided\nthey're valuable.And you know that if you have a\n$1.00 bill and you want to buysomething from someone,\nthey're going to take it,that you can make that exchange.And the reason that\nthey're going to take itis because they know\nthat someone else isgoing to take it.These things hold value because\nwe think that they hold value.It's a collective\nstory that we all tell.So I think once you\nlook at money that way,then when you start to look at\ntokens, which are essentiallydigital representations\nof these things, thingsthat are rare and a\nlittle bit special, thenwhen you ask, well, why\ndoes this token have value,because we think it has value.So what makes a token\ninherently valuable?The fact that we\nthink it's valuable.And a lot of different\nthings can go into that.Maybe we think it's valuable\nbecause it's very rare.Or maybe we think it's\nvaluable because someone'spromised that you\ncan use it to payfor storage, like with Dropbox.Or maybe we think it's valuable\nfor a completely differentreason, because\nwe like the name,or we like the people who\nare running the network.But ultimately\ntokens are valuable.These digital\nrepresentations are", "start": 600.0, "heat": 0.1}, {"text": "valuable because we\nthink they're valuable.Yes.AUDIENCE: And also because\nthey're a limited amount.NEHA NARULA: Name.AUDIENCE: [INAUDIBLE].Because they're\na limited amount.NEHA NARULA: Well,\nso my argumentis that the fact\nthat they're limitedis something that goes\ninto our perception thatmakes it valuable.Great.OK.So now that we've learned\na little bit about money,talked a little\nbit about money, Iwant to go into how payments\nwork because ultimately, we'regoing to get to\ncryptocurrencies.And cryptocurrencies\nare electronic cash.So here's the way that digital\npayments kind of work rightnow.You have an institution\ncalled a bank.You have Alice and you\nhave Bob, and Alice and Bobhave accounts at this bank.And so the bank is keeping\ntrack of who owns what.And these are these are records.These might be digital records.They might be paper\nrecords, whateverthe bank is using\nto keep track of whohas what in their account.And so the way that I've set\nup this example right now,Alice and Bob both\nhave bank accounts.Alice has $10.00 with the bank\nand Bob does not have any moneywith the bank.So let's say that\nAlice wants to pay Bob.Let's say that Alice and\nBob have gotten together.Maybe they're in the\nsame coffee shop.And Alice wants to buy\na sandwich from Bob.And Bob says, OK, you\nneed to pay me $1.00.If you give me $1.00, then\nI'll give you the sandwich.So how can Alice do this?How can she transfer\n$1.00 to Bob?Well, if she had a paper\ndollar, she could just do that.But let's say that she\ndoesn't have a paper dollar.So Alice can ask the bank to\nmake this transfer for her--or$5.00.So Alice sends a\nmessage to the bankand authenticates with\nthe bank to show the bankthat she is, in fact,\nAlice, but I'm notgoing to go into the\ndetails on how that works.And then the bank confirms\nthat, makes the transfer in itsledger, says Alice now has\n$5.00 and Bob now has $5.00.", "start": 720.0, "heat": 0.1}, {"text": "Alice tells Bob,\nhey, I did this.I talked to the bank.Go check.You can verify it for yourself.Bob checks with the bank\nand sees, yes, in fact,the bank is saying\nthat he has $5.00 now,whereas before he had zero.And then Bob gives Alice the\nsandwich because he believesthat he now has $5.00.And the bank sort of\npreserved the propertythat money was not created out\nof nowhere, that the balancewas ultimately maintained.So the bank is very\nimportant in this scenario.The bank is critical.This is how digital\npayments work.Credit cards, Venmo,\nbanks, kind of all sortof based on the same idea,\nthat there's some trustedinstitution that is\nhandling that payment for usand that is keeping\ntrack of everything.Now what are the pros and\ncons of this scenario?Anyone want to\nthrow a couple out?Yeah.AUDIENCE: The bank\ncan get hackedand people could move money\naround between the accounts.NEHA NARULA: Right.So we're putting a lot\nof trust in this bank.And maybe should\nwe trust the bank?Banks fail sometimes.Banks are hacked.Banks have humans\nwho are running themwho occasionally\nmight want to changethose balances in their favor.This has all happened.Anything else?Yeah.And say your name.AUDIENCE: Brittany.If it's urgent, sometimes\nyou might run into a delayor it might take time\nwith the process.NEHA NARULA: Yeah.Alice has to talk to the banks,\nand that's kind of annoying.So there's that.Anything else?Yeah.AUDIENCE: And if\neveryone can actuallywithdraw at the same time,\nthen the bank can actuallyget money into the system.NEHA NARULA: So OK.So this is getting a little\nbit more advanced here.What if everyone takes their\nbalances out at the same time?Well, we need to make sure\nthat the bank actuallyhas that money, so to speak.We're not going to be talking\nabout that problem right now.But very good problem.So to kind of talk\nthrough some of the prosand cons of this situation,\none of the big pros, I think,", "start": 840.0, "heat": 0.1}, {"text": "is, that even if\nAlice and Bob are notin the same physical location,\nAlice can still pay Bobif they can talk to the bank.So it's pretty cool,\nand that's somethingyou can't do with dollar bills\nor with coins or with barsof gold.So having this\ntrusted institutionthat you can communicate\nwith electronicallymeans that Alice and\nBob could be halfwayaround the world from each\nother and they can stillpay each other.So that's pretty awesome, and\nthat is definitely a propertythat we want to have.In terms of cons, I think we\ncovered quite a few of them,which is we're really\nputting this bankkind of in the middle\nof everything here.And there are a few different\nways that can cause us trouble.So the bank needs to be online\nduring every transaction.If the bank is offline,\nthen how does Bobknow whether he got paid or not?The bank could fail at\nsome point in time, whichis kind of related to that.The bank could simply\ndecide that theydon't want to do this anymore\nand can block transactions.And then privacy.The bank has kind of\ninsight into everyoneand their payments.And this is incredibly\nsensitive information.Payments are quite important.And we're going to be\ntalking about privacya lot in this class, during\nthe second half of this class.So just an example, a couple\nof visual examples of that.The bank could just\ntotally go away,and then what happens\nto that ledger?Who knows, right?I mean, literally, it\ncould just disappear.Maybe it's paper\nand it gets burnt,or maybe it's bits on a computer\nand it wasn't replicated.The bank could decide\nthat they don'tlike Alice for some\nreason, and that theydon't feel like processing\nAlice's transactions.This happens all the\ntime in the real world.So there have been designs\nfor electronic cashthat work a little\nbit differently.And we're going\nto kind of step upto the design that came\nright before bitcoin,and we're going to\ndo that iteratively.So let's talk about e-cash\nand how e-cash works.So the way that\ne-cash works is Alice", "start": 960.0, "heat": 0.1}, {"text": "tells the bank--\ninstead of saying,hey, bank, do this\ntransfer for me,Alice says, hey, I would\nlike a digital representationof a coin.Can you give me\nsomething that is digitalso I don't have to be in the\nsame physical place as you,and that I can use in such a\nway that I can prove to someoneelse that I have this thing and\nthat I haven't double spent it,because that's the problem\nwith digital representationsof coins.A fundamental problem is\nthat bits can be copied.So whatever system you use to\ndesign your electronic cash,you need to make sure\nthat people can't justcopy coins and give what is the\nsame coin to multiple people.In the previous\nexample, the bankwas making sure this happened.The bank was\nmaintaining balancesand debiting Alice's account\nand crediting Bob's account.But if we want to think about\nsomething that doesn't involvethe bank, and we're\nstarting to get there,then we need to think about how\nto ensure that a coin can't bewhat is known as double spent.So Alice asks the bank for coin.And maybe she has an account\nwith a bank like before.Or maybe she gives the bank\nteller actual physical moneyin order to get\none of these coins.So the bank generates\na unique number--SN stands for serial number--and decides that this is\nthe digital representationof the coin.The bank then gives that\ncoin to Alice in a waythat it's clear that\nthe bank did this.Usually this is done\nusing a technique calleddigital signatures.We're going to get to\nthat as class progresses,but not right now.Once Alice has this coin,\nthen she can give it to Bob.And Bob can take a\nlook at this coin,and hopefully there's enough\ngoing on with this cointhat Bob can be convinced\nthat this is a real coin.Alice didn't make it\nup out of nowhere.She actually had the funds,\nso to speak, to give to Bob,and that it hasn't\nbeen double spent.", "start": 1080.0, "heat": 0.1}, {"text": "And once Bob is\nconvinced of that,he can give Alice the sandwich.Now in traditional e-cash,\nthe way that this is doneis Bob actually goes\nback to the bankand says, here's this coin.Alice just gave me this coin.Is this an OK coin?But the fact of the matter is\nthat the bank, in this case,has a serial number\nand knows that itgave that unique\nserial number to Alice,and then Bob is showing\nup with a coin thatis that serial number.And what the bank is doing\nhere, in this example,is the way that the\nbank checks to make surethat this coin is correct is\nit looks at the serial number,and it makes sure that it\nhasn't been spent before.So the bank can link the\ncoin between Alice and Bob,which is unfortunate.The also still sort\nof has to be online,not to do the actual payment\nbetween Alice and Bob,but in order for Bob\nto have confidencethat this coin is real.And later on Bob can say, I\nwould like $1.00 for this cointhat I've just given you,\nor something like that.Or Bob can have an\naccount with the bankand can maintain\na balance there.So just to go through some\nof the pros and cons here,OK, we've kind of done\nsomething where the bank's notin the middle, except the bank\nis still really in the middle.We're getting a step\ncloser, but we're not there.Alice can technically give\nBob this electronic thing thatrepresents value,\nbut Bob still needsto talk to the bank\nto make sure it's realand it hasn't been double spent.And we still have this problem\nwhere the bank is the one who'sminting these things.The bank can decide\nnot to give Alicea coin if it feels like it.And we still have\nthis privacy problembecause the secret number,\nthe serial number that weinvent for the coin, can be\nlinked across these payments.So there's this\nnotion of something", "start": 1200.0, "heat": 0.1}, {"text": "called Chaumian e-cash.So David Chaumian\nis a cryptographer,and he developed\nthis system whichhas slightly nicer properties\nthan previous forms of e-cash.So the idea here,\nwhich is really key,is instead of the bank\nchoosing the secret number,Alice chooses the secret number.And we have ways of\ngenerating random numbersthat we can be fairly\nsure are unique.So we can let everybody generate\ntheir own random numbers.So in Chaumian e-cash, Alice\nchooses the secret numberthat represents a coin.And then Alice\nblinds her message.So Alice adds some randomness\nto the secret number suchthat the bank doesn't know\nwhat that number actually is.And we'll get into more detail\nabout exactly what that means.It's all in the paper\nthat was assignedreading for this\nclass, so make surethat you take a look at it.So when the bank verifies that\nthe secret number is a realsecret number and\nit's really a coin,and Alice gave the bank\n$1.00 or something like that,the bank does so on the\nblinded secret number.And Alice actually\nhas the abilityto remove that randomness,\nor that blinding, laterand end up with a valid\nsignature on a secret number.So Alice does the same\nthing that she did before.She gives Bob a representation\nof that electronic coin.And when Bob redeems it,\nnote that the bank neversees what the number is,\nso when Bob redeems it,the bank has no way of linking\nthe payment between Aliceand Bob.So just to get into how\nthis works visually,Alice will talk to\nthe bank, and Alicewill use a blinding factor\non the secret number.And so when Alice\ntalked to the bank,the bank doesn't actually see\nwhat the secret number is.They can't decode it.Again, Alice gives $1.00 or\nsomething like that to get thiscoin from the bank.And the bank signs this.Alice can remove the\nblinding factor later.", "start": 1320.0, "heat": 0.1}, {"text": "And this is what the coin is.The coin is a valid\nbank signatureon the secret number, and\nalso the number itself,which Alice can\nthen send to Bob.Bob can check and make sure\nthat this is a valid signaturefrom the bank.And if that's correct, then\nBob can give Alice a sandwich.In order to redeem this, Bob\ngives this coin to the bank.The bank says, OK, I've never\nseen the secret number before,and you have my signature on it.So I'm going to assume that\nI went through this processwith somebody and\nsigned something.And now I'm going to\nrecord that secret number.Once that happens,\nBob can be surethat this coin hasn't\nbeen spent before.The bank keeps a running list\nof all the secret numbersit's seen, and it makes sure\nthat if it ever sees one again,it can say no, this\nis not correct.I should never see a secret\nnumber more than once.Now, OK.But know what about Alice\ncould give one version of thatto Bob.Alice could also give a\nversion of that to Charlie.And how are Charlie\nand Bob supposedto know whose coin is correct?Because remember, we wanted\nto try to get the bank outof the way when doing this.And so in Chaumian\ne-cash, the waythat this works is\nthe bank actuallykeeps a bit more information.And the information\nthat the bank is keepingwon't let the bank link\nthese transactions togetherunless Alice happens to\ngive this to two people.And so if Alice gives the same\ncoin to two different people,the bank will be\nable to detect itand the bank will be able\nto know it was Alice.And so this is kind of\na motivator for Alicenot to do that.So the idea being here is that\nthe way that we get aroundthe fact that we don't know if\na coin has been double spentor not is we add punishment\nif the coin is double spent.", "start": 1440.0, "heat": 0.1}, {"text": "So Bob doesn't know for sure\nthat this coin he receiveshasn't been double spent, but\nhe does know that if it was,someone's going to\nknow it was Alice,and they're going to punish her.So this is a pretty\nclever scheme.And this actually gets us\naround a lot of problems.We have digital payments.We can make the actual transfer\nwithout the bank in the middle.We have some privacy now\nbecause the bank can'tlink transactions together.And we have this way of\ndoing double spend detection.We have a way of\nmotivating peoplenot to double spend their coins,\nwhich means that you probablydon't have to check\nat the time youreceive a coin whether or\nnot it's been double spent.Of course, this still suffers\nfrom a really big problem,which is that a bank can\nstill decide that they justdon't want to do this with you.They can just decide\nthat they don't wantto play this game with you.They don't want to issue coins.Maybe they don't like\nyou specifically.Maybe they don't want to take\nyour coins and exchange them.So this scheme, Chaumian e-cash,\nsolves quite a bit of problemswhen it comes to how do\nwe have electronic moneywith some nice features,\nbut it doesn't quiteget to all of them.And so the real\nquestion in this classis how do we do\nelectronic money, really,in a peer-to-peer\nway, where there'sno institution in the way.There's no sort of\nentity that can say no.TADGE DRYJA: So e-cash, the\nmath is really interesting.It kept relying on these\nbanks and so it never quitegot off the ground.So I'm willing to talk about\nsomewhat more abstract and lowlevel primitives.I'm not going to quite get into\ncash or tokens or transfersor anything this lecture.But I'm going to talk about\nthe really basic primitivesthat you need that we\nalready sort of mentioned,", "start": 1560.0, "heat": 0.1}, {"text": "hash functions and signatures.Signatures, obviously, we\ntalked about a little bit,what you need to be able\nto sign messages in orderto send these tokens around.But first I'll talk about hash\nfunctions, which are basicallythe most fundamental basic\nthing we use in these systems.And I think if you've\nused computers,or if you've\nprogrammed a little,you probably have\nsome familiaritywith hash functions.They're simple, but they're\nactually extremely powerful.The hash function\nis basically youhave some data,\na bunch of bytes,a bunch of ones and zeros.You run it through\na hash functionand you get an output that's\nalso a bunch of ones and zeros.Generally, the input\ndata can be of any size.You can hash something--put in a megabyte,\nput in a gigabyte,or put in a single byte,\nand generally the outputis of a fixed size.So in the case of\nbitcoin, we use Sha-256.The output size is 32 bytes\nlong, or 256 bits long.And this is used for lots\nof things in computers.I guess the reason they call\nit a hash is because it'slike when you take the\npotatoes and chop them upinto little squares and\ngrill them for breakfast,it's sort of that idea,\nthat we're taking this data.And the data going in gets\nchopped up and smushed aroundand then comes out\ninto an output.So this is not a sufficient\ndifferent definition.But I will say that you\ncan sort of do everythingwith hash functions.There's some fun things\nthat you can't do,but you could make a\ncryptocurrency only usinga single hash function.And I think people have, sort\nof for experimental reasons.You limit the fun stuff you can\ndo, but you can do signatures.You can do encryption.You can do all sorts\nof things like that.OK.So this is not a\nsufficient definition,that there's any size\ninput, a fixed size output,and the output is\nrandom-looking.That's sort of wishy-washy.But what does\nrandom-looking mean?", "start": 1680.0, "heat": 0.1}, {"text": "It's not actually random.If you put in the\nsame input, everyonewill get the same output.So if you say, OK, well,\nwhat's the hash of one,you'll get some output.And if someone else says,\nOK, what's the hash of one,you'll get the same thing.However, the output,\nwhile it is deterministic,it's sort of high\nentropy in thatthe output should have about as\nmany as one bits as zero bits.If you take the\nhash of one, it'sjust going to look like\na big random number.And the hash of two will look\nlike a completely unrelatedrandom number.The outputs look like noise.So if you've ever\nseen hash functions,you can run it on your computer.You say echo.Hello, pipe Sha-256\nsum, and you'll justget some kind of\ncrazy, random thing.There doesn't seem to be\nany order to the outputs.A little bit more well-defined.We usually talk about\nthe avalanche effect,in that changing a\nsingle bit in the inputshould change about half\nthe bits of the output.So even though you have\nextremely similar inputs,they should be completely\ndissimilar outputs--well, completely\ndissimilar, as in about halfthe output changed.If every bit\nchanges, then it justis the inverse of what you had,\nand so it's easily correlated.But the avalanche\neffect is sort of howhash functions are constructed,\nwhere generally they'reiterative rounds.And so you say, OK, I'm\ngoing to swap these thingsand multiply these things and\nshift these bits around suchthat if any change\nin the beginningwill sort of propagate\nan avalanche, too,so that all the output bits\nhave been affected by it.OK.And a little bit\nmore well-defined.Generally, the hash\nfunctions are definedby what they should not do.So the three main things\nthey should have--preimage resistance,\nsecond preimage resistance,which I'll sort of skip over,\nand collision resistance.And we can define\nwhat these things are.So a preimage is the thing\nthat came before the output.So it's sort of a math-y term.", "start": 1800.0, "heat": 0.1}, {"text": "But the idea is OK, if you know\ny, you can't find any x suchthat the hash of\nx is equal to y.So if I give you a hash output,\nand that's all I give you,you should not be able\nto find an input thatleads to that output.So if I just say, hey,\nhere's a hash output.It's 35021FF-- whatever,\nsome long string,you won't be able\nto figure out whatI used to put in to get that.Of course, you can\nfind it eventually.For any given y,\nthere's probably some x.In fact, there's probably\na lot of x's thatwill lead to that y.Since y is a fixed\nlength and there'stwo to the 256 possible\ny's, but there'san infinite number of\nx's because x is notbounded in length.You can have a megabyte or a\ngigabyte or a terabyte size x.So since there are sort of\ninfinite numbers of x's,and a fixed, though very\nlarge number of y's, as longas it is a random\nmapping, there willbe lots of different x's\nthat can lead to this y.And so you should\nbe able to find it.It's just impractical.It's like, yeah, you\nmay be able to find it,but it's going to take\nyou two to the 256 triesto find any specific y value.And that's about\n10 to the 78, whichis a number that's big enough\nthat you can sort of round itup to infinity.Well, I mean, not\nquite, but big enoughthat you're not going\nto be able to computethat, the sun'll burnout\nand the universe'll dieand stuff like that.So that's preimage resistance.You can't go backwards.Given the hash, you can't\nfind what led to that.OK.Any questions about\npreimage resistance?Seems reasonable?It's a little interesting\nin that given y isa little tricky, and\nthat it's like, OK, well,someone might know x in order\nfor them to have computed y.", "start": 1920.0, "heat": 0.1}, {"text": "Or maybe it's just\ncompletely random,and no one actually\nknows what the x is.So there's a sort of\nloss of informationin the idea of a preimage stack.OK.Second preimage resistance.This one's a little\ntrickier and can get messy.So I'll define it, but we\nwon't go into it too much.The idea is given x and\ny such that the hash of xis equal to y, you can't find\nx prime where x prime is notequal to x.And the hash of x\nprime is equal to y.So we're sort of\ngiving you a preimage.We're saying, hey, here's\nthis number x and here'sthis result y.I bet you can't find\nanother x that leads to it.This one is actually poorly\ndefined in the literature.And so it's a little\nlike, well, whomade x, and who gets to\nchoose, and is it any x primeand things like that.So it's not actually\nthat useful.So we can just sort of\ngloss over that one,just sort of mentioning it.And then the other one that's\nvery important is collisionresistance, where the idea is\nthat nobody can find any x,zpair such that x\nis not equal to z,but the hash of x is\nequal to the hash of z.And this one's a\nlot cleaner in thatthere's no lack of information.There's no secrets or anything.It's just like, look,\nno one can find this.And so it's really\neasy to disprove.You can just say, hey, look,\nhere's an x and here's a z.Try hashing them.Oh, shoot, the hashes are equal.And it doesn't really\nmatter how you got theseor who's doing it.So that's a really nice,\neasy, clear property.And again, you can\nfind this eventually.So if your output\nsize is 256 bits long,you'll be able to\nfind two inputs thatmap to the same output.In fact, you do not\nneed to try 256 times.I'm not going to go\ninto the details,", "start": 2040.0, "heat": 0.1}, {"text": "but you actually only\nhave to try 128 times.Sorry, two to the 128.So you need to take the square\nroot of the number of attemptsin order to find this collision\nbecause the intuitive reasonis, well, you just start\ntrying things and keepingtrack of all their hashes.And there's what's called\nthe birthday attack, which,as you keep trying them,\nthere's more possibilities.The next thing you\ntry, you can collidewith any of these things\nyou've tried before.And so you actually only\nhave to do the square root.And it's called\nthe birthday attackbecause there's the birthday\nparadox, which is not reallya paradox, but the idea\nis so in this room,there's people that\nhave the same birthday.It's almost certain,\nwhich seems kind of weirdbecause the intuitive thing is,\nlike, well, there's 365 daysa year.Maybe once you get 160,\n170 people in a room,you're going to have two\npeople with the same birthday.But actually, it's\nlike 22 or something--anyway, that it becomes\nlikely that peoplehave the same birthday.So it's kind of\ncounterintuitive,and it applies in\nthis case as well.So to find a collision,\nyou need the square rootof the output space.But a hash function should\nnot have collisions.If you can find a\ncollision, if any collisionexists for this\nhash function, youcan consider the\nhash function broken.It's a little bit different\nthan preimage resistancebecause it's hard to\ndefinitively provethat you've broken preimages.That's something of an\ninteractive process whereyou say, hey, here's a y,\nand then someone comes backwith an x, and\nyou're like, oh, OK,you prove to me that\nyou can find preimages.But that's hard to tell\nto the rest of the worldbecause it was sort\nof interactive,whereas collisions are very\nclear and non-interactive.You can just say, hey,\nhere's an x and here's a z.Anyone can verify these.Didn't really matter\nhow you got it.OK.So some practical, how\ndo these functions work.Practically speaking,\nthe collision resistanceis a harder property.So there are many functions\nwhere the collision resistance", "start": 2160.0, "heat": 0.112}, {"text": "has been broken where the\npreimage resistance has notbeen broken.So examples are Sha-1 and MD5.MD5's a fairly old one written\nby Ron Rivest over at--well, I guess it wasn't\nat the Stata Centerbecause it was in the '80s.But this was message digest 5.I guess there were\nseveral before that.And that is quite broken.You shouldn't use it.Its collision resistance\nis trivially broken.You can find collisions in under\na second on a modern computer.Sha-1 happened later, in\nthe late '90s, I think,and NSA made it.And there have been\ncollisions found.I think there's really\nonly one collision that'sbeen found, basically,\nby a team at Googleand some Italian\nuniversity last year.And they spent a lot of computer\ntime to find this collision.But they did find it.And then once you find one,\nit's sort of like, oh, yeah,we really shouldn't\nuse this anymore.But in both of these\ncases, sha-1 and MD5,there's no feasible\npreimage attack.So given a hash output\nfor either of these,you can't find what\nthe input was, or youcan't find a different input.So generally, it's a lot\neasier to make a functionstrong against preimages.Collisions is sort of\nharder to deal with.Also, practically speaking, how\ndo these hash functions work?It's a little bit\nof black magic.There's no proofs that a\nhash function can even exist.So if you could prove that\nthere is a one-way function,you get the Fields Medal, right?It's like a million\ndollar prize.So if you can prove\nit there is sucha thing as a hash\nfunction, you will bea super famous mathematician.We have no idea that this is\neven mathematically possible.Or maybe the universe\ndoesn't work this way.It seems to, though.It seems like there\nare these things thatwork like hash functions, that\nwork like one-way functions,but we have no proof of that.So even the most fundamental\npart that everything hinges on,", "start": 2280.0, "heat": 0.1}, {"text": "we don't even know if it exists.And then this is sort\nof closely related,if you're in the\ncomputer science-y stuff,like p and mp--anyway, so we don't know\nthat these actually work.And also, in practice,\nhash functionsare not nice math, cool\nthings like elliptic curvesand RSA, prime numbers\nand stuff like that.They're really, if you look at\nthe code, it's sort of like,well, I'm going to\ntake these bytesand I'm going to swap them.And then I'm going to\nadd these two numbers,and then I'm going to\nrotate the bits over here,and then I'm going to\nx over these things.And then I'm going\nto do that 50 times.And why 50?Well, it seems like\n50 is a good number.It's not too slow.No, really.It's sort of black magic,\nSha-256 uses 64 rounds.Nice even number.Different functions like\nBlake 2B uses 20 rounds.But then there's also\na version that uses12 rounds, which is faster.And people think, well, it's\nstill seems quite secure.But if you want to\nbe really secure,use the 20-round variant.If you want to be\nprobably secure enough,use the 12-round variant.So there's no proofs.There's heuristics and things\nlike that, and best practices.But this kind of cryptography\nis a little bit of black magic.And it's not based on any cool\nmathematical number theorystuff, either, the way\nthat elliptic curvecryptography or RSA stuff is.So if you break\nRSA, you can say,hey, I can now factor\nthese composite numbersvery quickly, that's,\nin and of itself,a cool mathematical discovery.The breaking of Sha-1,\nthere's not reallyany cool math insight.It was just like, yeah, we\nfound this fairly specific,weird path that we were\nable to break Sha-1after a couple of\nyears of computer.So it's cool, and some\npeople are super into it.But it's something of a niche to\nactually build hash functions.I would recommend not building\nyour own hash function.", "start": 2400.0, "heat": 0.1}, {"text": "Yes.AUDIENCE: I'm Wayne,\nand my questionis, is breaking a hash function\nliterally just guess and check,or is there more\nof a method to it?TADGE DRYJA: So no.If you say, hey, I\nfound a collisionby doing two to\nthe 128 attempts.One, nobody's done two\nto the 128 attempts.That's still seen as like\nbeyond technology today.But if that's how you break\nthe function, that's not reallyconsidered a break because\nthat's sort of the definition,is yeah, well, we know\nthis is 256 bits long.So to find a preimage, if you\ndo two to the 256 attempts,you'll find it.So that's not\nconsidered a break.A break is considered, hey,\nI found a preimage in twoto the 240 attempts.Or I have a proof\nthat you will beable to find a preimage in\ntwo to the 240 attempts,and here's how to do it.And that's considered a break.It's still impractical.Two to the 240's still\nimpossible in today'stechnology.But if you had a paper\nand people looked at it,like, oh, yeah, that would work,\nyou wouldn't be able to do it.But that's still\nconsidered broken.And so something like\nMD5, MD5 output sizewas 16 bytes or 128 bits.So collisions, even\nif it were strong,it would still be\ntoo short todaythat collisions would be able\nto be found in two to the 64iterations, which is doable\non today's computers.If you run a bunch of stuff on\nAWS, you can do two to the 64in a couple of days.But that's the\ndifferent definitionsof breaking the function.Sort of fun.Ethan Hellman,\nwho's at BU and wework with, he-- and we all broke\nthe IOTA wrote their own hashfunction, which is like\nsome cryptocurrency.And we found collisions in it.And it was kind of fun.But yeah, it was weird.It wasn't like number theory.It was just like, oh, well,\nI wrote this Python script", "start": 2520.0, "heat": 0.1}, {"text": "and we have this go script,\nand we tried this thingand we got a collision.So it was kind of fun.So usages.What do you use\nthese hashes for?There's lots of cool things\nyou can use them for.use them sort of as\nnames or references,where instead of naming\na file, you can justtake the hash of a file.And that is a good, compact\nrepresentation so you can pointto what you're talking about .So the hash of a file is\na unique representation.And if you change\nany bit in that file,the hash will change.And so you know that, OK, here's\nthis way to point to a file.You can also use it as sort\nof a reference or pointerin different algorithms.So you can say, anything\nyou're using pointers for,linked lists or maps and\nstuff like that, you can say,well, I'm going to use\na hash as a pointerand then be able to sort\nthrough it that way.So anytime you think of pointers\nand graph theory and stufflike that in computer\nscience, think, well,could I use a hash function\nhere instead of justlike regular memory pointer?And in many cases, you can.In some cases, you can't.So you can't have cycles.So the idea is you\ncan't find preimages,you won't be able to find a--whereas you could make a cycle\nof pointers in a computer,where A points to\nB, B points to C,C points back to\nA. You shouldn'tbe able to produce that\nwith hash functionsbecause having that cycle\nmeans, OK, well, somehow youfound this preimage.But in many cases,\nyou can do this.And another way to look at it\nis the hash is a commitment.You can say, well, I'm not\ngoing to tell you what x is,but I'll tell you what y is,\nand I can reveal x later.And then, since\neveryone remembers y,they can be sure that yeah,\nhe's revealing the right thing.There are no collisions\nin this function,", "start": 2640.0, "heat": 0.1}, {"text": "so we can be sure,\nif we're presentedwith x, that this was the x\nthat was committed to yesterday.So I'll give a little example\nof that, of commit and reveal.So you can commit to some\nkind of secret or somethingyou want to reveal later\nand reveal the preimage.So here's my commitment.This is an actual hash, Sha-256.I just made it on my computer.And there is a string.There's an Ascii string\nthat maps into this,and it is a prediction\nabout the weather,but that's all I'll say.And given that information\nand given this hash,you probably can't\nfind my prediction.You can try to try all these\ndifferent Ascii stringsabout the weather today,\nbut I'll reveal it.So I think it won't\nsnow Wednesday.But I think it\nactually-- anyway,and then I put this number in.And so if you put this in\nyour computer in Linux--I think in Mac it's a\nslightly different command.It's like Sha-2 or something.But in Linux, this will\nwork, and you can say,I think it won't snow Wednesday.And then I put some\nrandom numbers herebecause if I had committed\nto just the phrase,I think it won't\nsnow Wednesday, youmight have been\nable to guess that.You could say, well, he said\nit was about the weather.I'm going to take\nall sorts of millionsof different strings\nrelated to daysand weather and\ncommon English words,and I'm going to\ntry hashing themand see if I find a collision.And you might be able to.But I added this four\nbytes of randomnessat the end to make\nthat difficult.It doesn't really\ncontribute to my commitment.And you know this doesn't\nreally mean anything.But it makes it harder to\nguess what my input wasbecause I've already\nrevealed that it's nota fully random input.So you might be able\nto guess things.So I could say, hey,\nI'm going to makea prediction about the\nweather, commit to it,and then reveal my\nprediction tomorrow.And we'll see if I was right.This can be useful\nin the case where--", "start": 2760.0, "heat": 0.1}, {"text": "not the weather, but\nin other things--if knowing my prediction could\ninfluence the actual events,this would be a nice way to\ncommit to what my prediction iswithout everyone knowing\nwhat the prediction isand then revealing\nit the next day.Yes.AUDIENCE: What are the use\ncases for double hashing,like where you would\nhash that hash?TADGE DRYJA: Hashing this again?Well, so in bitcoin they\nhash everything twice.Generally, you don't need to.There's no explanation for\nwhy they do that in bitcoin.You could.But there are things\nyou can constructwhere you can, say,\nappend some extra dataand then hash this again.So you can say, here's my\nprediction for next week.And this is the hash,\nand then hash it again.So you can make\nchains of commitmentsand then reveal\niterations of it.Actually, I had\nsome slides whereyou can sort of hash\nsomething again and again,and start revealing\nit incrementally.That might be useful.I actually have stuff\nlike that in software.I've written where you\nwant to reveal secrets.But let's say I want\nto reveal secrets,but I don't want everyone to\nhave to store all of them.So I can make a chain of\nhashes, commit to the last one,and then as I reveal\nsuccessive preimages,you don't have to\nstore all of them.You can just store\nthe latest preimage,and you can reconstruct\nall the hashes from that.Yes.AUDIENCE: But is\nit computationallydifficult to run double hashes?TADGE DRYJA: So to evaluate--if you want to try this,\nit's imperceptible.To perform one\nSha-256 hash is, Idon't know, a billionth\nof a second or something.You can generally do,\nlike, 100 megabytesto a gigabyte of hash\noutput on a regular CPU.", "start": 2880.0, "heat": 0.1}, {"text": "NEHA NARULA: I\nthink she's askingdoes it make it harder to find\na preimage if you hash twice,and the answer's no.TADGE DRYJA: The\nanswer's sort of no.It might.So I don't know, chained MD5,\ncan you still find collisions?I'm not sure.But generally the thinking is,\nif the hash function is broken,and you can either find\ncollisions or preimages, yeah,maybe it gets a little\nharder by iterating it.But you should\njust stop using itand use something that's secure.But yeah, it seems\nthat finding preimageswould be harder since it's\nessentially adding morerounds by hashing it twice.And then there are some attacks,\nso it's fairly out there.But it's called length\nextension attacksdue to how hash functions\nare constructed,where if you do say, OK,\nI'm going to take the hashand then take the\nhash of that, youdo prevent certain types of\nattacks that are fairly niche.But a length\nextinction attack ina Merkle-Damgard construction\nwill be prevented by this.So generally, no.Generally, you don't\nneed to do this.But there are different\nconstructions where you'regoing to hash a bunch of times.I don't have the slides\nhere but, like a Merkle treeis a binary tree of\nhashes where you'retaking the hashes\nof these thingsand then hashing\nit again and again,and that's a really\nuseful data structure.And a blockchain is\nessentially a chain of hashes.And that's what we'll\ntalk about next week.But yeah.OK.So I'm going to go\na little faster.So that's an interesting\nuse case whereyou can commit and reveal.And yeah, adding randomness so\nyou can't guess the preimage.This is called a hash-based\nmessage authenticationcode where part of it is\nsecret and part of it is not.And this is getting towards a\nsignature, where I've committedto something, and\nthen I reveal it,and everyone knows,\nyeah, that must be whathe committed to the day before.It's not quite a signature, but\nit's getting to that direction.And so next I'm going to\ntalk about signatures.", "start": 3000.0, "heat": 0.126}, {"text": "What is a signature?It's useful, and it's a\nmessage signed by someone.And so I'll define\nwhat a signatureis through the\nfunctions that it uses.There's three\nfunctions will allowyou to create a\nsignature scheme,generate keys, sign, and verify.And these different things.Generate keys, you make a\nsecret key and a public key.And so the idea is there's\nsome public key which isyour identity , and there's\nsome secret key which you onlycontrol.And you use that to\nprove your identityand prove that these\nmessages are signed by you.So yeah, you\ngenerate a key pair.The holder of the secret\nkey can sign a message.And then anyone\npossessing a public keycan verify a message\nsignature pair.So I'll go into detail\non these three functions.And this applies generally.So I'm going to talk about a\nhash-based signature in detail,but there are many\ndifferent signature schemes.DSA, ElGamal, RSA signatures,\nelliptic curve signatures.There's tons of different\ncool math systems thatallow these kinds of functions.And I'll talk\nabout in some ways,this is one of\nthe simplest ones.So yeah, there's\nthese three functions.The first one is generate keys.And it returns a private\nkey public key pair.And it generally doesn't\ntake any arguments,but it takes in randomness.You need to flip coins.You need to find random\none and zero bits.And it has to be long\nenough that no one else canguess what your private key is.So you have a private\nkey, public key.Public key is public.You tell everyone.Private key is more secret key.Actually, I think in the\ncode, I always say secret key.It's usually better to say\nsecret key because at least itstarts with a\nletter that's not p.OK.And then the signing\nfunction, where", "start": 3120.0, "heat": 0.217}, {"text": "you take your secret\nkey and your message,and it signs a message\nand returns a signature.All these things are just\nstrings of ones and zeros.It's just a bunch of bytes.Public key, a private key,\na signature, a message.These are all just bytes.And then the verify function,\nwhich is the most complex.A verify function takes a\npublic key that you've seen,a message, and a signature.And it returns a Boolean\nwhether this was valid or not.So it returns a single bit.If it's zero, it says,\nyeah, these two thingsdon't match up.Maybe the message just\nchanged, or maybe the signaturehas changed, or maybe it's\nfrom a different public keyor something.But if all three of\nthese are correct,and the signing function\nwas the private key--the secret key associated\nwith this public key--was signed to this message\nand produce this signature,then it will return true.And so you get into\nthe math propertiesof what does it mean\nto forge a signature,and can they be forgeable\ncomputationally?Eventually a lot of these\nthings, since it's bits,you could eventually\nguess the forgery.But maybe that takes two to\nthe 256 attempts or something.OK.So any questions about the\nbasic structure of whatconstitutes a signature scheme?Mostly make sense?And you can see\nhow this is useful.You can publish a public\nkey and say, hey, I'm Tadge.This is my public key.And in fact, on my business\ncard, I have a RSA public key.And so if people get my business\ncard and then I sign a messageand email it to them, they\ncould be sure that, oh,this is probably the same guy.Nobody ever cares.But it's useful for the\nstuff we were talking aboutbefore with Chaumian cash, where\nAlice needs to authenticateto the bank, and one way to\ndo it is to sign a messageand say, hey, I'm\nAlice, give me a coin.And then Alice can sign a\nmessage to Bob and so on.", "start": 3240.0, "heat": 0.222}, {"text": "So this is really useful as a\nbasic building block for allthese kinds of messages.So I'll talk in\nthe last 14 minutesabout signatures from hashes.This is doable.Using just hash functions, you\ncan construct a signatures key.And in fact, that's\nthe first problem set.And you implement a signature\nsystem using only hashes.And the hash function is\nalready defined for you.It's in the standard library.It's just Sha-256, the\nsame thing bitcoin uses.And this is called\nLamport signatures.Leslie Lamport wrote\nabout this late '70s.I forget exactly when\nthe paper came out.But this was one of the\nearliest cryptographic signatureschemes.And it's kind of cool.And another fun thing is\nit's quantum resistant.So if you know about\nquantum computers,quantum computers kind\nof ruin all the funin terms of cryptography.All the cool things we can do\nwith cryptography-- not all,but most of them get\nruined by quantum.Computers but hash\nfunctions are quiteresistant to quantum\ncomputers because they're notbased on any fun math.They're based on\nthis black magicof just XORing and\nshifting numbers around.That's a huge\noversimplification.But yeah, so those\nhash functionsare generally seen to\nbe quantum-resistance.So if you have a\nsignature scheme thatonly uses hash\nfunctions, well, it stillworks, even if someone\ninvents a quantum computerand can break all\nthese other things,like RSA and elliptic curves.So there's actually\nrenewed interestin these kinds of\nsystems recently.OK.So how do you make a signature\nscene with just hash functions?So how do you generate\na key, in this case?So a public key and a private\nkey you want to generate.So first we generate\nour private key.Now these squares\nare 32 bytes each,and you generate 256\nof them on this row,256 of them on that row.", "start": 3360.0, "heat": 0.24}, {"text": "So you're generating 256 times\ntwo, or 512 32-byte blocks.And these blocks are each\n256 bits or 32 bytes.So in total, that's what, 8K?Eight kilobytes, I think.Pretty big.But anyway, you're saying,\nOK, here's my private key.It's all completely random.I just take slash dev\nslash urandom or whatever,just flip coins 8,000 times,\nor however many this is total,and generate all\nthese different blocksand store them on my hard\ndrive and keep it secret.Then I want to generate\nthe public key.So for each of these\n32-byte blocks,I take the hash of it,\nwhich will also be 32 bytes.So there's now 512 hashes, 256\non this row, 256 on this row.The green will be my public key.And the gray one\nis my secret key.So they all look the same.They all look like just a\nbunch of random ones and zeros.The gray ones actually are a\nbunch of random ones and zeros.The green ones are\nactually hashes, though,of all the gray ones.And I publish the green ones.Just to serialize it,\nI just put in a row.I say, OK, here's this first\n32-bit, second, third, fourth,and then go to this row or\nwhatever scheme you want.So how is this useful?Now everyone knows\na bunch of hashes,and I know a bunch\nof the preimages.So now it's sort of this\ncommit reveal thing, whereif I reveal to you this,\nyou can verify that, oh,yeah, that mapped to\nthis one later on.Any questions so far\nabout this process?Seems sort of useless but\nfairly straightforward.OK.Then I want to sign.So first, to sign a\nmessage, I'm goingto take the hash of\nthe message to sign.And this is often done.It's done in bitcoin.It's done in most signature\nschemes, where I want", "start": 3480.0, "heat": 0.234}, {"text": "a fixed length number to sign.It's annoying to\nhave to say, well,what if I want to sign\na megabyte long file,or what if I want to sign\nof 10-byte long string?You want to standardize it.So whatever I'm signing,\nit's always 256 bits long.So if I want to just sign\nthe message hi, firstI take the hash of the message\nhi, which in Sha-256, thisis the hash of hi.And so I look at this\nas 256 bits, and I say,OK, I'm going to pick the\nprivate key blocks to revealbased on the bits here.So the first bit here is\na one, because it's an 8.And so I'll reveal.And I indicated\nbefore that there'sthis zero row and this one row.And now what that means\nis, well, the first bitof my message to sign is a one.So I'm going to reveal\nthis gray square.And the next bit, the\nnext four bits, actually,since it's an eight,\nare going to be zero.So I'll reveal\nthis and then I'llreveal this, this, and this.And I just made it up.But yeah.So for example, if I'm signing,\nand it starts with 01101110,I reveal this preimage, this\npreimage, this preimage,this preimage, these\nthree, this one.And so I reveal preimages\nbased on the bit representationof the message I'm\ntrying to sign, and thengive everyone these.So my signature will\njust be this sequence.I can go in row order here.Yeah, it's probably\na lot easier.So I go in sequence.I say, OK, here's the first\n32 bytes of my signature.Here's the next, here's\nthe next, here's the next.And so my signature ends\nup being 256 blocks long,each of which are 256 bits.So it's like 8K.The keys are 16K and\nthis is 8K or something.Fairly big but totally\ndoable on a computer today.", "start": 3600.0, "heat": 0.145}, {"text": "Eight kilobytes is no big deal.OK.Now to verify,\ntake the signature,hash each block\nof the signature,and see that it maps into\nthat part of the public key.So the people who are\nverifying the signature,they have your public key.They have all the green squares.And now they have been\ngiven a signature, whichis these gray squares,\nand they say, OK,well, let me hash this one.Oh, it maps to that,\nso it maps to a zero.Oh, this maps to a one,\nthis maps to a one,this maps to a zero.And they can go\nthrough and say yeah,this is a signature\non that message.In the case of\nLamport signatures,you can actually determine\nwhat the message is justfrom the signature\nin the public key.If you're given\nthis and you're nottold whether it's a one or\na zero, well, just compare.Hash it and compare to\nthese two green ones.You'll be able to see.And that's a useful\nsignature because no onecan forge that\nbecause no one knowsthese preimages except\nfor the person whoholds the secret key.So given your public key,\nI can't forge a signaturefrom you.Once the signature is issued,\nI also can't forge a signature.The only bit sequence I know\nis the one that you revealed.And so I know part\nof your private key.I know half of it.But that half only lets me sign\nthe message you just signed.So I can't really do\nanything extra with this.So this is a usable\nsignature scheme.I think I just showed it.But any downsides that you\ncan think of with this?AUDIENCE: You can only sign one.TADGE DRYJA: Yeah,\nyou can only sign one.Is that what you were--AUDIENCE: You could also\nsend the same messageon to someone else with\ndifferent signatures.TADGE DRYJA: Yeah, but\nsignatures are sort of public.So yes, you're\nsaying that you cansign a message once and give\nit to a bunch of people.", "start": 3720.0, "heat": 0.16}, {"text": "And that's sort of a\nfeature, not a bug, I guess.There are different signature\nschemes where you want,I only want this signature\nto be valid to this person.There's different\nways to do thatwith Diffie-Hellman\nkey exchange and stuff.But the signature scheme\nwe've talked about herewith these three functions, the\npublic key is really public,and anyone can verify.And that's something we want.If you don't want that,\nthere's other ways to do it.But yeah, the big one is,\nwait, you can only sign once.Once you generate a key\npair, your private key,your public key, and you tell\neveryone these green squares,if you're try to sign again,\nyou will reveal more piecesof your private key.So if I sign two\ndifferent messages,sometimes it's the same bit.Sometimes it's different bits.And now I start revealing\nmore pieces of my private key.And now people can start\nto forge signaturesbecause I can say, OK,\nwell, the first bit,I can sign anything\non the first bit.I'm still constrained\nhere and here and here.But in several locations, I\ncan sign whichever bit I want.And so the basic thing is,\nif there's one signature,I can't forge anything.If you give me two signatures,\nsince it's generally random,on average, half of the\nbits of the signaturewill be constrained.So in this case, if it's 256\nbits long and you sign twice,I probably still can't forge\nanything because 128 bits,I have the freedom\nto pick either.And the other 128 bits, I'm\nstuck with the one or the zeroand I don't get to choose.So that means most\nmessages I want to sign,I won't be able to because if I\ntried two to the 128 attempts,I'll be able to find\na forged signature.But that's a lot.And so maybe you can sign twice.But again, it's probabilistic.You might get unlucky\nand reveal quite a bit", "start": 3840.0, "heat": 0.268}, {"text": "more than 128 bits,\nwhere you get both.But on average-- and then once\nyou have three signatures, OK,now I've probably revealed\n3/4 of the locationsyou're going to have both\nthe one and zero row.And you can start--\nand this startsto be practical\nbecause in this case,you'd need a 2 two the 64\nattempts to forge a signature.And that's doable on\ntoday's computers.", "start": 3960.0, "heat": 0.319}]