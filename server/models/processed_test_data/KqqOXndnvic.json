[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation, or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.SRINIVAS DEVADAS: All\nright, let's get started.Good morning everyone.I see a lot of tired faces.I'm not tired.Why are you tired?[LAUGHTER]I only lecture half the time.You guys take the\nclass all the time.So today's lecture is\nabout hash functions.And you may think that you know\na lot about hash functions,and you probably do.But what we're going to do\ntoday is talk about reallya completely different\napplication of hash functions,and a new set of\nproperties that we'regoing to require\nof hash functionsthat I'll elaborate on.And we're going to see a bunch\nof different applicationsto things like\npassword protection,checking the integrity\nof files, auctions,and so on and so forth.So a little bit of\na different lecture.Both today and on\nThursday I'm goingto be going to be doing\ncryptography and applications,not too much of algorithms.But we will do a little bit\nof analysis with respectto whether properties\nare satisfied,in this case by hash\nfunctions or not.So let's just dive right in.You all know what\nhash functions are.There's no real change\nin the definition.But the kinds of hash\nfunctions that we'regoing to be looking at\ntoday are quite differentfrom the simple hash\nfunctions, like taking a modwith a prime number that\nwe've looked at in the past.And the notion of\ncollisions is goingto come up again,\nexcept that again we'regoing to raise the\nstakes a little bit.So a hash function\nmaps arbitrary", "start": 0.0, "heat": 0.241}, {"text": "strings-- let me do this right.So you're not making a statement\nabout the length of the string.You will break it up, even if\nyou had a string of length 512,or maybe it was 27, you do\nwant to get a number out of it.In a specific\nrange there's goingto be a number of\nbits associatedwith our hash functions.And previously we\nhad a number of slotsassociated with the output\nof the hash function.But the input\ncould be arbitrary.And these arbitrary\nstrings of dataare going to get\nmapped, as I just said,to a fixed length output.And we're going to\nthink about this fixedlength as being a\nnumber of bits today,as opposed to slots\nin the hash table.Because we really aren't\ngoing to be storinga dictionary or a hash\ntable in the applicationswe're going to look at today.It's simply a question\nof computing a hash.And because the\nfixed length outputis going to be something on the\norder of 160-bits, or 256-bits,there's no way that you\ncould store two arraysto 160 elements in a hash\ntable, or even two arrays to 64really.And so we're going\nto just assumethat we're computing\nthese hashesand using them for\ncertain applications.I just wrote output\ntwice I guess.So map it to a\nfixed length output.We want to do this in a\ndeterministic fashion.So once we've computed the\nhash of a particular arbitrary", "start": 120.0, "heat": 0.13}, {"text": "string that is\ngiven to us, we wantto be able to repeat\nthat process to getthe same hash every time.We want to do this\nin a public fashion.So everything is public.There's no secrecy.There's keyed hash functions\nthat we won't actuallylook at today, but\nmaybe in passingI'll mention it next time.We're not looking at\nkeyed hash functions here.There's no secrets in any of\nthe descriptions of algorithmsor techniques I'm going\nto be describing today.And we want this to be random.We want it to look random.True randomness is going to\nbe impossible to achieve,given our other constraints.But we're going to\ntry and approximate itwith pseudo-randomness.But we'd want it to\nlook random, because weare interested-- as we were\nin the case of dictionariesand the regular application\nof hash functions-- weare interested in\nminimizing collisions.And in fact we're going to\nraise the stakes really highwith respect to collisions.We want it to be impossible\nfor you, or anyone else,to discover collisions.And that's going to be an\nimportant property of collisionresistance that obviously is\ngoing to require randomness.And those are the\nthree things we want,deterministic,\npublic, and random.And so just from a function\ndescription standpointyou have 0, 1 star here,\nwhich implies that it'san arbitrary length strength.And we want to go to 0, 1 d.And this is a\nstring of length d.So that means that\nyou're getting d-bits outfrom your hash function.And here the length is\ngreater than or equal to 0.", "start": 240.0, "heat": 0.304}, {"text": "So that's it.Not a lot that's new here.But a few things that are going\nto be a little bit different.And there's some subtleties\nhere that we'll get to.I want to emphasize two things,\none of which I just said.There's no secrecy, no secret\nkeys here in the hash functionsthat we are describing.All operations are public.So just like you had your hash\nfunction, which was k mod p,and p was a prime and p was\npublic and known to everyonewho used the dictionary,\neverything herewe are going to be\ntalking about is public.So anyone can compute h.And we're going to\nassume that thisis poly-time computation--\nnot too surprising-- but I'mbeing quite flexible here.When you look at\ndictionaries, and youthink about using dictionaries,\nand using it to implementefficient algorithms,\nwhat is the assumptionwe kind of implicitly made--\nare perhaps explicitlyin some cases-- with respect\nto computing the hash?Anybody?Yeah?AUDIENCE: Constant time?SRINIVAS DEVADAS: Constant time.We assumed-- so this is not\nnecessarily order 1, right?So that's important.So we're going to-- I want\nto make sure you're watching.So you're going to raise\nthe stakes even with respectto the complexity of the hash.And as you'll see, because\nof the desirable properties,we're going to have to do that.We're going to ask for\nreally a lot with respectto these hash functions.Nobody can find a\ncollision, right?And if you have something\nas simple as k mod p,", "start": 360.0, "heat": 0.397}, {"text": "it's going to be trivial\nto find a collision.And so these order\n1 hash functionsthat you're familiar\nwith aren't goingto make the grade with respect\nto any of the propertiesthat we'll discuss\nin a few minutes.All right, so remember this\nis poly-time computation.And there's lots of examples\nof these hash functions.And for those of you who are\nkind of into computer securityand cryptography already,\nyou might have heardof examples like MD4 and MD5.These are versions.MD stands for message digest.These were functions that were\ninvented by Professor Rivest.And they had d equals\n128 way back when-- 1992,if I recall-- when\nthey were proposed.And these algorithms have\nsince been broken in the sensethat it was conjectured that\nthey had particular propertiesof collision resistance that\nit would take exponential timefor anybody to find collisions.And it still kind of\ntakes exponential time,but 2 raised to 37 is\nexponential at one level,but constant in another level.So you can kind of do\nit in a few seconds now.So a little bit of history.I'm not going to spend\na lot of time on this.MD5 was used to create what was\ncalled a secure hash algorithm.This is 160-bits.And this is not quite\nbroken at this point.But that people consider it\nbroken, or soon to be broken.Right now the\nrecommended algorithmis called SHA-3, secure hash\nalgorithm version three.And there was a contest\nthat ran for like 18 months,or maybe even longer,\nthat eventually was wonby what turned into the SHA-3.And they had a different name\nfor it that I can't recall.", "start": 480.0, "heat": 0.367}, {"text": "But it turned into SHA-3.And what happened along the\nway, as we went from MD4,MD5, SHA-1 to SHA-3, is that\nthis amount of computationthat you had to do increased.And the complexity of\noperations that youhad to do in order to compute\nthe hash of an arbitrary stringincreased to the\npoint where-- youwant to think about this as\n100 rounds of computation.And certainly order\nd computation,where d is the number of bits.And perhaps even more.So it's definitely not order 1.So as I said a little bit\nof context with respectto the things that\nare out there.At the end of the\nlecture I'll give youa sense for how these\nhash functions are built.We're not going to\nspend a lot of timeon creating these\nhash functions.It's really a research topic\nonto itself and not reallyin the slope of 6.046.What is in the scope\nof 6.046, and whatI think is more\ninteresting, whichis what we'll focus\nour energy and time on,is the properties of\nthese hash functions.And why these properties\nare useful in a bunchof different apps.And so what is it that we want?We want a random oracle.We want to essentially\nbuild somethingthat looks like that,\ndeterministic, public, random.And we're going to\nclaim that what we wantis this random\noracle which has allof these wonderful properties\nthat I'm going to describe.I'm going to describe\nthe random oracle to you,and then I'm going to tell you\nabout what the properties are.And then unfortunately\nthis is an ideal worldand we can't build\nthis in the real world.And so we're going to\nhave to approximate it.And that's where the MD4's and\nthe MD5's and the SHA-1's camein, OK?So this is not\nachievable in practice.", "start": 600.0, "heat": 0.322}, {"text": "So what is this oracle?This oracle is on input\nx, belonging to 0,1 star.So that could be an\narbitrary string.If x not in the book--\nso there's this the book,all right?And there's this\ninfinite capacity bookthat has all of the computations\nthat were ever done prior.And they're always\nstored in the book.And that's how we're\ngoing to get determinism.Because this book\ninitially gets filled in.All of the entries in\nthe book are filledin using pure randomness.So you flip a coin d\ntimes to determine h of x.So that's basically it.And you just keep flipping.You have to flip d times.And so if x was 0, you\nflip d times, d was 160.You flipped a coin 160\ntimes and got a string.If x were 1, flip 160 times,\nyou get a different stringwith very high\nprobability, obviously.And so on and so forth.But what you do is\nyou have this book.So you're going to record\nx h of x in the book, OK?So at some level\nyour hash functionis this giant look-up\ntable in the sky, right?Actually not giant, infinite\ncapacity look-up tablein the sky.Because you can put\narbitrary strings into this.And if it's in the book-- this\nis obviously the important partthat gives you determinism--\nthen you return y,where x and y are\nin the book, OK?", "start": 720.0, "heat": 0.562}, {"text": "So you get a random\nanswer every time,except as required\nfor consistencywith previous answers.So the very first\ntime you see a string,or-- and the whole world\ncan create this book.It's public.So if I created the book at\nfirst with a particular string,let's say Eric.I was the string.And I'm the one who put\nthe entry-- x equals Eric,and h of x, h of Eric equals\nsome random 160-bit string--into the book, I get\ncredit for that, right?But if you come a nanosecond\nlater and ask for h of Eric,you should get exactly\nwhat got put into the bookwhen I asked for h of Eric.And so on and so forth.So this is true for everybody.So this is like-- I mean\nbasically impossible to get.Because not only can\nanybody and everybody query,you have to have this\nordering associatedwith people querying the book.And you have to\nhave consistency.All right.So everyone convinced\nthat we can't build this?All right.If you took anything\nout of this lecture,that's what you should take.No, no.There's a lot more.So we want to approximate\nthe random oracle.And we're going to get to that.Obviously we're going to have to\ndo this in poly-space as well.So what's wrong with this?Of course this picture is\nI didn't actually say this,but you'd like things to be\npoly-time in terms of space.You don't want to store\nan infinite number-- thisis worse than poly-time,\nworse than exponential time,because it's arbitrary strings\nthat we're talking about here,right?So you can't possibly do that.So we have to do\nsomething better.But before I get into how we'd\nactually build this, and give", "start": 840.0, "heat": 0.614}, {"text": "you a sense of how SHA-1\nand MD5 were built--and that's going to come\na little bit later--I want to spend a lot of time\non the what is interesting,which are the\ndesirable properties.Which you can kind of see\nusing the random oracle.So what is cool about\nthe random oracleis that it's a simple algorithm.You can understand it.You can't implement it.But now you can see what\nwonderful propertiesit gives you.And these properties are\ngoing to be importantfor our applications, OK?And so let's get started with a\nbunch of different properties.And these are all\nproperties thatare going to be useful for\nverification or computersecurity applications.The first one, it's not ow,\nit's O, W. It's one-wayness,all right?So one-way, or one-wayness.And it's also called-- you're\nnot going to call it this--but perhaps this is a more\ntechnical term, a more preciseterm, pre-image resistance.And so what does this mean?Well this is a very\nstrong requirement.I mean a couple of\nother ones are alsogoing to be perhaps stronger.But this is a pretty\nstrong requirementwhich says it's\ninfeasible, given y,which is in the-- it's basically\na d-bit vector, to find any xsuch that h of x equals y.And so this is x is\nthe pre-image of y.", "start": 960.0, "heat": 0.863}, {"text": "So what does this say?It says that I want to\ncreate a hash function suchthat if I give you\na specific-- we callit a 160-bit string, because\nwe're talking SHA-1 here,and that's the hash--\nI'm going to have,it's going to have\nto be impossiblefor me to discover an x that\nproduced that 160-bit string,OK?Now if you go look\nat our random oracle,you realize that if you\nhad a 160-bit string,and perhaps you\nhave the entire bookand you can read\nthe entire book.It's an infinite capacity book.It's got a bunch of stuff in it.And know that any time anyone\nqueried the book the first timefor a given x, that there was\nthis random 160-bit number thatwas generated and\nput into the book.And there's a whole lot\nof these numbers, right?So what's going to\nhappen is, you'regoing to have to look\nthrough the entire book,this entire potentially\ninfinite capacity book,in order to figure out if this\nparticular y is in the bookor not.And that's going to take a long\ntime to do, potentially, OK?So in the case where you\nhave a random oracle you'dhave to go through and find--\nlooking at the output hashcorresponding to each of the\nentries in the random oracle,you're going to start matching,\nmatch, match, match, match,it's going to take\nyou exponential time.Well actually worse than that,\ngiven the infinite capacityof the book.So this clearly gives you that.Now you may not be a completely\nsatisfied with that answerbecause you say well,\nyou can't implement that.But we'll talk a\nlittle bit, as I said,about how you could\nactually get this.But what's-- I should be\nclear-- is that the simple hashfunctions that we've looked\nat in the past just to builddictionaries do not\nsatisfy this, right?", "start": 1080.0, "heat": 0.944}, {"text": "So suppose I had h of x\nequals x square mod p.Is this one-way,\ngiven a public p?No of course not, right?Because I'm going to be--\nit's going to be easyfor me to do something.Even though this is discrete\narithmetic I could do somethinglike, well, I know that what\nI have here-- actually let'sdo it with something\nthat's simpler,and then I'll talk\nabout the x squared.If I had something\nas simple as x mod p,I mean that's trivially broken\nin terms of one-wayness.Because I know that h of x could\nbe viewed as the remainder.So anything-- if this\nis h of x, and let'sjust call that y for a\nsecond, because that'swhat we had it out there.Something that's a multiple\nof y plus the remainder-- so Icould have a-- is that right?Is that what I want?Yeah.No, plus y.So I want a of-- well since\nI can't figure it out,why can't you?What do I need to\nput in there in orderto discover an x that\nwould produce a y?Can I write an equation?Yeah?AUDIENCE: Could you\njust write y itself?SRINIVAS DEVADAS: Just y itself.That's right.Good point.Just y itself in this case.Good.I knew you guys were\nsmarter than me.This proves it.So if you just take\ny-- and y rememberis going to be something\nthat's 0 to p minus 1, right?And that's it.It just goes through, right?So that's a trivial\nexample, right?Now if I put x squared in\nhere, obviously it's not y,but I could start looking\nat-- what I have here is", "start": 1200.0, "heat": 0.545}, {"text": "I'm going to get y that\nlooks like x squared.But I could take\nthe y that I have,take the square root\nof that, and then startlooking for x's that give\nme the y that I have.Actually it's not a complicated\nprocess to try and figure out,through trial and\nerror potentially,what an x is that\nproduces a particular yfor the kinds of hash\nfunctions that we'velooked at, all right?Now as you complicate this\nequation it gets harder.Because you have to invert\nthis set of equations.And that's what\nthe game is goingto be when you go create\none-way hash functions.The amount of computation\nthat you do in orderto compute the y is going\nto increase to the pointwhere, as I mentioned, you have\n80, 100 rounds of computation,things getting mixed in.And the hope is that you create\nthis circuit, if you will,that has all this\ncomputation in that.Going forwards is\neasy, because you'vespecified the\nmultiplications and the modsand so on and so forth.But not all of these operations\nhave simple inverses.And going backwards,\nwhich is whatyou need to do in order\nto break one-wayness,or discover the x\ngiven a y, is goingto be harder and harder\nas the computations getmore complex, OK?So everyone have a sense\nof what one-wayness is?So that's one-wayness.There's four other properties,\ntwo of which are very related.CR and TCR.So CR is collision resistance.It's infeasible to find x and\nx prime such that x not equalto x prime, and h of\nx equals h of x prime,", "start": 1320.0, "heat": 0.533}, {"text": "which is of course a collision.OK?And that just says you have\nthis crazy hash function whereyou can't discover collisions.Well it would be\nabsolutely wonderful.In fact that's what we wanted\nwhen we built dictionaries.But why don't we use\nSHA-3 in dictionaries?Why don't we use\nSHA-3 in dictionaries?Yeah?AUDIENCE: Because it's more\ncomplicated than we need.SRINIVAS DEVADAS: Yeah,\nit's horribly slow, right?It would take longer to\ncompute the hash than accessthe dictionary,\nwhen you actuallyhad a reasonable dictionary\nthat maybe had some collisions.I mean you just go off and\nyou have a linked list,you can afford a few collisions,\nwhat's the big deal, right?So it just doesn't\nmake any senseto use this level of\nheavyweight hash function,even if it satisfies\ncollision resistance-- whichsome of these are conjectured to\ndo-- for the applications we'velooked at.But there'll be other apps\nwhere collision resistance isgoing to be important.So that's collision resistance.And then there's-- TCR is\ntarget collision resistance.It's a weaker form--\nso sometimes peopleCR strong collision resistance,\nand TCR weak occlusionresistance.We'll use CR and TCR here.And this says it's\ninfeasible, givenx-- so there's a\nspecific x that youwant to find a collision\nfor, as opposedto just finding a pair that\ngoes once to x and x prime.And any pair would suffice to\nbreak the collision resistanceproperty.But TCR says is I'm going\nto give you a specific x.And I want you to\nfind an x prime who'shash collides with\nthe hash of x, OK?", "start": 1440.0, "heat": 0.313}, {"text": "That's TCR.OK that's TCR for you.And that just to be clear,\nI think you probablyall got this, obviously\nwe want this herebecause we have a\ndeterministic hash function.And it's a trivial thing\nto say that if you had x,and you had x again, that you\nget the same hash back from it.That's a requirement, really.So we want two distinct x\nand x primes that are notequal that end up colliding.That's really what\na collision is.And so you see the difference\nbetween CR and TCR?Yup?Yeah?AUDIENCE: Are we to\nassume that given an xit's very easy to\nget the h of x back?SRINIVAS DEVADAS:\nSo the questionwas, given an x, it's poly-time\ncomputation to get h of x.Absolutely.Public poly-time computation\ngiven an x to get h of x.So going this way is easy.Going this way-- I ran\nout of room-- hard.OK?AUDIENCE: So does that mean that\nTCR is basically the same as 1?SRINIVAS DEVADAS: No,\nno, no, absolutely not.TCR says it's OK.You can compute this.You can get x.And you can get h of x.So given x, you know\nthat you can get h of x.I didn't actually put\nthat in the definition.And maybe I should have.So given x you can\nalways get h of x.Remember that.It's easy to get h of x.So any time I say given\nx, you can always add it,saying given x and h of x.So I'm given x.I'm given h of x.I obviously need to\nmap-- I need to discoveran x prime such that h of\nx prime equals h of x, OK?Now you have situations\nwhere for-- it", "start": 1560.0, "heat": 0.36}, {"text": "may be the case that\nfor particular x's youcan actually do this.And that's enough to break TCR.So you have to have\nthis strong propertythat you really don't want to\nfind collisions are for some--even if there's a constant\nfraction of x's thatbreak the TCR property, you\ndon't like your hash function,OK?Because you might end\nup picking those and gobuild security applications\nusing those properties.I want to talk a little\nbit about the relationshipbetween OW, CR, and TCR.So I'm going to\nget back to that.And we're going to talking\nabout hash functions thatsatisfy one property but\ndon't satisfy the other.And I think your\nquestion will probablybe answered better, OK?Thanks for the question.So those are the main ones.And really quickly, if you\nwant to spend a lot of timeon this-- but I do\nwant to put up--I think I'll leave\nthese properties up herefor the duration.Because it's important for you\nto see these definitions as welook at the\napplications where werequire these properties, or\na subset of these properties.But that we have\npseudo randomness.And this is simply a\nfunction of the factthat-- so this is PRF-- we know\nwe can't build a random oracle.And so we're going to have to do\nsomething that's pseudo-random.And basically what\nwe're saying hereis the behavior is\nindistinguishable from random.So we're going to have to use\nnon-linearity, things thatare called non-linear\nfeedback shift registers,to create pseudo-random\nfunctions.", "start": 1680.0, "heat": 0.665}, {"text": "There's many ways that we can\ncreate pseudo-random functions.We won't really get into that.But obviously\nthat's what we want.And then the last\none is a bit tricky.And we will have an app that\nrequires this way at the end.But this is infeasible\ngiven h of xto produce h of x prime, where\nx and x prime are-- and it getsa little bit fuzzy here-- are\nrelated in some fashion, right?So a concrete\nexample of this is,let's say that x\nprime is x plus 1.So this is a reasonable\nexample of this.So what this says is\nyou're just given h of x.It doesn't actually say\nanything about one-wayness yet.But you could\nassume, for example,that if this was a\none-way hash function,that it would be possible to\nget x from h of x, correct?And let's keep that though.Hold that thought, all right?We're going to get back to it.So if I'm just given the hash\nthrough some computation,it may be possible for me\nto create another hash, hof x prime, such that\nthere's some relationshipthat I can prove or argue\nfor between the strings thatcreated the hashes,\nnamely x and x prime, OK?That's what\nmalleability is, right?Now you might just go off and\nsay here's an x, here's a y,", "start": 1800.0, "heat": 0.941}, {"text": "here's h of x,\nand here's h of y.These look completely random.And you might go off-- I'm\nbeing facetious here-- Isay that y is x's third cousin's\nroommate's brother-in-lawor something, right?I mean just make\nsomething up, right?So clearly there's got to be\na strong, precise relationshipbetween x and y.If in fact you could\ndo this and get yequals x plus 1, that'd\nbe a problem, right?But if you are--\nand then you cando this sort of consistently\nfor different x's and y's, thatwould absolutely be\na problem, right?But what you're really\nasking for-- and typicallywhen you want\nnon-malleability-- it'sthings where you have\nauctions, for example, whereyou are to be careful about\nmaking sure that you don't wantto expose your bid.And so maybe what you're\ndoing is exposing h of x.You don't want somebody\nto look at your h of xand figure out how\nthey could beatyour bid by just a little bit.Or in case of Vickrey auctions,\nwhere the second highest bidderwins, now just be a little\nbit below you, right?So that's the kind\nof thing that youwant to think about when it\ncomes to non-malleability,or malleability, where you\nwant a strong relationshipbetween two strings\nthat are relatedin some ordered fashion,\nlike x equals-- x primeequals x plus 1, or just\nx prime equals 2 times x.And you don't want\nto be able to-- youdon't want the adversary\nto be able to discoverthese new strings.Because that would be\nthe system, all right?So any questions\nabout properties?Are we all good on\nthese properties?All right, because I'm\ngoing to start asking youhow to use them for\nparticular applications,", "start": 1920.0, "heat": 0.695}, {"text": "or what properties are required\nfor certain applications, OK?One last thing\nbefore we get there.I promised a slightly\nmore detailed analysisof the relationships\nbetween these properties.So let's do that.Now if your just look\nat it, eyeball it,and you look at collision\nresistance and TCR,what can I say about\nthe relationshipbetween CR and TCR?If h is CR, it's going\nto be TCR, right?It's got to be TCR.It's a strictly\nstronger requirement.But not reverse.And you can actually\ngive a concrete exampleof a particular hash\nfunction that is TCR.I'm not going to go there.It's actually a\nlittle more involvedthan you might think it is,\nwhere a TCR hash function isnot collision resistant.But you can see that\nexamples such as theseshould exist, simply because I\nhave a more stringent propertycorresponding to\ncollision resistanceas opposed to TCR, right?So if you're interested in\nthat particular example,you're not responsible for\nit, get in touch with meand I'll point you to a,\nlike a three-page descriptionof an example.So I didn't really\nwant to go in there.But what I do want to do is talk\nabout one-wayness and collisionresistance.Because I think that's\nactually much more interesting,all right?So if h is one-way--\nany conjecturesas to what the question\nmark is in the middle?", "start": 2040.0, "heat": 0.559}, {"text": "Can I make strong statements\nabout the collision resistanceof a hash function,\nif I'm guaranteedthat the hash function I have\nis a one-way hash function,or vice versa?Another way of\nputting it is, can yougive me an example of,\njust to start with,a hash function which is\none-way but not TCR, nottarget collision resistant?So I'm going to try and\nextract this out of you.This is somewhat subtle.But the way you want\nto think about thisis, let's say that h\nof x is OW and TCR, OK?And so I have a bunch of inputs.And this is the output.And I get d-bits out.And I've got x1, x2, to xn, OK?Now I've given this h--\nI've been given this h whichis one-way and TCR.It satisfies those properties\nthat you have up there.In the case of one-way, I give\nyou an arbitrary d-bit string.You can't go backwards and\nfind a bunch of the xi's thatproduce exactly that\nd-bit string, all right?So it's going to be\nhard to get here.But you're allowed now\nto give me an example.So this is some hash\nfunction that you can create,which may use h as well.And h is kind of nice because\nit has this one-way property.So let's say that we want\nto discover something whereone-way does not imply TCR.So I want to cook up a\nhash function h prime such", "start": 2160.0, "heat": 0.537}, {"text": "that h prime is one-way,\nbut it's not TCR, OK?The way you want to think about\nthis is you want to add to h.And you want to add something\nto h such that it's still hard--if you add h it's still hard\nto go from here to there.Because you've got to go deeper.If you add to, for\nexample, the inputs of h.Or you could add to the\noutputs of h as well,or the outputs of the current h.But you can basically go deeper,\nor need to go deeper in orderto find the break\none-wayness, in orderto find an x, whatever you have,\nthat produces the d-bit stringthat you have, right?So what's a simple way of\ncreating an h prime such thatit's going to be pretty easy to\nfind targeted collisions even,not necessarily collisions,\nit's pretty easy to findtargeted collisions,\nwithout breakingthe one-way property of h?Yeah?AUDIENCE: So if you have\nx sub i, if i odd thenreturn h of x of i.So that's minus 1.So return the even group.SRINIVAS DEVADAS: Sure.Yep.AUDIENCE: Given\nx any x of i, youcan usually find another x of\ni that was the same output?You can go backwards.SRINIVAS DEVADAS: You\ncan't go backwards.Yeah, that's good.That's good.I'm going to do something that's\nalmost exactly what you said.But I'm going to\ndraw it pictorially.And what you can do, you can\ndo a parity, like odd and eventhat was just described.And all I'll do is add\na little [? XNOR ?]gate, which is a parity\ngate, to one of the inputs.So you have and b here.So I've taken x1, and\nI have a and b here.", "start": 2280.0, "heat": 0.221}, {"text": "So I've added-- I can\nadd as many inputsas I want to this function.Oh I should mention\nby the way, h of xis working on arbitrary strings.And obviously I\nput in some numberhere that corresponds to\nn, which is a fixed number.So you might ask, what the\nheck happened here with respectto arbitrary strings?And there's two answers.The first answer is,\nwell, ignore arbitrary.And assume that you\nonly have n-bit strings.And n this is really\nlarge number, right?And that may not be\nparticularly satisfying.The other answer is,\nwhich is more practical,which is what's\nused in practice,is that typically\nwhat happens is,you do have particular\nimplementationsof hash functions that\nobviously need to havefixed inputs, n, for example.And n is typically 512.It's usually the block size.And you chunk the input up\ninto five 12-bit blocks.And typically what\nyou do is, youtake the first five 12-bits,\ncompute the hash for it.And then you can do it\nfor the remaining blocks.And then you can hash all\nof them together, all right?So there's typically\nmore invocations.I don't really want\nto get into it.But there's typically\nmore invocations of hwhen the input would be 2 times\nn, or 3 times n, all right?So we don't really\nneed to go therefor the purposes\nof this lecture.But keep that in mind.So we'll still stick with our\narbitrary string requirement.So having said that, take\na look at this picture.And see what this\npicture implies.I have an h prime that\nI've constructed, right?Now if I look at h\nprime, and I give youan output for h prime--\nso h prime now has,it's a function of a and b, and\nx2 all the way to xn, right?So it's got an extra input.If I look at h prime, and I look\nat the output of h prime thatis given to me, and I need\nto discover something thatproduces that, it is pretty\nclear that I need to figure out", "start": 2400.0, "heat": 0.313}, {"text": "what these values\nare, all right?And I need to know what\nthe parity of a and b is.And maybe I don't need to\nknow exactly what a and b are,but I absolutely need to know\nwhat the parity of a and bare, because that's x1.And the one-way I'd\nbreak would requireme to tell you what\nthe value of x1 is,and the value of x2,\nand so on and so forth.So it's pretty clear that\nh prime is one-way, right?Everybody buy that?h prime is one-way.But you know what?I've got target\ncollisions galore, right?All I have to do is flip-- I\nhave a equals 1 and b equals 1.And I have a equals\n0 and b equals 0.They're going to give\nme the same hash, right?So trivial example,\nbut that getsto the essence of the difference\nbetween collision resistanceand one-wayness, target\ncollision resistanceand one-wayness, all right?So this is one-way but not TCR,\nsimply because a equals 0, bequals 0 for\narbitrary x's producethe same thing as a equals\n1 and b equals 1, right?So those are collisions.So admittedly contrived.But it's a counterexample.Counterexamples\ncan be contrived.It's OK.All right.So that was what\nhappens with that.Let's look at one\nmore interesting thingthat corresponds to\nthe other way, right?So what I want to show is that a\nTCR does not imply one-wayness.OK, so now I want an\nexample where it is clear", "start": 2520.0, "heat": 0.479}, {"text": "that I have target collision\nresistance, because I can justassume that.And we're going to\nuse the same strategy.I'm just going assume\nthat I have an h that'starget collision resistant.And I'm going to try and cook up\nan h prime that is not one-way.So I'm going to assume that\nin fact h is TCR and OW.And I'm going to take away\none of the properties.And if I take it one\nof the propertiesI have a counterexample, right?So think about how\nyou could do this.You have h as before.And I want to add\nsome stuff around itsuch that it's going to be\neasy to discover-- for a large,for a constant\nfraction of hashesthat I've given to me,\nnot for any old hash.Because you can always\nclaim that one-waynessis broken by saying I have\nx, I computed h of x, nowI know what-- given h\nof x I know what x is.I mean you can't do that, right?So that's not breaking\nthe one-wayness of it.It's when you have\nan h of x and thisis the first time\nyou've seen it,you're trying to find\nwhat x is, right?So how would you-- how\nwould you set it upso you break the\none-wayness of hwithout necessarily breaking\nthe target collisionresistance of the overall hash\nfunction that you're creating?And you have to do something\nwith the outputs, OK?You have to do something.This is a little more involved.It's not as easy\nas this example.It's a little more involved.But any ideas?Yeah, go ahead.AUDIENCE: So x is\nless than b returns x.If x is greater than\nb, return [INAUDIBLE].SRINIVAS DEVADAS: Beautiful.Right.What color did\nyou get last time?", "start": 2640.0, "heat": 0.529}, {"text": "AUDIENCE: Blue.SRINIVAS DEVADAS: You\ngot a blue last time?All right.Well you get a purple.You have a set.Actually we have these red ones\nthat are precious, that are--no, we don't.We chose not to do red.I don't know.There was some\nsubliminal messageI think with throwing red\nFrisbees that we didn't like.But OK.So thank you.And h of x is simply\nsomething whereI'm going to concatenate\na zero to the x valueand just put it out.And clearly this is\nbreaking one-waynessbecause I'm just taking the\ninput, I'm adding a zero to it,and shipping it out.So it's going to be easy\nto go backwards, right?And this only happens\nif x is less than n,as the gentleman just said.Less than or equal to n in\nterms of the input length, OK?Otherwise I'm\ngoing to do h of x.So this is good news.Because I'm actually using\nthe hash function in the casewhere I have a\nlonger input string.This is bad news for\none-wayness because I'm justpiping out the input.And so if I get an x, and I\nsee what the x is out here,and let's just say\nfor argument's sakethat-- you could\neven say that n isgoing to be something\nthat is less than d,which is the final\noutput, which has d-bits.And so if you see something\nthat h prime producesthat's less than\nd-bits you instantlyknow that you can go\nbackwards and discoverwhat input produced that\nfor the h prime, right?Because you just go off\nand you go backwards.This is what it tells you.", "start": 2760.0, "heat": 0.415}, {"text": "Now on the other\nhand if it's largerobviously you can't do that.But there's a whole\nlot of combinationsthat you can do that for.So this breaks one-wayness, OK?Now you think about TCR.And what you want\na show of courseis that this maintains TCR.So that's the last thing\nthat we have to show.We know that it\nbreaks one-wayness.But if it broke TCR we don't\nquite have our example.So we want to show\nthat it actuallymaintains TCR, which is\nkind of a weakish propertythat we need to maintain.And the reason\nthis maintains TCRis that there's really only\ntwo cases here obviously,corresponding to\nthe if statement.And it's pretty clear that if\nx is less than or equal to n,clearly different x's produce\ndifferent h prime x's, correct?Because I'm just passing\nalong the x out to the output.So if x is less than n I am\ngoing to get different hashesat the output.I'm just passing them out.So that's easy.And for the other case,\nwell I assume that h of xwas CCR, correct?Because that was the original\nassumption, that I had h,which was CCR.So in both cases TCR is\nmaintained because else hof x maintains TCR, all right?So again, a bit of\na contrived exampleto show you the\ndifference betweenthese different properties so\nyou know not to mix them up.You know what you\nwant to ask for,what is required\nwhen you actuallyimplement an\napplication that dependson particular properties.All right?Any questions so\nfar about propertiesor any of these examples?", "start": 2880.0, "heat": 0.436}, {"text": "We're going to dive\nin to using them.OK.So start thinking\ncomputer security.Start thinking hackers,\nprotecting yourselfagainst the bad guys\nthat are out there whoare trying to discover\nyour passwords,trying to corrupt\nyour files, generallymake your life miserable.And we'll start out with\nfairly simple examples, wherethe properties are\nsomewhat obvious,and graduate to this auction\nbidding example whichshould be sort of the\nculmination of at leastthis part of the lecture.And depending on\nhow much time I haveI'll tell you a\nlittle bit about howto implement hash functions.But I think these\nthings are moreimportant from a\nstandpoint of giving youa sense of cryptographic hashes.All right.Password storage.How many of you write your\npassword in an unencrypted textfile and store it in\na readable location?There you go, man.Thank you for being honest.And I do worse.Not only do I do that, I\nuse my first daughter'sname for four passwords.I won't tell you\nwhat the name is.So that's something that\nwe'd like to fix, right?So what do real systems do?Real systems cannot protect\nagainst me using my firstdaughter's name as\na password, right?So there's no way you\ncan protect against that.But if I had a reasonable\npassword, whichhad reasonable\nentropy in it-- solet's assume here that we\nhave reasonable entropy", "start": 3000.0, "heat": 0.664}, {"text": "in the password.And you can just say 128-bits.And it's not a lot, right?128-bits is 16 characters, OK?And you don't have to answer\nthis-- how many of youhave 16 characters\nin your password?Oh I'm impressed.OK.So you've got\n128-bits of entropy.But the rest of you, forget it.This is not going\nto help you, OK?But what I want,\nassuming you havesignificant entropy in your\npassword-- because otherwise,if there's not\nenough entropy youcan just enumerate all possible\npasswords of eight letters.And it's not that much.It's 2 raised to\n50, what have you.And you can just go off.And none of these\nproperties matter.You just-- you have your h of x.It's public.We'll talk about how we\nuse that in a second.But clearly if the\ndomain is smallyou can just\nenumerate the domain.So keep that in mind.I talked about h of\nx, and it's obviouslygoing to be relevant here.But suppose I wanted\nto build a system,and this is how\nsystems are built,ETC slash password\nfile, assumingyou have long passwords\nit does it this way,otherwise it needs something\nthat's called a salt.But that's 6, 8, 57\nand we won't go there.So we just assume\na large entropy.What is it that a system can do?What can it store in order\nto let you in, and onlylet you in when you\ntype your password,and not let some bogus\npassword into the system?Or somebody with a bogus\npassword into the system.Yeah, go ahead.AUDIENCE: If you capture the\npassword when you enter itand compare it to\nwhat's stored--SRINIVAS DEVADAS: Yes.AUDIENCE: If it's a one-way\nhash you know you havewhat the correct password is.SRINIVAS DEVADAS:\nThat's exactly right.That's exactly right.So it's a really simple\nidea, a very powerful idea.It, as I said, assumed that the\nentropy-- and I'm belaboringthe obvious now--\nbut it is importantwhen you talk about security\nto state your assumptions.But you do not store\npassword on your computer.", "start": 3120.0, "heat": 0.796}, {"text": "And you store the\nhash of the password.Now why do I store my\npassword on the computer?Because this is so\ninconvenient, right?So this is what the\nsystem does for me.But the fact of the matter\nis, if I lose my password,this doesn't help me.Because what the system wants\nyou to do is choose a passwordthat is long enough,\nand the h is one-way.So anybody who discovers h of\nPW that is publicly readablecannot discover PW, all right?That's what's cool about this.How do you let\nthe person log in?Use h of PW to compare\nagainst h of PW prime,which is what is entered, where\nPW prime is the typed password.And clearly what we need is\nthe disclosure of h of PWshould not reveal PW.So we definitely\nneed one-wayness.What about-- what about\ncollision resistance?Our target collision resistance?Think practitioner now, right?Are we interested in\nthis hash functionbeing collision resistant?What does that\nmean in this case?Give me the context in this\nparticular application?Yeah, go ahead.AUDIENCE: It means that someone\nentering a different passwordwill have the same\nhash [INAUDIBLE].SRINIVAS DEVADAS: Exactly.So it means that what you have\nis a situation where you do notreveal-- and so what might\nhappen is that h of PW prime", "start": 3240.0, "heat": 0.392}, {"text": "equals h of PW.But h of PW equals\nh of PW prime.But PW is not equal to PW prime.What you have is\na false positive.Someone who didn't\nknow your passwordbut guessed right-- and\nthis is a 128-bit value,and they guessed right--\nis going to get it.You don't particularly\ncare of the probabilityof this occurrence.It's really small.Typically you're going to\nhave systems that lock you outif you try 10 tries that occurs\none, two, wrong passwords,right?So really in systems\nyou do not require--you do want to\nbuild systems thathave minimal\nproperties with respectto the perimeters that are used.So from a system building\nstandpoint just require OW.Don't go overboard.Don't require collision\nresistance or TCR, OK?Let's do a slightly\ndifferent example.Also a bit of a\nwarm-up for what'scoming next, which is a\nfile modification detector.So for each file F, I'm going to\nstore h of F. And as securely.So you assume that this means\nthat h of F cannot be modifiedby anybody, h of F itself.And now we want to\ncheck if F is modifiedby re-computing h of\nF. Which could be,", "start": 3360.0, "heat": 0.481}, {"text": "this could be modified.So this could\nactually be F prime.You don't know that.You have a file.It's a gigabyte.And somebody might\nhave tampered with oneof the bits in the file.All you have is a\nd-bit digest thatcorresponds to h of F that you\nstored in a secure location.And you want to check\nto see, by re-computingh of F, the file\nthat is given to you,and comparing it with what\nyou've stored, the h of Fthat you've stored.And so what property do we\nneed in order to pull this off?Of hash functions.What precisely do we\nneed to pull this off?What is the adversary\ntrying to do?And what is a successful break?A successful break is if an\nadversary can modify the fileand keep h of F the same, right?That would be a\nsuccessful break, right?Yup.Go ahead.AUDIENCE: TCR.SRINIVAS DEVADAS: TCR?Yeah, absolutely.You need TCR.So you want to modify the file.So you're given that\nthe file-- the adversaryis given the file, which\nis the input to the hash,and is going to try and\nmodify-- modify the file, right?So let's do a couple more.And we're going to advance our\nrequirements here a little bit.So those two are\nbasic properties.", "start": 3480.0, "heat": 0.998}, {"text": "I want to leave this up there.We're going to do\nsomething that correspondsto digital signatures.So digital signatures are\nthis wonderful inventionthat came out of MIT in a\ncomputer science laboratory--again, Ron Rivest and\ncollaborators-- whichare a way of digitally\nsigning a document usinga secret key, a private key.But anybody who has\naccess to a public key,so it could be\npretty much anybody,could verify the authenticity\nof that signature, right?So that's what a\ndigital signature is.So we're going to talk\nabout public cryptographyon Thursday, in terms\nof how you could buildsystems or encryption algorithms\nthat are public key algorithms.But here I'll just tell you\nwhat we want out of them.Essentially what we have here\nin the case of signatures,we actually want to talk\nabout encryption here,are-- there's two\nkeys associatedwith a public key system.Anybody and everybody\nin the systemwould have a public key that\nyou can put on your website.And you also have a secret key--\nthat's like your password--that you don't\nwant to write down,you don't want to give away,\nbecause that's effectivelyyour identity.And what digital\nsignatures respond toare that you have\ntwo operations.You have signing\nand verification.So signing means that you\ncreate a signature sigma thatis the sign using your\nprivate key, your secret key,", "start": 3600.0, "heat": 0.936}, {"text": "off a message M. So you're\nsaying this is this message,it came from me, right?That's what signing means.You have this long message\nand you sign it at the bottom.You're taking responsibility for\nthe contents of that message.And then verification is you\nhave M sigma and a public key.And this is simply going\nto output true or false.And so the public key should\nnot reveal any informationabout the secret key.And that's the challenge\nof building PKI systems,that we'll talk about in\nsome detail next time.But we don't need to\nthink about that otherthan acknowledging it today.So the public and private\nkey are two distinct things,neither one of which reveals\nanything about the other.Think of them as completely\ndistinct passwords.But they happen to be\nmathematically related.That's why this\nwhole thing works.And that mathematical\nrelationshipwe'll look at in some\ndetail on Thursday.But having said\nthat, take a lookat what this app is\ndoing for us, right?This is a security application.And I haven't quite gotten\nto hash functions yet.But I'll get to it\nin just a minute.But what I want to do is\nemphasize that there'stwo operations going on.One of which is a\nsignature, whichis a private signature, in the\nsense that it's private to me,if I'm Alice.Or private to Alice.And you're using\nsecret informationon this public message,\nM, because that'sgoing to be publicized.And you're going to\nsign the public message.And then anybody in the\nworld who has access", "start": 3720.0, "heat": 0.717}, {"text": "to Alice's public key is\ngoing to be able to say,oh I'm looking at the signature,\nwhich is a bunch of bits.I'm looking at the message,\nwhich is a whole lot of bits.And I have this public key,\nwhich is a bunch of bits.And I'm going to be\nable to tell for surethat either Alice\nsigned this message,or Alice did not\nsign this message.And the assumption\nhere is that Alicekept her private key secret.And of course, what\nI just wrote there,that the public key\ndoes not reveal anythingabout the secret key, OK?So that's digital signatures\nfor you, in a nutshell.And when you do MIT\ncertificates you'reusing digital signatures a la\nRivest-Shamir-Adleman, the RSAalgorithm.So you're using\nthis all the time,when you click on 6.046\nlinks, for example.And what happens is M is\ntypically really large.I mean it could\nbe a file, right?It could be a large file.And you don't necessarily want\nto compute these operationson large files.So for convenience, what happens\nis you end up hashing the file.And for large M it's\neasier to sign h of M.And so replace the M's that\nyou see here with h of M,all right?So now that we're given that\nwe're going to be doing h of Min here, think\nabout what we wantedto accomplish with M, right?I told you what we wanted\nto accomplish with M.There's a particular message.I'm Alice.I'm going to keep my\nsecret key secret.But I want to commit to signing\nthis message M, all right?And I want to make\nsure that nobody", "start": 3840.0, "heat": 0.644}, {"text": "can pretend to be me who\ndoesn't know my secret key.And nobody does.So if I'm going to be signing\nthe hash of the message,now it comes down\nto today's lecture.I'm signing the hash\nof the message h of M.What property do I require of\nh in order for this whole thingto work out?Yeah, go ahead.AUDIENCE: Is it\nnon-malleability?SRINIVAS DEVADAS: Non\nmalleability, but even beforethat-- suppose-- absolutely,\nbut non-malleabilityis kind of beyond one of these\nproperties over on the right.You're on the\nright track, right?So do you want to give\nme a different answer?You can give me a\ndifferent answer.AUDIENCE: Oh, I'm not sure.SRINIVAS DEVADAS: OK.What?Yeah, back there.AUDIENCE: I think you wanted to\none-way because otherwise youcould take that signature and\nfind another message that youcould credit.SRINIVAS DEVADAS: I\ncan make M public.I can make M-- M can be public.And h of M is public.So one-wayness is not\ninteresting for this exampleif M is public.And we can assume that M\neventually gets public.Because that's the message\nI'm signing, right?I can also put M out.So I want the\nrelationship-- I wantyou to focus on the relationship\nbetween h of M and Mand tell me what would\nbreak this system.And you're on the right track.Yeah, go ahead.Or way back there.Yeah, sorry about that.AUDIENCE: TCR.SRINIVAS DEVADAS: TCR.Why TCR?AUDIENCE: [INAUDIBLE].SRINIVAS DEVADAS: So I have\nM. So what happens here--I should write this out.I'm given-- as an adversary I\nhave M and h of M. It is bad", "start": 3960.0, "heat": 0.256}, {"text": "if Alice signs h of M, but Bob\nclaims Alice signed M prime.Because h of M equals\nh of M prime, right?That is bad.So the M is public--\ncould you stand up?M is given.There's a specific\nM, and a specific hof M in particular,\nthat has been exposed.And h of M is what was\nused for the signature.So you want to keep\nh of M the same.It's a specific one.So it's not\ncollision resistance,it's target\ncollision resistance,because that's given to you.And you want to\nkeep that the same.But you want to claim that oh,\nyou promised me $10,000, not$20, right?If you can do that,\nyou signed sayingyou want to pay $10,000, not\n$20, then you've got a problem.So your thing is very close.It's just that it doesn't need\nto be a strong relationshipbetween the 10,000 or the 20.I mean I give you a\nconcrete example of that.But it could be more,\nit could be less.Anything that is different\nfrom what you signed,be it with the numerical\nrelationship or not,would cause a problem and\nbreak this scheme, all right?Are we good?All right, one last example,\nthe most interesting one.And as I guessed I'm\nprobably not goingto get to saying very much\nabout how cache functions are", "start": 4080.0, "heat": 0.353}, {"text": "implemented.But maybe I'll spend\na minute or two on it.So let's do this example that\nhas to do with commitments.Commitment is important, right?You want to commit\nto doing things.You want to keep your promises.And in this case we\nhave a legal requirementthat you want to be able to make\npeople honor their commitments,and not weasel their way\nout of commitments, right?And we want to deal with\nthis computationally.And let's think about auctions.So Alice has value x,\ne.g. an auction bid.Alice computes what\nwe're going to callC of x, which is a commitment\nof x, and cements it, right?C of x, C of x is-- let's\nassume that the auctioneer,and perhaps other auctionees\nas well, see C of x.You have to submit it\nto somebody, right?So you can assume\nthat that's exposed.And what is going to happen\nis, when bidding is over Aliceis going to open--\nso this is-- Cof x can be thought\nof as sealing the bid.", "start": 4200.0, "heat": 0.301}, {"text": "So that's the commitment.You're sealing the--\nyou're making a bidand you're sealing\nit in an envelope.You've committed to that.That's obviously, what\nhappens in real lifewithout cryptography,\nbut we wantto do this with cryptography,\nwith hash functions.And so now Alice opens\nC of x to reveal x.So she has to prove that\nin fact x was her bid.And that it matches\nwhat she sealed.When you open it up, think\nabout it conceptuallyfrom a standpoint of\nwhat happens with paper,and then we have to think\nabout this computationallyand what this implies, right?So again I'll do a\nlittle bit of set up.And then we have start\ntalking about the propertiesthat we want for this\nparticular application.So there are a bunch\nof people who aredoing bidding for this auction.I don't-- I want\nto be the first--I don't want to\nspend a lot of money.But I want to win.All of us are like that, right?If I know information\nabout your bid,that is obviously a\ntremendous advantage.So clearly that\ncan't happen, right?If I know one other person's\nbid I just do plus 1 on that.If I know everybody else's I\njust do plus 1 on the maximum.So clearly there's some secrecy\nthat's required here, correct?So C of x is going to\nhave to do two things.It can't reveal x.Because then even maybe\nthe auctioneer is bad.Or other people are\nlooking at this.And you can just assume that C\nof x is-- the C of x's are allpublic.But I also need a\nconstraint that'sassociated with C of x\nthat corresponds to makingsure Alice is honest, correct?So I need to make Alice\ncommit to something, right?So what are the different\nproperties of the hash functionthat if I use h of\nx here, that I'd", "start": 4320.0, "heat": 0.582}, {"text": "want h to satisfy in order\nfor this whole processto work like it's supposed to\nwork with paper and envelopes?Yeah, go ahead.AUDIENCE: It has to be\none-way [INAUDIBLE].SRINIVAS DEVADAS: It\nhas to be one-way.And explain to me-- so I\nwant a description of ithas to be one-way, because why?AUDIENCE: Because\nyou want all the cx's to be hidden from\nall the other options.SRINIVAS DEVADAS: Right.C of x should not\nreveal x, all right?All right.That's good.Do you have more?It has to be\ncollision resistant.OK.I guess.A little bit more.You're getting there.What-- why is it\ncollision resistant?AUDIENCE: Because you want\nto make sure that Alice,when she makes a bid that\nshe commits that bid.If she's not going to resist\nit then she could bid $100and then find something else.SRINIVAS DEVADAS:\nThat's exactly right.So CR, because\nAlice should not beable to open this in\nmultiple ways, right?And in this case it's\nnot TCR in the sensethat Alice controls\nwhat her bids are.And so she might find a pair\nof bids that collide, correct?She might realize that in\nthis particular hash function,you know $10,000 and a billion\ndollars collide, right?", "start": 4440.0, "heat": 0.601}, {"text": "And so she figures\ndepending on what happens,she's a billionaire,\nlet's assume.She's going to open\nthe right thing.She's a billionaire, but\nshe doesn't necessarilywant to spend the billion, OK?So that's that, right?But I want more.Go ahead.AUDIENCE: You don't\nwant it to be malleable.Assuming that the\nauctioneer is not honestbecause you don't want to\naccept a bribe from someoneand then change\neveryone else's bidto square root of\nwhatever they bid.SRINIVAS DEVADAS:\nThat's exactly right.Or plus 1, which is a\ngreat example, right?So there you go.I ran out of Frisbees.You can get one next time.So yeah, I don't\nneed this anymore.You're exactly right.There's another-- it turns out\nit's even more subtle than whatyou just described.And I think I might be able\nto point that out to you.But let me just first\ndescribe this answer, whichgives us non-malleability.So the claim is that you\nalso want non-malleabilityin your hash function.And the simple reason is,\ngiven C of x-- and let's assumethat this is public.It's certainly public\nto the auctioneer,and it could be public to\nthe other bidders as well.Because the notion of\nsealing is that you'vesealed it using C of x.But people can see the\noutside of the envelope, whichis C of x.So everyone can see C of x.You still want this to work,\neven though all other bidderscan see C of x.So given C of x, should\nnot be possible to produceC of x plus 1.You don't know x is.But if you can produce C of\nx plus 1, you win, all right?And so that's the problem.Now it turns out you\nnow say OK, am I done?", "start": 4560.0, "heat": 0.666}, {"text": "I want these three properties.And I'm done, right?There's a little\nsubtlety here whichthese properties don't capture.So that's why there's more here.And I don't mean to\ntitillate, because I'lltell you what is missing here.But let's say that I have a hash\nfunction that looks like this.And this here is non-malleable.It is collision resistant.And it's one-way, all right?So h of x has all these\nwonderful properties,all right?I'm creating an h\nprime x that lookslike this, which is\na concatenation of hof x, and giving away the most\nsignificant bit of x, whichis my bid, right?I'm just giving\nthat away, right?The problem here is\nthat we haven't reallymade our properties\nbroad enough to solvethis particular\napplication to the extentthat there's contrived cases\nwhere these properties aren'tenough, OK?And the reason is simple.h prime x is arguably\nNM, CR, and OW.And I won't go into to\neach of those arguments.But you can think\nabout it, right?If I'm just giving you one\nbit, there's 159 others,there's a couple of\nhundred others, whatever itis that I have in the domain.It's not going to be invertible.h prime x is not going to\nbe invertible if h of xis not invertible.h prime x is not going to be\nbreakable in terms of collisionresistance if h of\nx is not breakable,", "start": 4680.0, "heat": 0.434}, {"text": "and so on and so forth.But if I had a hash\nfunction like that,is it a good hash function\nfor my commitment application?No, obviously not.Because if I publicize this\nhash function-- remember,everything is public\nhere with respectto h and h prime-- you\nare giving away the mostsignificant that\ncorresponds to your bidin this particular\nhash function, right?So you really need a little bit\nmore than these for secrecy,for true secrecy.But in the context\nof this example,I mean it's common\nsense that you would notuse the hash function\nlike that, right?So it's not that there's\nanything profound here.It's just that I\nwant to make surethat you understand the\nnuances of the propertiesthat we're requiring.We had all the\nrequirements correspondingto the definitions\nof NM and CR and OW.And you need a little bit\nmore for this example, whereyou have to say something,\nperhaps informally,like the bits of your auction\nare scrambled in the final hashoutput, which most hash\nfunctions should do anyway,and h of x will definitely do.But you kind of unscrambled\nit by adding this little thingin here, corresponding to\nthe most significant thing,all right?So I'll stop with that.Let me just say that the\noperation-- or sorry,the work involved in\ncreating hash functions thatare poly-time computable\nis research work.People put up hash functions\nand they get broken,like MD4 was put up in '92 and\nthen got broken, SHA-1 and soon and so forth.And so I just encourage you\nto look up SHA-3 and just takea quick scan and what\nthe complexity of SHA-3is with respect to computing the\nhash given an arbitrary string,all right?I'll stick around for questions.", "start": 4800.0, "heat": 0.404}]