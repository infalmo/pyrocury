[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high-quality,\neducational resources for free.To make a donation, or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.ANA BELL: All right.Let's begin.As I mentioned\nbefore, this lecturewill be recorded for OCW.Again, in future\nlectures, if youdon't want to have the\nback of your head show up,just don't sit in\nthis front area here.First of all, wow,\nwhat a crowd, you guys.We're finally in 26-100.6.0001 made it big, huh?Good afternoon and welcome to\nthe very first class of 6.0001,and also 600, this semester.My name is Ana Bell.First name, Ana.Last name, Bell.I'm a lecturer in\nthe EECS Department.And I'll be giving some\nof the lectures for today,along with later on in the term,\nProfessor Eric Grimson, who'ssitting right down there, will\nbe giving some of the lectures,as well.Today we're going to go over\nsome basic administrivia,a little bit of\ncourse information.And then, we're going\nto talk a little bitabout what is computation?We'll discuss at\na very high levelwhat computers do just\nto make sure we're allon the same page.And then, we're going to dive\nright into Python basics.We're going to talk a little bit\nabout mathematical operationsyou can do with Python.And then, we're going to\ntalk about Python variablesand types.As I mentioned in my\nintroductory email, allthe slides and code that I'll\ntalk about during lectureswill be up before\nlecture, so I highlyencourage you to download\nthem and to have them open.We're going to go through some\nin-class exercises which willbe available on those slides.And it's fun to do.And it's also great if could\ntake notes about the code just", "start": 0.0, "heat": 0.1}, {"text": "for future reference.It's true.This is a really\nfast-paced course,and we ramp up really quickly.We do want to position you\nto succeed in this course.As I was writing\nthis, I was tryingto think about when\nI was first startingto program what helped\nme get through my veryfirst programming course.And this is really a good list.The first thing was I just\nread the psets as soonas they came out, made sure that\nthe terminology just sunk in.And then, during\nlectures, if the lecturerwas talking about something\nthat suddenly I remembered,oh, I saw that word in the pset\nand I didn't know what it was.Well, hey, now I\nknow what it is.Right?So just give it a read.You don't need to start it.If you're new to programming, I\nthink the key word is practice.It's like math or reading.The more you practice,\nthe better you get at it.You're not going to\nabsorb programmingby watching me write programs\nbecause I already know howto program.You guys need to practice.Download the code\nbefore lecture.Follow along.Whatever I type,\nyou guys can type.And I think, also,\none of the big thingsis if you're new to\nprogramming, you'rekind of afraid that you're\ngoing to break your computer.And you can't really do that\njust by running Anacondaand typing in some commands.So don't be afraid to\njust type some stuff inand see what it does.Worst case, you just\nrestart the computer.Yeah.That's probably the\nbig thing right there.I should have probably\nhighlighted it,but don't be afraid.Great.So this is pretty much a\nroadmap of all of 6.0001 or 600as I've just explained it.There's three big things we\nwant to get out of this course.The first thing is the\nknowledge of concepts,which is pretty much true of\nany class that you'll take.The class will teach you\nsomething through lectures.Exams will test\nhow much you know.", "start": 120.0, "heat": 0.1}, {"text": "This is a class in programming.The other thing we want\nyou to get out of itis programming skills.And the last thing,\nand I think thisis what makes this\nclass really great,is we teach you how\nto solve problems.And we do that\nthrough the psets.That's really how I feel\nthe roadmap of this courselooks like.And underlying all of\nthese is just practice.You have to just type some\nstuff away and code a lot.And you'll succeed in\nthis course, I think.OK.So what are the things we're\ngoing to learn in this class?I feel like the things we're\ngoing learn in this classcan be divided into basically\nthree different sections.The first one is related to\nthese first two items here.It's really about\nlearning how to program.Learning how to\nprogram, part of itis figuring out what\nobjects to create.You'll learn about these later.How do you represent knowledge\nwith data structures?That's sort of the\nbroad term for that.And then, as you're\nwriting programs,you need to-- programs\naren't just linear.Sometimes programs jump around.They make decisions.There's some control\nflow to programs.That's what the second\nline is going to be about.The second big\npart of this courseis a little bit more\nabstract, and itdeals with how do you write\ngood code, good style,code that's readable.When you write code, you\nwant to write it suchthat-- you're in big company,\nother people will read it,other people will\nuse it, so it hasto be readable and\nunderstandable by others.To that end, you\nneed to write codethat's well organized,\nmodular, easy to understand.And not only that, not\nonly will your codebe read by other people,\nbut next year, maybe,you'll take another\ncourse, and you'llwant to look back at\nsome of the problemsthat you wrote in this class.You want to be able\nto reread your code.", "start": 240.0, "heat": 0.1}, {"text": "If it's a big mess, you might\nnot be able to understand--or reunderstand--\nwhat you were doing.So writing readable\ncode and organizing codeis also a big part.And the last section is going\nto deal with-- the first twoare actually part of the\nprogramming in Introductionto Programming and\nComputer Science in Python.And the last one deals mostly\nwith the computer science partin Introduction to Programming\nand Computer Science in Python.We're going to talk about,\nonce you have learnedhow to write programs\nin Python, how doyou compare programs in Python?How do you know that one program\nis better than the other?How do you know\nthat one program ismore efficient than the other?How do you know\nthat one algorithmis better than the other?That's what we're going to\ntalk about in the last partof the course.OK.That's all for the\nadministrative partof the course.Let's start by talking at a high\nlevel what does a computer do.Fundamentally, it\ndoes two things.One, performs calculations.It performs a lot\nof calculations.Computers these days\nare really, really fast,a billion calculations per\nsecond is probably not far off.It performs these\ncalculations and ithas to store them somewhere.Right?Stores them in computer memory.So a computer also has\nto remember results.And these days, it's not\nuncommon to find computerswith hundreds of\ngigabytes of storage.The kinds of calculations\nthat computers do,there are two kinds.One are calculations that\nare built into the language.These are the very\nlow level typesof calculations,\nthings like addition,subtraction,\nmultiplication, and so on.And once you have\na language thathas these primitive calculation\ntypes, you, as a programmer,can put these types\ntogether and then defineyour own calculations.You can create new\ntypes of calculations.", "start": 360.0, "heat": 0.1}, {"text": "And the computer will be able\nto perform those, as well.I think, one thing\nI want to stress--and we're going to\ncome back to thisagain during this entire\nlecture, actually--is computers only know\nwhat you tell them.Computers only do what\nyou tell them to do.They're not magical.They don't have a mind.They just know how to\nperform calculations really,really quickly.But you have to tell them\nwhat calculations to do.Computers don't know anything.All right.We've come to that.Let's go into the\ntypes of knowledge.The first type of knowledge\nis declarative knowledge.And those are things\nlike statements of fact.And this is where my\nemail came into play.If you read it all\nthe way to the bottom,you would have entered a raffle.So a statement of fact\nfor today's lectureis, someone will win a\nprize before class ends.And the prize was\na Google Cardboard.Google state-of-the-art\nvirtual reality glasses.And I have them right here.Yea.I delivered on my promise.That's a statement of fact.So pretend I'm a machine.OK?I don't know anything\nexcept what you tell me.I don't know.I know that you tell\nme this statement.I'm like, OK.But how is someone going\nto win a Google Cardboardbefore class ends, right?That's where imperative\nknowledge comes in.Imperative knowledge is\nthe recipe, or the how-to,or the sequence of steps.Sorry.That's just my\nfunny for that one.So the sequence of steps\nis imperative knowledge.If I'm a machine,\nyou need to tell mehow someone will win a Google\nCardboard before class.", "start": 480.0, "heat": 0.1}, {"text": "If I follow these\nsteps, then technically,I should reach a conclusion.Step one, I think we've\nalready done that.Whoever wanted to\nsign up has signed up.Now I'm going to open my IDE.I'm just basically\nbeing a machineand following the steps\nthat you've told me.The IDE that we're using in\nthis class is called Anaconda.I'm just scrolling\ndown to the bottom.Hopefully, you've installed\nit in problem set zero.I've opened my IDE.I'm going to follow the\nnext set of instructions.I'm going to choose a random\nnumber between the firstand the nth responder.Now, I'm going to actually\nuse Python to do this .And this is also an\nexample of how justa really simple\ntask in your life,you can use computers or\nprogramming to do that.Because if I chose\na random number,I might be biased\nbecause, for example,I might like the number 8.To choose a random number,\nI'm going to go and say, OK,where's the list of responders?It starts at 15.Actually, it starts at\n16 because that's me.We're going to choose a\nrandom number between 16and the end person 266.Oh, we just got-- oh.OK.OK.I'm going to cut\nit off right here.271.OK.16 and 271.Perfect.OK.I'm going to choose\na random number.I'm going to go to my IDE.And you don't need to\nknow how to do this yet,but by the end of\nthis class, you will.I'm just going to use Python.I'm just going to get the random\nnumber package that's goingto give me a random number.I'm going to say random.randint.And I'm going to choose a random\nnumber between 16 and 272,OK.75.OK.Great.I chose a random number.And I'm going to find the\nnumber in the responder's sheet.What was the number again?Sorry.75.OK.Up we go.There we go.Lauren Z-O-V. Yeah.", "start": 600.0, "heat": 0.1}, {"text": "Nice.You're here.Awesome.All right.That's an example of me\nbeing a machine and also,at the same time, using\nPython in my everyday life,just lecturing, to\nfind a random number.Try to use Python\nwherever you can.And that just\ngives you practice.That was fun.But we're at MIT.We're MIT students.And we love numbers here at MIT.Here's a numerical\nexample that showsthe difference between\ndeclarative and imperativeknowledge.An example of\ndeclarative knowledgeis the square root of a number\nx is y such that y times yis equal to x.That's just a statement\nof fact It's true.Computers don't know\nwhat to do with that.They don't know what to\ndo with that statement.But computers do know\nhow to follow a recipe.Here's a well-known algorithm.To find the square\nroot of a number x,let's say x is originally\n16, if a computer followsthis algorithm, it's going\nto start with a guess, g,let's say, 3.We're trying to find\nthe square root of 16.We're going to calculate\ng times g is 9.And we're going to\nask is if g times gis close enough to x, then\nstop and say, g is the answer.I'm not really happy with\n9 being really close to 16.So I'm going to say,\nI'm not stopping here.I'm going to keep going.If it's not close\nenough, then I'mgoing to make a new guess\nby averaging g and x over g.That's x over g here.And that's the\naverage over there.And the new average is\ngoing to be my new guess.", "start": 720.0, "heat": 0.1}, {"text": "And that's what it says.And then, the last step\nis using the new guess,repeat the process.Then we go back to the beginning\nand repeat the whole processover and over again.And that's what the\nrest of the rows do.And you keep doing\nthis until you decidethat you're close enough.What we saw for the\nimperative knowledgein the previous\nnumerical examplewas the recipe for how to\nfind the square root of x.What were the three\nparts of the recipe?One was a simple\nsequence of steps.There were four steps.The other was a flow of\ncontrol, so there wereparts where we made decisions.Are we close enough?There were parts where\nwe repeated some steps.At the end, we said,\nrepeat steps 1, 2, 3.That's the flow of control.And the last part of the\nrecipe was a way to stop.You don't want a program\nthat keeps going and going.Or for a recipe, you don't want\nto keep baking bread forever.You want to stop at some point.Like 10 breads is enough, right?So you have to have\na way of stopping.In the previous example,\nthe way of stoppingwas that we decided\nwe were close enough.Close enough was maybe\nbeing within .01, .001,whatever you pick.This recipe is there\nfor an algorithm.In computer science speak,\nit's going to be an algorithm.And that's what we're going\nto learn about in this class.We're dealing with computers.And we actually want\nto capture a recipeinside a computer, a computer\nbeing a mechanical process.Historically, there were two\ndifferent types of computers.Originally, there\nwere these thingscalled fixed-program computers.And I'm old enough to\nhave used something", "start": 840.0, "heat": 0.1}, {"text": "like this, where there's\njust numbers and plus, minus,multiplication,\ndivide, and equal.But calculators these days\nare a lot more complicated.But way back then, an example\nof a fixed-program computeris this calculator.It only knows how to do\naddition, multiplication,subtraction, division.If you want to plot\nsomething, you can't.If you want to go on the\ninternet, send email with it,you can't.It can only do this one thing.And if you wanted to create a\nmachine that did another thing,then you'd have to create\nanother fixed-program computerthat did a completely\nseparate test.That's not very great.That's when stored-program\ncomputers came into play.And these were machines\nthat could storea sequence of instructions.And these machines could execute\nthe sequence of instructions.And you could change the\nsequence of instructionsand execute this different\nsequence of instructions.You could do different\ntasks in the same machine.And that's the computer\nas we know it these days.The central processing unit is\nwhere all of these decisionsget made.And these are all\nthe peripherals.The basic machine architecture--\nat the heart of every computerthere's just this\nbasic architecture--and it contains, I\nguess, four main parts.The first is the memory.Input and output\nis the other one.The ALU is where all of\nthe operations are done.And the operations\nthat the ALU can doare really primitive operations,\naddition, subtraction,and so on.What the memory contains\nis a bunch of dataand your sequence\nof instructions.", "start": 960.0, "heat": 0.1}, {"text": "Interacting with the Arithmetic\nLogic Unit is the Control Unit.And the Control Unit\ncontains one program counter.When you load a sequence\nof instructions,the program counter starts\nat the first sequence.It starts at the sequence,\nat the first instruction.It gets what the instruction\nis, and it sends it to the ALU.The ALU asks, what are we\ndoing operations on here?What's happening?It might get some data.If you're adding two numbers,\nit might get two numbersfrom memory.It might do some operations.And it might store\ndata back into memory.And after it's done, the\nALU is going to go back,and the program counter\nis going to increaseby 1, which means\nthat we're goingto go to the next sequence\nin the instruction set.And it just goes linearly,\ninstruction by instruction.There might be one\nparticular instructionthat does some sort of test.It's going to say, is\nthis particular valuegreater or equal to or the same\nas this other particular value?That's a test, an\nexample of a test.And the test is going to\neither return true or false.And depending on the\nresult of that test,you might either go to\nthe next instruction,or you might set\nthe program counterto go all the way back to\nthe beginning, and so on.You're not just\nlinearly steppingthrough all the instructions.There might be some\ncontrol flow involved,where you might\nskip an instruction,or start from the\nbeginning, or so on.And after you're done,\nwhen you finishedexecuting the last\ninstruction, then youmight output something.That's really the basic\nway that a computer works.Just to recap, you have\nthe stored program computerthat contains these\nsequences of instructions.The primitive operations\nthat it can do", "start": 1080.0, "heat": 0.1}, {"text": "are addition, subtraction,\nlogic operations, tests--which are something equal\nto something else, somethingless than, and so\non-- and moving data,so storing data, moving data\naround, and things like that.And the interpreter goes\nthrough every instructionand decides whether you're going\nto go to the next instruction,skip instructions, or repeat\ninstructions, and so on.So we've talked\nabout primitives.And in fact, Alan Turing, who\nwas a really great computerscientist, he showed that\nyou can compute anythingusing the six primitives.And the six primitives are move\nleft, move right, read, write,scan, and do nothing.Using those six instructions\nand the piece of tape,he showed that you\ncan compute anything.And using those\nsix instructions,programming languages\ncame about thatcreated a more convenient\nset of primitives.You don't have to program\nin only these six commands.And one interesting thing, or\none really important thing,that came about from\nthese six primitivesis that if you can compute\nsomething in Python,let's say-- if you write a\nprogram that computes somethingin Python, then,\nin theory, you canwrite a program that\ncomputes the exact same thingin any other language.And that's a really\npowerful statement.Think about that today when\nyou review your slides.Think about that again.That's really powerful.Once you have your\nset of primitivesfor a particular language, you\ncan start creating expressions.And these expressions\nare going to becombinations of the primitives\nin the programming language.", "start": 1200.0, "heat": 0.1}, {"text": "And the expressions are\ngoing to have some value.And they're going up some\nmeaning in the programminglanguage.Let's do a little bit of\na parallel with Englishjust so you see what I mean.In English, the\nprimitive constructsare going to be words.There's a lot of words\nin the English language.Programming languages-- in\nPython, there are primitives,but there aren't\nas many of them.There are floats,\nBooleans, theseare numbers, strings,\nand simple operators,like addition,\nsubtraction, and so on.So we have primitive constructs.Using these\nprimitive constructs,we can start creating, in\nEnglish, phrases, sentences,and the same in\nprogramming languages.In English, we can say\nsomething like, \"cat, dog, boy.That, we say, is not\nsyntactically valid.That's bad syntax.That's noun, noun, noun.That doesn't make sense.What does have good syntax in\nEnglish is noun, verb, noun.So, \"cat, hugs boy\" is\nsyntactically valid.Similarly, in a\nprogramming language,something like this-- in\nPython, in this case-- a wordand then the number five\ndoesn't really make sense.It's not syntactically valid.But something like operator,\noperand, operator is OK.So once you've created these\nphrases, or these expressions,that are syntactically\nvalid, youhave to think about the static\nsemantics of your phrase,or of your expression.For example, in English, \"I\nare hungry\" is good syntax.But it's weird to say.We have a pronoun, a verb,\nand an adjective, whichdoesn't really make sense.\"I am hungry\" is better.", "start": 1320.0, "heat": 0.1}, {"text": "This does not have\ngood static semantics.Similarly, in\nprogramming languages--and you'll get the\nhang of this the moreyou do it-- something like\nthis, \"3.2 times 5, is OK.But what does it mean?What's the meaning to have\na word added to a number?There's no meaning behind that.Its syntax is OK,\nbecause you haveoperator, operand, operator.But it doesn't really make\nsense to add a number to a word,for example.Once you have created\nthese expressions thatare syntactically correct and\nstatic, semantically correct,in English, for example, you\nthink about the semantics.What's the meaning\nof the phrase?In English, you can\nactually have more than onemeaning to an entire phrase.In this case, \"flying\nplanes can be dangerous\"can have two meanings.It's the act of flying\na plane is dangerous,or the plane that is in\nthe air is dangerous.And this might be\na cuter example.\"This reading lamp\nhasn't uttered a wordsince I bought it.What's going on?\"So that has two meanings.It's playing on the\nword \"reading lamp.\"That's in English.In English, you\ncan have a sentencethat has more than\none meaning, that'ssyntactically correct and\nstatic, semantically correct.But in programming languages,\nthe program that you write,the set of instructions that\nyou write, only has one meaning.Remember, we're coming\nback to the factthat the computer only does\nwhat you tell it to do.It's not going to\nsuddenly decideto add another variable\nfor some reason.It's just going to execute\nwhatever statements you'veput up.In programming languages,\nthere's only one meaning.But the problem that comes into\nplay in programming languagesis it's not the meaning\nthat you might haveintended, as the programmer.", "start": 1440.0, "heat": 0.1}, {"text": "That's where things\ncan go wrong.And there's going\nto be a lectureon debugging a little\nbit later in the course.But this is here\njust to tell youthat if you see an error\npop up in your program,it's just some text\nthat says, error.For example, if we do\nsomething like this,this is syntactically correct.Incorrect.Syntactically incorrect.See?There's some angry\ntext right here.What is going on?The more you program,\nthe more you'llget the hang of\nreading these errors.But this is basically\ntelling me the linethat I wrote is\nsyntactically incorrect.And it's pointing to the exact\nline and says, this is wrong,so I can go back and\nfix it as a programmer.Syntax errors are actually\nreally easily caught by Python.That was an example\nof a syntax error.Static semantic\nerrors can also becaught by Python as long as, if\nyour program has some decisionsto make, as long as you've\ngone down the branch wherethe static semantic\nerror happens.And this is probably going to\nbe the most frustrating one,especially as\nyou're starting out.The program might do\nsomething different than whatyou expected it to do.And that's not because the\nprogram suddenly-- for example,you expected the program\nto give you an output of 0for a certain test case, and\nthe output that you got was 10.Well, the program\ndidn't suddenlydecide to change\nits answer to 10.It just executed the\nprogram that you wrote.That's the case where\nthe program gave youa different answer\nthan expected.Programs might crash, which\nmeans they stop running.That's OK.Just go back to your code and\nfigure out what was wrong.", "start": 1560.0, "heat": 0.1}, {"text": "And another example\nof a different meaningthan what you intended was\nmaybe the program won't stop.It's also OK.There are ways to stop\nit besides restartingthe computer.So then Python\nprograms are goingto be sequences of\ndefinitions and commands.We're going to have expressions\nthat are going to be evaluatedand commands that tell the\ninterpreter to do something.If you've done\nproblem set 0, you'llsee that you can type\ncommands directlyin the shell here, which is\nthe part on the right whereI did some really\nsimple things, 2 plus 4.Or you can type commands up in\nhere, on the left-hand side,and then run your program.Notice that, well, we'll\ntalk about this-- Iwon't talk about this now.But these are-- on the\nright-hand side, typically,you write very simple\ncommands just if you'retesting something out.And on the left-hand\nside here in the editor,you write more lines and\nmore complicated programs.Now we're going to start\ntalking about Python.And in Python, we're going\nto come back to this,everything is an object.And Python programs\nmanipulate these data objects.All objects in Python\nare going to have a type.And the type is going to tell\nPython the kinds of operationsthat you can do\non these objects.If an object is the\nnumber five, for example,you can add the number\nto another number,subtract the number, take it\nto the power of something,and so on.As a more general example,\nfor example, I am a human.So that's my type.And I can walk, speak\nEnglish, et cetera.Chewbacca is going\nto be a type Wookie.He can walk, do that\nsound that I can't do.", "start": 1680.0, "heat": 0.1}, {"text": "He can do that, but I can't.I'm not even going\nto try, and so on.Once you have these\nPython objects,everything is an\nobject in Python.There are actually\ntwo types of objects.One are scalar objects.That means these are very basic\nobjects in Python from whicheverything can be made.These are scalar objects.That can't be subdivided.The other type of object\nis a non-scalar object.And these are objects that\nhave some internal structure.For example, the\nnumber five is a scalarobject because it\ncan't be subdivided.But a list of numbers,\nfor example, 5, 6,7,8, is going to be\na non-scalar objectbecause you can subdivide it.You can subdivide it into--\nyou can find parts to it.It's made up of a\nsequence of numbers.Here's the list of all of\nthe scalar objects in Python.We have integers, for example,\nall of the whole numbers.Floats, which are all of\nthe real numbers, anythingwith a decimal.Bools are Booleans.There's only two\nvalues to Booleans.That's True and False.Note the capitalization,\ncapital T and capital F.And this other thing\ncalled NoneType.It's special.It has only one\nvalue called None.And it represents the\nabsence of a type.And it sometimes comes in\nhandy for some programs.If you want to find\nthe type of an object,you can use this special\ncommand called type.And then in the\nparentheses, you put downwhat you want to\nfind the type of.You can write into\nthe shell \"type of 5,\"and the shell will tell\nyou, that's an integer.If you happen to want to convert\nbetween two different types,Python allows you to do that.And to do that, you\nput the type that you", "start": 1800.0, "heat": 0.1}, {"text": "want to convert to\nright before the objectthat you want to convert to.So float(3) will convert the\ninteger 3 to the float 3.0.And similarly, you can convert\nany float into an integer.And converting to an\ninteger just truncates.It just takes away the\ndecimal and whatever'safter it-- it does not round--\nand keeps just the integerpart.For this slide, I'm\ngoing to talk about it.But if you'd like if\nyou have the slides up,go to go to this exercise.And after I'm done\ntalking about the slide,we'll see what people\nthink for that exercise.One of the most\nimportant things that youcan do in basically\nany programming,in Python also, is\nto print things out.Printing out is how you\ninteract with the user.To print things out, you\nuse the print command.If you're in the shell, if\nyou simply type \"3 plus 2,\"you do see a value here.Five, right?But that's not actually\nprinting something out.And that becomes apparent\nwhen you actuallytype things into the editor.If you just do \"3 plus 2,\" and\nyou run the program-- that'sthe green button here-- you see\non the right-hand side here,it ran my program.But it didn't actually\nprint anything.If you type this\ninto the console,it does show you this\nvalue, but that'sjust like peeking into the\nvalue for you as a programmer.It's not actually\nprinting it out to anyone.If you want to\nprint something out,you have to use the print\nstatement like that.In this case, this is actually\ngoing to print this numberfive to the console.That's basically what it says.It just tells you it's an\ninteraction within the shell", "start": 1920.0, "heat": 0.1}, {"text": "only.It's not interacting\nwith anyone else.And if you don't\nhave any \"Out,\" thatmeans it got printed\nout to the console.All right.We talked a little\nbit about objects.Once you have objects, you can\ncombine objects and operatorsto form these expressions.And each expression is\ngoing to have a value.So an expression\nevaluates to a value.The syntax for an\nexpression is goingto be object, operator,\nobject, like that.And these are some operators\nyou can do on ints and floats.There's the typical ones,\naddition, subtraction,multiplication, and division.If, for the first\nthree, the answerthat you get-- the type of\nthe answer that you get--is going to depend on the\ntype of your variables.If both of the variables of\nthe operands are integers,then the result you're going\nto get is of type integer.But if at least one of\nthem is a float, thenthe result you're going\nto get is a float.Division is a little\nbit special in thatno matter what the\noperands are, the resultis always going to be a float.The other operations you can\ndo, and these are also useful,are the remainder,\nso the percent sign.If you use the percent\nsign between two operands,that's going to give you the\nremainder when you divide iby j.And raising something to\nthe power of something elseis using the star star operator.And i star stars j is going\nto take i to the power of j.These operations have\nthe typical precedencethat you might expect\nin math, for example.And if you'd like\nto put precedencetoward some other\noperations, youcan use parentheses to do that.", "start": 2040.0, "heat": 0.1}, {"text": "All right.So we have ways of\ncreating expressions.And we have operations\nwe can do on objects.But what's going to be useful\nis to be able to save valuesto some name.And the name is going to\nbe something that you pick.And it should be a\ndescriptive name.And when you save\nthe value to a name,you're going to be able\nto access that value lateron in your program.And that's very useful.To save a value to a variable\nname, you use the equal sign.And the equal sign\nis an assignment.It assigns the\nright-hand side, whichis a value, to the\nleft-hand side, whichis going to be a variable name.In this case, I assigned\nthe float 3.14159to the variable pi.And in the second\nline, I'm goingto take this expression,\n22 divided by 7,I'm going to evaluate it.It's going to come up\nwith some decimal number.And I'm going to save it\ninto the variable pi_approx.values are stored in memory.And this assignment\nin Python, wesay the assignment binds\nthe name to the value.When you use that name\nlater on in your program,you're going to be referring\nto the value in memory.And if you ever want\nto refer to the valuelater on in your code,\nyou just simply typethe name of the variable\nthat you've assigned it to.So why do we want to give\nnames to expressions?Well, you want to reuse the\nnames instead of the values.And it makes your\ncode look a lot nicer.This is a piece of\ncode that calculatesthe area of a circle.And notice, I've assigned\na variable pi to 3.14159.", "start": 2160.0, "heat": 0.1}, {"text": "I've assigned another variable\ncalled radius to be 2.2.And then, later on in my\ncode, I have another linethat says area-- this\nis another variable-- isequal to-- this\nis an assignment--to this expression.And this expression is referring\nto these variable names, piand radius.And it's going look up\ntheir values in memory.And it's going to replace\nthese variable nameswith those values.And it's going to do\nthe calculation for me.And in the end, this\nwhole expressionis going to be\nreplaced by one number.And it's going to be the float.Here's another exercise, while\nI'm talking about the slide.I do want to make a note\nabout programming versus math.In math, you're often\npresented with a problemthat says, solve for x.x plus y is equal to\nsomething something.Solve for x, for example.That's coming back to the\nfact that computers don'tknow what to do with that.Computers need to\nbe told what to do.In programming, if you\nwant to solve for x,you need to tell the computer\nexactly how to solve for x.You need to figure\nout what formulayou need to give the\ncomputer in order to beable to solve for x.That means always in programming\nthe right-hand side isgoing to be an expression.It's something that's going\nto be evaluated to a value.And the left-hand side\nis always a variable.It's going to be an assignment.The equal sign is\nnot like in mathwhere you can have a lot\nof things to the leftand a lot of things to the\nright of the equal sign.There's only one thing to\nthe left of the equal sign.And that's going\nto be a variable.An equal sign stands\nfor an assignment.Once we've created expressions,\nand we have these assignments,you can rebind variable\nnames using new assignmentstatements.", "start": 2280.0, "heat": 0.1}, {"text": "Let's look at an\nexample for that.Let's say this is our memory.Let's type back in the example\nwith finding the radius.Let's say, pi is equal to 3.14.In memory, we're going to\ncreate this value 3.14.We're going to bind it\nto the variable named pi.Next line, radius\nis equal to 2.2.In memory, we're\ncreating this value 2.2.And we're going to bind it\nto the variable named radius.Then we have this\nexpression here.It's going to substitute\nthe values for pifrom memory and the value\nfor radius from memory.It's going to calculate the\nvalue that this expressionevaluates to.It's going to pop\nthat into the memory.And it's going to\nassign-- because we'reusing the equal\nsign-- it's goingto assign that value\nto that variable area.Now, let's say we rebind\nradius to be something else.Radius i is bound\nto the value 2.2.But when we do this line, radius\nis equal to radius plus 1,we're going to take\naway the binding to 2.2.We're going to do\nthis calculation.The new value is 3.2.And we're going to rebind that\nvalue to that same variable.In memory, notice\nwe're still goingto have this value,\n2.2, floating around.But we've lost\nthe handle for it.There's no way to get it back.It's just in memory\nsitting there.At some point, it might\nget collected by whatwe call the garbage collector.In Python, And it'll\nretrieve these lost values,", "start": 2400.0, "heat": 0.1}, {"text": "and it'll reuse them for new\nvalues, and things like that.But radius now points\nto the new value.We can never get back 2.2.And that's it.The value of area-- notice,\nthis is very important.The value of area\ndid not change.And it did not change because\nthese are all the instructionswe told the computer to do.We just told it to change\nradius to be radius plus 1.We never told it to\nrecalculate the value of area.If I copied that line down\nhere, then the value of areawould change.But we never told it to do that.The computer only does\nwhat we tell it to do.That's the last thing.Next lecture, we're going\nto talk about adding controlflow to our programs, so\nhow do you tell the computerto do one thing or another?All right.", "start": 2520.0, "heat": 0.1}]