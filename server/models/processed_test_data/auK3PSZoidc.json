[{"text": "SRINI DEVADAS: All right\ngood morning, everyone.Welcome back.I hope you had a\ngood long weekend.So today's puzzle is, I\nguess, a classic puzzle.It's Sudoku.I've never actually\nsuccessfully managedto complete a Sudoku\npuzzle by myself,because they've fallen\ninto two categories for me.Either they're easy, and\nI get bored and I stop.Or they're too hard, and\nI get lazy and I stop.But what I have done is\nwrite a computer programthat essentially solves\nany Sudoku puzzle that isput in front of it in seconds.Maybe there exist puzzles for\nwhich it would take minutes,but I haven't\ndiscovered such puzzles.And what we're going to do\ntoday is talk about Sudoku,compare and contrast the human\nway of solving Sudoku puzzlesagainst a brute force way,\nand then try and integratethe two together.You know perhaps\nthis is the closestwe're going to get\nto AI in this class,where we're going to try and\nmarry an exhaustive searchmethod with some smarts.And back-- I think when we were\ndoing the N-queens puzzle--one of you asked a\nquestion about whatthe number of\npossibilities were.For an eight queens puzzle,\nwas it eight raised to eight?And I said, well no.You can prune the\nsearch by figuring outthat particular partial\nconfigurations that correspondto perhaps two queens\nbeing placed on the eightby eight board already does\nnot correspond to a solution,because the two queens\nconflict with each other.And you can then\nshrink this eight", "start": 0.0, "heat": 0.1}, {"text": "raised to eight substantially.So that's exactly\nthe methodologythat we're going to\nfollow here in tryingto take our brute\nforce solver, whichwill work, given enough time,\non arbitrary Sudoku puzzles.But we may not want\nto wait that long.And we're going to take this\nstrategy of pruning the searchto try and improve the solver.And one last thing before I get\nstarted on the rules of Sudoku,we're going to have to have a\nway of measuring performance.Just like we can measure eight\nraised to eight or four raisedto four or what\nhave you, we wantto have a way of measuring--outside of the\nparticular machinethat's being used,\nwe can obviouslymeasure real time\nin terms of seconds,but that's not as precise--you want to measure\nmore precisely whatthe number of combinations are.And so we could certainly\ninstrument our codewith appropriate\ncounters that will allowus to measure this performance.And so then it won't matter if\nour code runs on a fast machineor a slow machine.We can compare it with\nanother piece of codeor another variant of the code\nand say, oh this new variantis slower or the new\nvariant is fasteraccording to this metric.All right?So without further ado,\nlet's dive into Sudoku.How many of you have never seen\nSudoku, never played Sudoku?All right, so that's fine.It's only going to take\nme about 30 secondsto explain what the\nrules of Sudoku are.And then we can dive into trying\nto, at least partially, solvethis puzzle.I do not want to\ncompletely solve the puzzlebecause, as I said, it's either\ntoo simple or it's too hard.And I'd rather write\ncomputer programs.And so the rules of\nSudoku are simple.So this is classic Sudoku,\nand it's a nine by nine.", "start": 120.0, "heat": 0.1}, {"text": "There's many variants of Sudoku.In fact, a couple\nof the exercisestalk about two variants,\ndiagonal Sudoku and evenSudoku, I think--there's probably odd\nSudokus as well--that add even more constraints\nto the basic constraintsof Sudoku that I'm\ngoing to write up here.And this is nine by nine Sudoku.And the numbers are\none through nine.And the rules are simple.Each row has all\nthe numbers, whichmeans that no numbers could\nbe repeated, because there'snine columns and nine rows.So there's nine\nnumbers on each row.Each column has\nall the numbers--same thing.So there's nine rows\nand nine columns.And then each sector, which\nis a three by three grid--and so that's why I have these\noverhangs here correspondingto pointing out what the\nnine sectors are in Sudoku.So this is a sector.That's a sector.This middle one, which\nis completely blankright now is a\nsector, et cetera.So each sector has\nall the numbers.You can grow the\nsize of the puzzle.It gets more difficult. You\ncould add more constraints.As I mentioned, diagonal\nSudoku might say somethinglike both of the diagonals, the\nlarge diagonals, the full sizediagonals, have all nine\nnumbers on them, et cetera.So that makes the\npuzzle different.", "start": 240.0, "heat": 0.1}, {"text": "You may have a\nsolution to the nineby nine original Sudoku\npuzzle, but it may notbe a solution to\nthe diagonal puzzle.Obviously the other\nway around worksbecause the diagonal puzzle\nonly has more constraints.And so what we do here is\ntry and use implications.Right, so we have these rules.And we'll first forget\nabout computer programsand try and solve this the\nway people do when they justhave a paper and\npencil and they havethe puzzle in front of them.And they try and use these rules\nto discover empty positions.And it's kind of hard to do\nanything with this sector here.You could use the row and\ncolumn constraints, obviously,even for this sector.Because you have constraints on\nthese three based on the factthat you have nine and seven\nand one and six on this row,et cetera.But usually you go\nwith sectors thathave a few numbers in them.You go with rows that have\na few numbers in them.And you go with columns that\nhave a few numbers in them.And then you can try and\nshrink the possibilities.All right?So just because I don't\nwant to go overboardwith respect to looking\nall over the puzzle,let's focus in on eight--the number eight.And one of you tell me\nif I can imply somethingbased on the locations\nof eight on the top thirdof this puzzle.Yeah, go ahead.AUDIENCE: Top middle square.SRINI DEVADAS: Top middle\nsquare, what's your name?Kye?So Kye says top middle square\nshould be an eight, right here.Right, and-- oh, top OK.Yeah that clearly\ncan't be an eight,because this is an eight here.But good, so the claim\nis this is an eight.", "start": 360.0, "heat": 0.1}, {"text": "And Kye, how did\nyou figure that out?AUDIENCE: You can eliminate\nthe first two rows because.SRINI DEVADAS: Right\nyou can eliminate this,because eight can't be\nhere because of this eight.Eight can't be here\nbecause of this eight.You need to have an 8 in\nhere somewhere, because eightdoesn't exist in the sector.So that would imply that I\nneed to put an eight up here.OK?So this is what's called\na horizontal scan.The only thing that Kye did\nhere was scan horizontally.And you can imagine that--so Kye did not use, in\norder to imply the eight--and so this word implication,\nimply, is somethingthat we're going to use\nin a more technical senseas well when we write our code,\nbut an implication essentiallysays these rules imply\nthe location of the eight.Right?And we didn't do\na vertical scan.We did not use the fact that--in this particular\nimplication, we did notuse the fact that a column\nneeds to have all numbers on it,and therefore all of the numbers\non a column have to be unique.Take a look at--take a look at this part here.And let's look at one.And try and use a more\nsophisticated formof implication corresponding\nto both horizontaland vertical scans to imply\nthe position of a one somewhereon the puzzle.Can someone do that?Yeah, back there.AUDIENCE: In the top box--\nin the top right box,it's to the right of six.SRINI DEVADAS: OK, so\nthe one can't be here.The one can't be here.Right?And the one can't be here.So it has to be over here.What's your name?AUDIENCE: George.SRINI DEVADAS:\nGeorge-- so Georgesays the one has to be here.And he used both vertical\nscanning as well ashorizontal scanning in\norder to imply the one.", "start": 480.0, "heat": 0.1}, {"text": "So it's a little\nmore sophisticated.OK, on top of that,\nobviously, sectorsare going to give you\nsome implications as well.And there's no end\nto this, honestly.There's combinations, there's\nalso a little bit of lookahead, where the hardest puzzles\nare the ones where you run outof the eights and the ones\nin terms of the examplesthat we have here where\nwe've just sort of implied--without guessing, we've implied\nthe location of a number.And then because of that, our\npuzzle got smaller in the sensethat there's fewer blank\nlocations, blank squares.And then that helps\nus move forward.So the easy puzzles\nare the ones wherefairly straightforward\nimplicationslike the ones we did here\nalways exist, are easy to find.Sometimes you have to search\na little bit, look at the top,look at the bottom,\nlook at the middle.And then you fill things in.And because you\nfilled things in,something else now\nis in play, right?It becomes viable in\nterms of an implication.The fact that I put\nan eight in thereimplies that the\neight is now taken--its location.And so now obviously\nthere's only four left here.And the fact that\nthere's an eight hereimplies that all of these\ncan't have an eight in them.These seven locations\nunderneath can'thave an eight in them, right,\nbecause of the constraints.So this shrinking\nof possibilitiesis something that a human does.And you can kind of go\nthrough this process.It's an iterative process\nthat you go through.And if you get stuck then\nyou can't do an implicationthat gives you a number.And some of the harder\npuzzles you have to-- youhave a couple of choices,\nand only one of them", "start": 600.0, "heat": 0.1}, {"text": "is going to be a correct\none going forward,but you don't know\nthat at that moment.So you now have to guess.And perhaps you put\nan eight over hereor an eight over there.And then you say I'm going to\ngo with an eight over here.And then you go a\nlittle bit further,and then you realize,\nwait a minute,there's no way I can\nsolve this puzzle.Because I need to put two\nsevens into this sector.And then you go back and\nthere's actually a bitof backtracking that happens--a wrong guess, and you\nneed to go backwards.And it's very hard to do for us.It's very hard to do for\nus with pencil and paper,keeping things in our head,\nor you know writing down noteson the side of the paper.Whereas it's very easy to do\nthat for a computer program.And we kind of did that\nalready in the eight queens.But we're going to do\nthat in a much moresystematic way over here.So you kind of\nweigh these two waysof approaching this problem.One of which is I'm\njust going to blastthrough the different\ncombinations,having a giant tree\nstructure in my head ofwhere, you know this might imply\nthat particular grid locationgrid IJ equals eight.This might imply that\ngrid IJ equals seven.And there's obviously\na huge numberof combinations corresponding\nto which of these squaresthat I pick and what value\nI assign to those squares.And then once I do that\nthere's another set.And this explodes\non you very quickly.And so if you just did this\nin a completely brutish way,there's no way your\nprogram would everend, even on a simple puzzle.But thanks to these rules,\nit turns out a fairlystraightforward program that's\n20 lines of code is goingto solve most problems-- at\nleast the ones that I've lookedat--in a reasonable amount of time.And then it's just interesting\nfrom an algorithmic standpointand an efficiency\nstandpoint to look and seehow we can take that\nfairly naive approach which", "start": 720.0, "heat": 0.1}, {"text": "does have some pruning but it's\nexhaustive and improve that.All right, so that's kind\nof where we are headed.Make sense?Any questions about\nwhat we have so far?All right.So what we're going to\ndo is go ahead and lookat code for Sudoku that--so all you need to think about\nnow for the next few minutes,because we're going to move into\nexhaustive search mode and codethings up in a computer,\nis just those rules.So you don't have\nto really thinkabout horizontal scans and\nimplications or vertical scans.That's going to come\na little bit later.And we're going to\nvary that up as well.But we're going to do kind of\nwhat we did for the N-queensproblem, which is set up\na recursive search thatis going to explore all of\nthese different possibilities.And the equivalent of no\nconflicts for the eight queensor the N-queens problem, which\nsaid there's no conflicts herebecause none of the queens\nattack each other, we're goingto have something that\nessentially says this is validso far, none of\nthe rules of Sudokucorresponding to\nthese three rulesthat I have up on the board\nare going to be violated.All right so let's take a look.And so this structure hopefully,\ngiven that we've done N-queens,should be a little bit\neasier to understand.So when we did eight\nqueens or N-queens,we decided to start\ncolumn by column.And we could have\ndone row by row,but we decided to\nstart column by column.And it was a fairly\nstraightforward puzzle.There's obviously no real change\nin an eight queens puzzle.I mean, you're solving\nthe same puzzle as I am.But if I give you\na Sudoku puzzle,there's more variety\nto it in the sense that", "start": 840.0, "heat": 0.1}, {"text": "depending on what I fill up--the hard puzzles\nare the ones thatare kind of intermediate in the\nsense of they're not obviouslyfully filled and\nthey're not empty.Right if it's\ncompletely empty thenit's trivial to solve\na Sudoku puzzle.You can take any solution\nto a Sudoku puzzleand present it as a solution\nto the empty puzzle.And then if everything is\nfull except for two things,I mean it's kind of\nobvious what those twothings are assuming that the\npuzzle had a valid solution.So really it's puzzles\nlike this wheremaybe a third are full\nthat are more difficult.And it's kind of a separate\nschool, a little community thatdesigns puzzles and tries\nto create hard puzzles.And they try and make\nthe human's problemharder by making this\nrequirement of look ahead,like I mentioned.So good.So let's take a look\nat the code here.So what I want to do here--\nand the first part here is--as I said, we went column by\ncolumn in the case of N-queens.And the question is,\nwhere do I start.I want to do something\nin a fairly naive way.And what I'm going to do is I'm\ngoing to do some sort of scan.I'm going to scan like that.And I'm going to find--as I do the scan, I'm going\nto find the next empty gridlocation.And I'm going to say that is\ngoing to be something that I'mgoing to try and fill in.OK so it's not going to be I\ndiscovered this eight in the--it was, if you count in\nterms of the empty locations,if I went this way, it was\nthe fourth empty locationand decided to fill that up.But here I'm just--\nin this code I'mgoing to try one, two, three,\nfour, five, six, seven, eight,nine here.And the first part\nof the code here thatsays what is the name\nof this procedure.It says find next cell to fill.Which means what its name is--", "start": 960.0, "heat": 0.1}, {"text": "find the next cell.Find the next grid\nlocation to fill.And it simply goes\nfor X in range zerothrough nine, for Y in\nrange zero through nine.I'm assuming that since zero\nis not a valid entry here,I could use zero\nto signify empty.OK?It's only one through nine,\nso zero can signify empty.And this just returns\nX and Y correspondingto the first empty location.So in this case it\nwould just return (0,0).OK?And then if this were\nfull then it would go--obviously the X changes.And when X changes, you're\ngoing over to the right.And so you would\nget a (1,0) back.If this were filled,\nthe next time around I'dget this grid\nlocation, et cetera.It doesn't matter.Just like I could go\ncolumn by column or rowby row, as long as I\nhave a deterministic wayof discovering the\nempty location--and usually you want to have\nthe same way of discoveringthe empty location.But even that is\nnot a requirementas long as there's\nan empty locationand your find next cell to\nfill finds that empty locationand returns it to you, you're\ngood, and the rest of our codeis going to work.But no reason to\nget more complicatedthan what I have up there.So find next cell\nto fill makes sense?We good with that?All right.And generally with\nexhaustive searchthe key procedure is always\ndo you have a valid solutionor not?And you may not have\na complete solution.Think of it as a\npartial configuration.So this is a partial\nconfiguration that is valid.It's not a complete solution\nto the Sudoku puzzle.It's a partial configuration\nthat's valid in the sensethat it satisfies all\nof the constraints.You know, if I put\nanother eight in here", "start": 1080.0, "heat": 0.1}, {"text": "it would not be a valid\npartial configuration.It would be partial,\nbut not valid.Right?I need to grow this.I need to grow this\ninto a solution.And when I say solution I\nmean all the constraintshave to be satisfied.A configuration could\nbe invalid or valid.A solution is always valid.All right?That's just terminology.And so I want to be\nable to look high upand be able to truncate\nthe search and say,you know what, grid\nIJ equaling eight,because I put an eight in\nthat sector which alreadyhad an eight in it, is something\nthat should not be explored.And I don't have\nto worry about anyof the branches that come here.Because immediately I've\nviolated the constraint.So in general, I\ncan always checkwhether partial configurations\nviolate the threeconstraints I have or not.And that is what this\npiece of code does.And it's also straightforward.It's perhaps even\nmore straightforwardthan diagonal checking in\nthe case of eight queens.But all this does is\nuse the construct thatsays I'm going to look at--essentially this is\nsomething that islist comprehensions in Python.The for comes after\nthis predicate here.But effectively what you're\nsaying is for X in range nine,check that grid IX is\nnot equal to E. OK,and you're just looking at E.So is valid, grid IJE takes the\ngrid which looks like this one,let's say, and so it's got zeros\nin all of the empty places.And it's got a bunch of non-zero\nentries in all of the placesthat you see here.And in addition, you\nhave perhaps zero, zero,", "start": 1200.0, "heat": 0.1}, {"text": "and let's call it one.And so this is I, and this\nis J, and that is E. OK.And so let me write that\nout here, I, J, and E,where I is one--zero, I'm sorry, I is zero,\nJ is zero, and E is 1.So that would mean\nputting a one up hereand that obviously is going to\nviolate one of our constraints.But that's fine.We're going to check that.And it's essentially\ndoing incremental checkingjust like we did.So it's not checking to see\nthat all of the existing gridIJ values are\nconflicting or not.It's just saying I have an--I'm going to be writing\nsomething into this grid,into an empty location.It happens to be zero,\nzero having the value one.And I'm going to check\nwhether the introductionof a one into this square is\ngoing to cause problems or not.That's all that it's doing--incremental, just like\nwe had with eight queens.And that check is\nrelatively easy to do,because I just need to go and\nI look at the row correspondingto I, which in this\ncase is the top row.I look at the\ncolumn correspondingto J, which is the\nleftmost column,and then I look at the\nsector correspondingto zero, zero, which is\nthis top left sector.And I check to see for\neach of those three things,whether there's\na problem or not.And the first two--well actually, I have\na problem with the row.And I would also have a\nproblem with the sector.I wouldn't have a\nproblem with the column.But one of them is bad enough.And so I'm going to get a false.So row OK is going to be false.And so I'm going to\nreturn false out here.", "start": 1320.0, "heat": 0.1}, {"text": "All right, that make sense?So those are the three things.And there's really\nnot that much herebeyond taking those\nconstraints and codifying them.Right.Any questions?Yeah.Fadi.AUDIENCE: What is\nthe all thing--SRINI DEVADAS: Ah,\nthe all is essentiallya Python built in\nfunction that isgoing to essentially say that--it's going to-- it's\na conjunction thatsays I'm getting a bunch\nof Booleans that correspondto the generation of\nthis list comprehensionwhere E not equal to grid IX is\ngoing to give me true or false.And I need all of those\nthings to be true.All right?AUDIENCE: Okay, it's always\ngoing to be a Boolean thereand that depends on\nwhether all of the elementsof the list itself are--SRINI DEVADAS:\nIt's a conjunction.Yeah, that's right.So and, think of it as an and.Even if one of them is\nfalse, the and is false.In order for the and to\nbe true, then all of themneed to be true.All right?So it's just a convenient\nconstruct whichis applicable in sort of--the perfect application\nis what you see here.It's not the most\nsophisticated of applications,but it works very\nwell in this case.Now for the sector, I\ncan't actually do that.And so there's a little bit\nmore work, because I can't--this only works\nwhen-- and I couldput a list comprehension\nin here like thisand generate all the Booleans.For the sector I end up having\nto do something a little bitdifferent.I mean you could do things more\nconvoluted and use all in hereas well, but it's not worth it.OK, that make sense?Good.So here's the core routine\nthat corresponds to the search.And ignore this\nglobal variable here.I'll explain that in a minute.That's going to be our metric.", "start": 1440.0, "heat": 0.1}, {"text": "Backtracks is going to be\nour metric for computingperformance.And it's going to be\nquite interesting.It's going to produce some\ninteresting results for uswhen we run this on\nvarious different examples.But this core\nprocedure looks a lotlike the n-queens\nsearch in the sensethat you have a for loop\nand a recursive call.And in this case the\nfor loop is goingto be something that ranges\nthrough the different values,that you find a location that\nyou want to put something into,which is the next empty location\nin your current configuration.And then you need to go put\nin one through nine in there.And it's brutish.You're going to put\nin one and you'regoing to check conflicts.And then you'll put\nin two and you'regoing to check conflicts.If you put in a one and\nyou don't get a conflict,then you get to recur.And you now move\ninto something thatis another partial\nconfiguration, potentially,but obviously has\none location filledfrom the caller configuration.And then you go and\nlook for the next cell.So it's certainly\npossible that I'd go--when I put in a one here that\nfails, but if I put in a twohere, it's not going to fail.A two is not going to fail\nhere because, if I just lookat those constraints, a two OK.All right, so I'm going\nto put in a two here.And then I'm going to recur.And I'm going to go out here,\nand I'll try and put in a onehere.And a one is going to fail\nbecause of this and that.A two is going to\nfail because of that.A three-- is a\nthree going to fail?No, not immediately.So I could put in a three here.And then I recur and\ngo to the next one,and so on and so forth, right?And for each of these\nthings obviouslyI have to do a bunch\nof search underneath.", "start": 1560.0, "heat": 0.1}, {"text": "And you know thank goodness\nfor fast computers, right?Because otherwise,\nI mean God, I meancan you imagine\nthe amount of paperwe'd generate if you were doing\nthis and putting two and threeand I want a new sheet\nof paper for the four,et cetera, et cetera.I mean, we can count the\nnumber of backtracks.That's how many sheets\nof paper you'll need.OK.So what you see here, again\nignore the backtracks,I'll get to that in just\na second-- it's justa way of counting\nthe number of calls.And this thing here\nessentially saysI'm going to be returning--as long as I get through\nand find a solutionI want to return true.So if solve Sudoku\ngrid IJ is true,then I'm going return through.And then I'm going to pop\nup all the way to the top,assuming I got--I go all the way down to the\nbottom and I get to the pointwhere I have a solution\nthat returns true,which is a completely\nfull configuration thatreturns true.Right?But if not, then I need to\ngo try the other combinationsand I'm only going to\nmake that recursivecall if, obviously IJE,\ncorresponding to this,is valid.And that checks the constraints.And the only other thing\nI have to worry aboutis essentially something that\nsays reset your grid locationand make sure that\nyou're setting it backto zero after you're done.Right, and so I've just\nmade a choice here,grid IJ equals E. If I look\nat this line of code here,this is resetting the grid IJ\nequals E and saying it's empty.Because if I've\nfailed in all of theseand I haven't return true in\nall of these, then obviously Iwant to change this.And you could argue that\nthe next time around", "start": 1680.0, "heat": 0.1}, {"text": "if I and J are\nexactly the same--because I and J\nare set up here--then I'm going to overwrite\nthe E from a one to a two,et cetera, et cetera.And so that is,\nin fact, correct.But I do need to reset\nthis outside of the loop,if not inside of the loop.So it's not like I can get\naway with this line of code.In general, if you\never backtrack,you have to go back\nand undo your decision.And you have to erase the tree.And that's essentially what that\ngrid IJ equaling zero is doing.You just need to\nundo that decision.And you can do this\na few different ways.But the biggest\nthing to rememberwhen you do recursive\nsearch is to get your--the undoing of your\ndecision, whichis what we call\nbacktracking, to be correct.And if you ever leave a mess,\nthen you'd have a problem.That's also true in the case\nof the N-queens problem.So I'm going to go ahead and--and this is just\na print routine.So this is not exactly the\nSudoku that I have up there,the Sudoku puzzle\nthat I have up there,but it's kind of roughly\nsimilar in complexity.And I could go ahead and\nrun the Sudoku program.And for each of those\ndifferent Sudoku problems,it's producing solved puzzles.So this is a solved puzzle.You can check this\npuzzle just real quickand you'll find that all of\nthe constraints are satisfied.And I'm going to explain\nbacktracks in a second.So true says that\nthere's a solution.The number of\nbacktracks was 579.For the second puzzle, which\nwas a little bit harder,the number of\nbacktracks was 6363.I'm sorry, this\nis just scrolling.And for the fourth\none, it was 335,000--", "start": 1800.0, "heat": 0.1}, {"text": "I'm sorry, for the third one.And for the fourth\none, was 9949.These last two\npuzzles, hard and diff,there was a Finnish guy called--there is a Finnish guy\ncalled Arto Inkala,who designs puzzles.And he claimed that\nthis hard puzzle in 2006was the hardest puzzle\never designed in Sudoku.And then in 2010 he came up\nwith this more difficult puzzle,according to him, that\nrequired a lot of lookahead from a standpoint\nof the human being.Like if we went back to\nwhat I said you can't quitedo this implication.You have to kind\nof make a guess.And then you have to go\nfurther and further down.And I think the claim was\nthat the hard puzzle requiredlike five levels of look ahead,\nand then the difficult puzzlerequired six levels\nof look ahead.And obviously, given\nthat look ahead,this puzzle has to have an\ninitial configuration that'ssolvable.So it's not a trivial\nthing to create puzzles.But now people are\nusing computer programsand doing things\nlike we're doing hereto find difficult puzzles.And interestingly\nenough, the 2006 puzzle,at least for this\nnaive computer program,takes 335,000 backtracks--the one that was supposedly\nmade more difficultin 2010, which now takes\nabout 10,000 backtracks.So obviously there's a\ndifference between the waythis program behaves and\nhow you or I would behave,or rather you would behave if\nyou tried to solve this puzzle.So let me just\nexplain backtracks,and then I'll stop\nto see if there'sany questions about the code.So when you make\nrecursive calls and youwant to count the number of\nrecursive procedure calls--you want to do\nsomething inside eachof the recursive\nprocedures and youwant to sort of cumulatively\nor collectively keep", "start": 1920.0, "heat": 0.1}, {"text": "some information, one\nway of certainly doingit is to pass arguments.And then you have to\nreturn the argument,because when you\npass an argumentand you modify it\nit's not like thatis going to be--\nthat modification,if it's just an integer, if\nit's not a mutable variable,it's not going to be seen\nby the caller procedure.And so when you do recursion and\nyou want to do some counting,the notion of global variables\nis a convenient constructto have.And global variables\nessentially saythat there's exactly one\nmemory location associatedwith this variable.And we're going to\ngo ahead and, anytimewe are mutating this variable\nand you're modifying it,you're going to see the\neffect of that in that memorylocation.So what you have up here is,\nI set backtracks to be zero.OK and that's my\nglobal variable.The fact that I put\nbacktracks equals zerohere doesn't make this a\nglobal variable just yet.The fact that I have global\nbacktracks inside of solveSudoku now says that there's\na single copy of backtracks,and it doesn't\nmatter whether I'mat the top level of recursion or\nthe bottom level of recursion.It's just that memory location\ncorresponding to backtracks--the name backtracks, that\nis getting incremented.And this could be\n10 levels deep.It could be 40 levels deep,\ngiven that I've called things40 levels in.But it's just the\none backtracks.So as you can see,\nwhat backtracks doesis anytime you have\na valid locationand you've gone ahead and--essentially you've failed.The reason it's\nout here is solveSudoku did not return true.When solved Sudoku\nactually returns false,that's when you come out and\nyou increment backtracks.So it meant that you\nhad to do some undoing.When you set grid IJ to be\nzero, that's when you're", "start": 2040.0, "heat": 0.1}, {"text": "undoing your guess, right?So backtracks makes sense\nfrom a standpoint of Ineed to backtrack and go in\na different fork in the road.And so that's why I have\nbacktracks plus equals onewhen I'm undoing my\ndecision that I made.So this kind of\ngives you a sensefor how many wrong guesses\nthat this program did.And as you can imagine,\nthe more the numberof wrong guesses, the more\nthe computation and the longerit takes.So it is definitely a\nproxy for performance.But it's a platform\nindependent proxythat's more algorithm\nrelated as opposedto the speed of the computer.Because if this computer\nwere twice as fast,I mean I'd just see\nthings running fastereven though the algorithm\nisn't any better.Right?That make sense?So it's a very\nsimple use of global.You don't want to\nuse global variablesexcept in certain\nconstrained settings.This is a fine use\nof global variables.Cool, good.So any questions\nabout this code?So what I've done here is\nI just have the naive code.And I happen to have different\nnumbers of backtracksbecause I have different inputs.Unlike the N-queens\nproblem, whichis kind of boring in some sense,\nbecause once you've solved itthere's nothing left,\nin the case of Sudoku,I could change my input,\nmy starting point,and give you different problems.And so the reason we had many\ndifferent kinds of backtrackswas simply because--numbers of backtracks\nwas because wehad four different inputs\nto the Sudoku puzzle.All right, so are we good here?People understand this code?You're going to have\nto modify it, right?Not necessarily this code,\ndepending on the exerciseyou do, but this is\ncertainly somethingthat hopefully you feel\ncomfortable with potentiallymodifying.All right so what I'm\ngoing to do now is firstI'm going to go\nahead and show you", "start": 2160.0, "heat": 0.1}, {"text": "some code that corresponds\nto something thatis the original\ncode, except that I'mgoing to add some smarts to it.What I'm going to do is,\nat any given point of time,I'm going to try to do some\nimplications without actuallydoing any guessing.So the way I'm going to\nintegrate the human approachinto this exhaustive search\napproach at top level,is I'm going to take\nmy configuration,and before I do an\narbitrary guess,before I call find\nnext cell, or maybe Ihave a particular location\nhere that I'm eventuallygoing to guess.So I do know that.But before that, I'm\ngoing to try and seewhether the current grid values\nimply anything or not by usingthe rules in exactly the same\nway or roughly, I should say,the same way that we did right\nwhen we began the lecture.All right?So we're going to try\nand use some implicationsand maybe imply the eight\nor imply something differentassociated with\nsome other location.So this is not a\nbacktrack, in the sensethat this is going to be--I can take this to\nthe bank assumingI haven't done any guessing\nup until this point,and assuming that the\ninitial configuration thatwas given to me corresponds\nto a valid solution.But I'm actually\ngoing to do thisat different points\nin the search.So it might be that I'm just\ngoing to arbitrarily choosea two here.And so I go through and\nI'm going to take this,for argument's sake, and\nI'm going to put a two down.And then I have not the initial\npuzzle that was given to me,but something that I've\nkind of hacked in the sensethat I've stuck a two in there.And that may not\ncorrespond to the solution,because I just sort of\nput the two down there.But now given the two,\nI'm going to try and dosome implications.And I'm going to try\nand see whether there'sthings that are valid or not.The important thing is that,\nbecause I put a two down", "start": 2280.0, "heat": 0.1}, {"text": "in an arbitrary way\nwithout using implications,the two could have\nbeen incorrect.I mean that's exactly why we\nhave all of these backtracks,correct?Because I've put down\nincorrect guesses and thenI've had to backtrack.So once I put a\ntwo down and thenI fill in a bunch of\nthings with implications.You know, I may even\nput an eight up there.I may put a six out here,\net cetera, et cetera.And I go deep in and\nthen I realize, ooh,you know that two was a mistake.The two really shouldn't\nhave been in there.Now I have to clean\nup everything.I have to clean up all of the\nguesses that came after twoand all of the implications\nthat came after two.All right?That's the biggest thing\nthat I want you to take awayfrom this integration\nof implicationswith exhaustive search.It's clean up your mess,\nclean up your bad guesses.The fact that-- you say, oh but\nthe implication was somethingthat was deterministic.It was exactly\nfollowing these rules.No, no, no, no, no.It was deterministic.All of that is true.But you made a wrong guess.And therefore everything\nthat you did from then on outis in question.And if you, in fact,\nfind a contradiction,you've got to go all the way\nback and clean up everything.And then go back and erase\neverything that you had.And then go take this two and\nmaybe turn it into a threeor what have you.All right?So before I show you the code\nthat does the implications--and you can kind of\nimagine that there'smany ways that we\ncould do implications,we did that manually.I want to show you this part\nlooks exactly the same asbefore, no change.Find next cell to grid\nis exactly the same.Is valid is exactly\nthe same, right?There's a large make\nimplications procedureand an undo implications\nthat I'll get to in a second.But this part here looks\nalmost exactly the same,except that I've\nreplaced grid IJ equalsE with make implications.", "start": 2400.0, "heat": 0.1}, {"text": "And this is something\nthat not only is--what make implications is going\nto do is it's going to set--whatever I had up here, it's\ngoing to set two up here.And on top of that it's going\nto go use these things to gofill in a bunch of\ndifferent values in here.So it's one extra step.This is the integration\nthat I talked about.So the idea is that--now you can do this for\nthe original as well.But the point is, once\nyou've made a guess,you always want to check to\nsee whether that guess doescertain implications or not.Right?I mean that's the whole\npurpose of this exercise.Even humans do this in the\nvery difficult puzzles.They make a guess and then\nthey see whether there'ssome implication or not.And maybe there's\na contradictionand they have to go back and\nundo all of that damage theycaused and change the guess.But in general, when\nyou have a configurationand you add to it,\nit's possible suddenlythat there will be other things\nthat are implied by the onechange that you made to it.So grid IJ equals E\nin the original codegot replaced with this\nprocedure that we'll talk about,which I don't want to spend\na whole lot of time on,but it's essentially\nsomething in terms of details.But it's essentially\nsomething thatputs in different values\nin the different locations.And grid IJ equal zero is\nreplaced by undo implications,which is cleaning up all\nof the incorrect guessesand incorrect implications.And the reason the\nimplications areincorrect-- because it came\nfrom an incorrect guess.And so that's it.Undo implications is trivial.It just sets all of\nthe implications,and I'll tell you what the\ndata structure is in a second,but think of it as making\neverything zero, going backto a clean slate.I mean clean slate\nin the sense that allof the incorrect implications\nand guesses are cleaned up.", "start": 2520.0, "heat": 0.1}, {"text": "So that's all\nthere is over here.Make implications is-- you\ncan do anything you want.You can do vertical scans.You can do horizontal scans.You can-- if you go look\nat Sudoku literatureand you look at ways\nof playing Sudoku,there's books written on\nhow you can become a betterSudoku puzzle solver.And you could take that,\nand you could code that in.And you could replace\nmake implicationswith those fancy techniques\nthat are up there, right?But we've established I'm lazy.And so I only write a\ncertain amount of code,and then I get tired.And so I wrote about 20\nlines of code correspondingto a fairly straightforward\nimplication justto give you a sense of\nhow this would work.But the most important\nthing in hereis not the details\nof make implications.And I'll give you some sense\nof that before we're done.But it's really the structure\nthat is the most important.The fact that I've done make\nimplications here and undoimplications here is the\ncorrectness requirementthat is important to\nexhaustive search.So if I do this and I do\nkind of the implicationsthat we had right at\nthe beginning of lectureand I go ahead and run\nit, just take a look.I won't write this\nout, but rememberwhat the backtracks are for\nthese things, roughly speaking,for the original Sudoku.Oh, I'm sorry, I need\nto go to the shell.And it was 335,000--what is it-- 579, 6363,\n335,000, and 9949.So if I go off and I\nrun Sudoku optimized,which is doing these\nimplications like I describe,and I go ahead and run that.The first one goes from\n579 to 33 backtracks.OK so that's pretty good.Because it's done a\nbunch of implications.It's still-- it's\nnot super smart.I mean that is a simple enough\npuzzle that a human being would", "start": 2640.0, "heat": 0.1}, {"text": "not backtrack.I mean a human being would not\nbacktrack in that first puzzle,right?And you should check that.And-- oh, this thing\nfinished in the middle.So it went to 33.Oh, only had three of them?What do I have\nhere in Sudoku Opt?Oh I see.I only ran-- oh wow.OK so I ran inp2,\nhard, and difficult.So it really went\nfrom 6363 to 33.It went from 335,000 to 24,000.And then it went to--7-- went from 9949 to 726.The details aren't-- the\nnumbers aren't super important.Don't hang your hat on them.Obviously if I change the\ncode those numbers change.But you can see that there\nare substantial gainsto be had in terms\nof implicationsnot making these dumb guesses\nthat clearly are incorrect.And you can fill\nin-- if you take awaysome of these\nempty squares, thenthe depth of the recursion\nthat you have to go throughbecomes substantially smaller.And that's why your\nbacktracking is simpler.So I want to leave you\nwith a couple of things.I want to give you some sense\nfor what particular implicationthat--a strategy that we used.And so I'll just put up make\nimplications and give yousome sense for how this works.So the basic idea is\nthat what I'm doing hereis I'm looking at a\nparticular sector.And I've created a data\nstructure that says the missingelements here-- if I\nput a two in here--let's just say I go ahead\nand put a two in here.The missing elements here are--the set is three, four,\nfive, six, seven, and nine.", "start": 2760.0, "heat": 0.1}, {"text": "So this could be three, four,\nfive, six, seven, eight, nine.This could be three, four,\nfive, six, seven, eight, nine.This is quite dumb right now.But each of these\ndifferent squarescould be three, four, five,\nsix, seven, eight, nine.OK?Possibly, all right.And then I say-- so that's\nthe first part of the code.And then I say I'm going\nto attach, essentially,a copy of the set to each\nof the missing squares.And then I'm going to go through\nand find the missing elements.So this thing here can't be a\nnine because I see a nine here.It can't be a three, right?And so I can take\nthis thing here.And I take away the nine.And I take away the three.And I can do the\nsame thing with that.Obviously I can\nalso take away the--the eight isn't there, but\nI could take away the seven,and I could away the three,\nthe six, and the one.So I go ahead and I\ntake away the six.And the three was\nalready taken out.And I keep doing this.And I try and shrink the\npossibilities correspondingto this particular\nsquare that has the setof different possibilities.And if I ever--so when can I make\nan implication?What is the condition\nthat is goingto let me make an implication\nwhen I take this set of numbersand I start shrinking them down\nusing these rules that I haveover on the right\nhand side there?What is an implication?What does that correspond\nto in relation to the size--in relation to the set?Right, yeah, behind you, Ryan.AUDIENCE: So if you\nonly have one element.SRINI DEVADAS:\nThat's exactly right.If you have one\nelement in the set,then that's an implication.If I have two\nelements in the set,it's not an implication,\nbecause I don't quiteknow what to do there.But if I had one element in\nthe set, that's an implication.And that's it.That's-- you know this\ncode is not complicated.Check if the vset is\na singleton, whichis a single element.And I'm going to\ngo ahead and appendto this implication, which is\na very straightforward datastructure that says this\nis the grid location I,", "start": 2880.0, "heat": 0.1}, {"text": "grid location J, and this is the\nvalue that was implied by that.So not only do I have IJE,\nwhich is the original guessthat I have, I also have kind\nof a bunch of other tuplescorresponding to\ndifferent coordinates,you know, KL coordinates\nand the value, call it V,associated with that.And these are all the\ndifferent implicationsthat I can collect\ntogether in this list.And I can just add those\nthings into make implications.And then I keep going.And then if I ever realize\nI've made a bad guess,I have to undo everything by\nzeroing them all out, whichis making them all empty.So one thing that\nthis code does,and you can take a look at it.And I would encourage you to\ndo the first exercise, whichis taking these implications\nand making them a little morepowerful by adding three or\nfour lines of code to this code.And exactly what you have\nto do in this exercise,and I'll show you what\nthe results shouldbe in just a minute.But let me just spend 30\nseconds explaining to youhow you could do a\nlittle bit betterthan what this code does.So what I've described to\nyou really is get this set,imply, get a\nsingleton, et cetera.And then you can\ndo this, obviously,for each of these sectors.And that's what this does.You had a for loop\nup there that does itfor each of the sectors.Grab a sector and\ngo ahead and doan implication for that sector.Now this code just runs\nthrough the sectors,you know, One, two, three, four,\nfive, six, seven, eight, nineand then discovers\nthe implicationsif they exist, adds\nthem to the imply list,and then throws up its hands\nand says I'm tired, I'm done,I don't want to do any more.What could you do that's\nan improvement, givenwhat we have described and\nwhat I've told you so far.What is an incremental\nimprovementover going over\nthese sectors onceand doing these implications\nand storing them and moving on?What is an incremental\nimprovement?", "start": 3000.0, "heat": 0.1}, {"text": "Ganatra?AUDIENCE: Look, once we\nget all the singletons,we can set those as-- since\nthose are determined, like,deterministic, I think\nthat we could set thoseinto the original grid and\nsay that's our new base gridand run through it again.SRINI DEVADAS: Run\nthrough it again, exactly.You don't have to stop.There's no reason to\nstop if you're implying.Once you've put\nsomething in hereand you've gone through one,\ntwo, three, four, five, six,seven, eight, nine,\ngot the implications,you can put them into the grid\nand then start over again.One, two, three, four,\nthat's what humans do.Right?When humans put something\nin, then they don't stop.They just keep going\nuntil they get to the end.Now of course all of\nthese implicationscould be incorrect if that\nfirst guess was incorrect.There's no change there.But there's nothing\nthat's stopping youfrom turning this little thing--\nthere's a loop here that simplycorresponds to making a\npass over the sectors,but you can put this\nwhole thing into a loop.And you keep going\nthrough the loopuntil you basically\nhave no change thathappens in your grid.OK so that's four lines of code.And I'm not going to show you\nwhat those four lines of codelook like, so close\nyour eyes in case you--And this is the\nsolution to that code.And I'm going to go\nahead and run it.And you saw what those\nnumbers were with respectto the backtracks.But if you do those\nextra implications,the 33 went down to\ntwo for that example.So this is not optimal,\nbecause I wanted one.So if I wanted to be\na human being thattook this easy puzzle\nand just sort of wentall the way without making\nany incorrect guesses,I would be doing implications.And that would go all the way.And I got close with two.And I didn't print out\nthe intermediate ones,but the 24,000 went\ndown to 11,000.And I forget what\nthe last one was.It went down.So with four lines of code\nand with the optimized codethat I'll put up you should\nbe able to get those numbersin your first exercise.", "start": 3120.0, "heat": 0.1}, {"text": "Or you could solve diagonal\nSudoku or even Sudoku.Or you could spend the\nrest of the day codingwhatever you want, whatever.All right, see you next time.", "start": 3240.0, "heat": 0.1}]