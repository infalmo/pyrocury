[{"text": "The following content is\nprovided under a CreativeCommons license.Your support will help\nMIT OpenCourseWarecontinue to offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.ANA BELL: All right\neveryone, let's get started.So good afternoon.So this is the 3rd\nlecture of 6.0001 and 600.As always, please\ndownload slides and codeto follow along.So a quick recap of\nwhat we did last time.Last time, we talked about\nstrings as a new object type,as sequences of characters.And then we introduced\ntwo new conceptsthat allowed us to\nwrite slightly morecomplicated programs.So we introduced branching, with\nthese keywords, if, elif, else.And branching allowed\nus to write programsthat, us, as programmers,\ncould introduce decisionsinto our programs.And then we introduced two\ndifferent kinds of loops,while loops and for loops.And those also added a\nlittle bit of complexityto our programs.Today, we're going to talk a\nlittle bit more about strings.So we're going to see a\ncouple of more operationsthat you can do on strings\nand string objects.And then we're going\nto talk about threedifferent algorithms,\na guess and checkalgorithm, an\napproximate solutionalgorithm, and a bisection\nmethod algorithm.So let's dive right in.We'll talk a little bit\nabout strings, first.So strings, we thought of them\nas sequences of characters,case sensitive, as we saw in\nprograms we wrote last lecture.And strings are objects.And we can do all of these\noperations on string objects,like test if they're equal, less\nthan, greater than, and so on.", "start": 0.0, "heat": 0.1}, {"text": "It turns out, we can do more\nthan just concatenate twostrings together or do\nthese little tests on them.So we're going to start\nintroducing the ideaof a function or a procedure.And we're going to see\nmore about functionsand how you can write your\nown functions next lecture.But for today, you can\nthink of a functionas sort of a procedure that\ndoes something for you.Someone already wrote this.So the first one\nwe're going to look atis a pretty popular function.And when applied on a string,\nthis function, called len,will tell you the\nlength of a string.So that's going to tell\nyou how many charactersare in the string.And characters are going\nto be letters, digits,special characters,\nspaces, and so on.So it's just going to\ncount how many charactersare in a string.So if I have the string\ns is equal to \"abc\"--remember a string is in\nquotation marks-- then,if I do this, if I write\nthis expression, len s, here,since it's an expression,\nit has a value.So it evaluates to\na certain value.And by definition, it's\ngoing to tell me whatthe length of the string,\nwhich is 3 characters long.Another thing that\nwe can do on stringsis, since they're a\nsequence of characters,I might want to get\nwhat character isat a certain position.So we do this using this\nfancy word called indexing.But pretty much what\nindexing into a string meansis you're going\nto tell Python, Iwant to know the character,\nat this certain positionor at this certain\nindex, inside my sting.So once again, let's use this\nstring, s is equal to \"abc.\"And let's index into it.So in computer science, we start\nfrom 0, counting by convention.Notice, we had a problem\nset 0 in this class.Python is no different.So in Python, you start\nindexing at position 0.", "start": 120.0, "heat": 0.1}, {"text": "Or you start indexing at 0.So the first character, in your\nstring, we say is at position 0or at index 0.The next character in\nthe string is at index 1.And the next character in\nthe string is at index 2.In Python, it turns\nout, you can alsouse negative numbers to index.And if you index into the string\nwith negative 1, for example,that means that you want the\nlast character in the string.So the last character\nin your stringis always going to be\nat position negative 1,the second-to-last\ncharacter is at negative 2,third-to-last character\nis at negative 3,and so on and so on.So the way you\nindex into a stringis with these square\nbrackets, here.And this is the notation.So if I want the character\nat position 0 or at index 0,I say s, which is the\nstring I want to index into.And then, inside\nthe square brackets,I say what index I want.So s at index 0 is going to\nbe the value \"a.\" s at index 1is going to be the value\n\"b,\" and so on and so on.And we can also do\nnegative indexing, as well.I added this in here.If you do try to\nindex into a stringbeyond the limits\nof the string--and we can even\ntry this out, justto show you that it's not the\nend of the world if we do that.If we have s is equal to \"abc,\"\nand we have s at position 20,for example,\nobviously, my stringis only length 3, so\nwhat's at position 20?I get an error.I call this angry\ntext, here, in Python.But really, the most\nrelevant thing to noteis these last couple\nof lines here.This tells you what\nline is problematic.", "start": 240.0, "heat": 0.0}, {"text": "So s at position\n20 has an issue.And this last line here tells\nme what actual error I have.So it's an index\nerror, which meansI'm trying to index too\nfar into the string,because it only has\nthree characters.So it's nice to be able to\nget a single character outof my string.But sometimes, I might\nwant to get a substring.So I want to start at\nthe first characterand go halfway into\nthe string, or Iwant to take a few\ncharacters in between,or I want to skip every other\nletter or something like thatin my string.So if I want to do this slightly\nmore complicated interactionwith strings, we call that\nslicing, slicing into a string.And this notation here should\nseem a little bit familiar,because we saw it last lecture\nwhen we did it with range.We had a start,\nstop, and a step.The notation was a\nlittle bit different,because, in range, we had\nopen-close parenthesesand commas in between.But except for that, this\nsort of works the same.The start is the\nindex, starting from 0,from where you want to\nslice into this string.The stop is the stop index.So you're going to go\nup until stop minus 1and take that index.And then the step is how many\nletters you wish to take.So this is the\nfull notation here.But sometimes, you\ncan not give ita third sort of number in here.So if you only give\nit two numbers,then, to Python, that represents\njust the start and the stop.And by default, step\nis going to be 1.And there's a lot of other\nthings you can do with strings.You can omit numbers and\njust leave colons in Python.", "start": 360.0, "heat": 0.0}, {"text": "By definition, the way\nthat whoever wrote slicinghad decided, if\nyou omit numbers,then it's going to be\nequivalent to these things here.So we slice using square\nbrackets, just like indexing.Except now, we can\ngive it two numbers.So with this string, s, if\nwe slice into the string s,we start from index 3\nand go up until index 6.So if we have abcdefgh, this is\nposition 0, 1, 2, 3, 4, 5, 6,7.And you just count.So s, starting from 3 and going\ntill 6, is going to start here,3.So it's going to come\nup with-- sorry d.And then we're going to take e.And then we're going to take f.And since we're going\nuntil stop minus 1,we're not going to take g.Because this is position 6, and\nwe're going until 6 minus 1.The next one here, 3, 6, 2\nis going every other one.So we start at 3, and then\nwe skip every other one,so we go d but not e, and\nthen f, and then stop.If you do s and then nothing\ninside except colons,notice that you're going\nto have s, and thennothing, and then colon,\nnothing, colon, nothing.So nothing for start, nothing\nfor stop, nothing for step.And that's just going to value\nit to the string, itself.It's the same as 0 to the\nlength s going every step.", "start": 480.0, "heat": 0.0}, {"text": "This one might\nactually be useful.It reverses the string\nautomatically for you.So with this one\nlittle line here,you can get the\ninverse of your string.And that's equivalent to that.So the minus 1 represents\nstarting from the endand going back every letter.And then this one's a little\nbit more complicated but alsonot too bad.So as we're doing\nthese string slices,again, if you're unsure\nwhat something does,just type it into Spider.And you might be surprised.You might not be.But it's a good way\nto check yourself,to make sure you're\nunderstanding what's happening.One thing I want to\nmention, and it'sgood to keep this in\nthe back of your mind.We're going to come\nback to this as westart talking about slightly\nmore complicated object types.But strings are immutable.So just keep this word\nin the back of your mindas we go through this class.And what I mean by this is\nthat an actual string object,once it's created,\ncannot be modified.This might not mean\nanything right now.But let me just draw\na little something.Let's say I have this\nstring, s is equal to hello.Remember, in the\nfirst lecture, wedrew a diagram\nsort of like this.This is my memory.I have this object \"hello.\"And this object, \"hello\" is\nbound to this variable s.So now I can access the object\n\"hello\" using this variable s.Now you might think, well, since\nI could index into a string,I might be able to just say\nsomething like, s at position 0is equal to y.And that will just change\nthe little h into a y,and I'll have a new object.Well strings are immutable,\nwhich means, in Python,you're not actually\nallowed to do this.And it gives you an error\nif you do try to do that.If you want the variable s to\npoint to the string, Y-E-L-L-O,", "start": 600.0, "heat": 0.0}, {"text": "you could just say s\nis equal to Y-E-L-L-O.Or you could do string\noperations like this.And this takes the y\nand it concatenates itto the string s,\nall of the elementsstarting from position\n1, which is e, l, l, o.So this makes Y-E-L-L-O.Now internally,\nwhat happens whenI write this line\nis Python says,OK, I'm going to break my\nbond with this original object\"hello.\"I'm going to bind\nmy string variables to the new object \"yello.\"\nand this other, old objectstill is in memory somewhere.But it's an entirely different\nobject that I've created here.Again, it might not\nmean anything right now,but just keep this in\nthe back of your mind,strings are immutable.So the next thing I\nwant to talk aboutis a little bit of\nrecap on for loops.And we're going to see how\nwe can apply for loops, veryeasily, to write very\nnice, readable code whendealing with strings.So remember that for\nloops had a loop variable.My loop variable being this var,\nhere, in this particular case.It can be anything you want.And this variable, in\nthis particular case,iterates over this sequence\nof numbers, 0, 1, 2, 3, 4.So the very first time through\nthe loop, var has a value of 0.It does the expressions\nin the loop.As soon as they're done,\nvar takes the value 1.It does all the\nexpressions in the loop.And then var takes the value\n2, and it does that allthe way up until 0, 1, 2.And the last time it goes around\nis with var is equal to 3.And remember, we said that\nwe can customize our rangein order to start\nfrom a custom valueto end at a different value\nand to skip certain numbers.", "start": 720.0, "heat": 0.0}, {"text": "So, so far, we've only\nbeen using for loopsover a sequence of numbers.But actually, for loops are a\nlot more powerful than that.You can use them to iterate\nover any sequence of valuesnot just numbers\nbut also strings.So here are two pieces of code,\nthis one and this one here.These two pieces of code\nboth do the exact same thing.To me, possibly to\nyou, this one looksa lot more readable than this\none, just at a first glance.If I were to read this one,\njust using the keywordsand variables here, it would\nsound like broken English.But you could decipher\nwhat I'm trying to say.For a char in a string s,\nif the char is equal to \"i\"or a char is equal to \"u,\"\nprint \"There is an i or a u.\"It sounds weird, but\nyou could probablytell what I was\ntrying to do here.Whereas up here,\nit's a little morecomplicated to tell\nwhat I'm doing.You have to sort of think\nabout it a little bit.For some index in\nthis range of numbers,0 through the\nlength of the strings, if s, at position index, is\nan \"i\" or s at position indexis a \"u\" print, \"There\nis an i or a u.\"Both of these codes just\ngo through the string s.And if it encounters a\nletter that's an i or a u,it's just going to print\nout this string here.But this bottom one is\na lot more pythonic.It's an actual word created\nby the Python community.And it just looks pretty, right?You can tell what this\ncode's supposed to do.Whereas this one is a little\nbit harder to decipher.", "start": 840.0, "heat": 0.0}, {"text": "So that's sort of an\nillustration of a for loopover a sequence of characters.So char is going to be\na loop variable, still.And the loop variable,\ninstead of iterating overa set of numbers, it's going\nto iterate over every characterin s, directly.And char is going\nto be a character.It's going to be a letter.So here's a more\ncomplicated example.I wrote this code a\ncouple of years ago.And it was my attempt at\ncreating robot cheerleaders ,because I needed\nsome motivation.And then I googled, last\nnight, \"robot cheerleaders,\"and was not disappointed.Created this GIF.It looks pretty cool.And it looks like they\nkind of stole my idea.But that's fine.So let's look at what this\ncode's supposed to do.I'm going to run it.I'm going to run it, and\nthen we'll go through it.All right, it prints out,\n\"I will cheer for you!Enter a word.\"You know what, I like robots,\nso I'll put in \"ROBOTS.\"How enthusiastic\nam I about robots?Let's say 6.So what this is going to\nprint is-- it's a cheerleader,right? \"Give me an r, r.\" \"Give\nme an o, o.\" \"Give me a b, b,\"and so on and so on.\"What does that spell?ROBOTS.\"And it's going to print it 6\ntimes, because I'm 6 out of 10enthusiastic about robots.So that's pretty much what\nthat code's supposed to do.And you can write it using\nwhat we've learned so far.Now let's go through\nit a little bit.And I'm going to show\nyou just how easy itis to convert this code using\na for loop over characters.Right now, what it does is\nit asks the user for input,", "start": 960.0, "heat": 0.0}, {"text": "so a word and a number.And then it does this\nthing, here, right?First, it uses a while loop.And second, it uses indexing.And what tips you off\nthat it's using indexingis it's using the square\nbracket, here, into the word.And obviously, it's\nusing a while loop.And it has to first create\na counter, initialize it.And then, down here, it's\ngoing to increment itinside the while loop.If you remember,\nthat's sort of whatwe need to do for while loops.So it's going to start at 0,\nand it's just basically goingto go through index i is\nequal to 0, 1, 2, 3 4, whichis going to go all the way to\nthe end of the word, whateverthe user typed in, in\nthis case \"ROBOTS.\"It's going to get the\ncharacter at that position.word at position i is\ngoing to be a character.This line here is just for the\ncheerleading to make sense.It's just to take\ncare of letters thatmake sense to use an, right?So give me a b, give me an b.So give me an b does\nnot make sense, right?So that's just\ntaking care of that.And I'm using this\nin keyword to checkwhether the character-- so\nthe character, r, for example,in robots-- is\ninside an letters.And an letters I've defined\nup here, which is theseare all the letters\nthat make senseto put an an before the letter.So give me an r for\nexample, here, on the right.And so if it makes sense to\nuse an before the letter,use that, and otherwise\nuse just an a.", "start": 1080.0, "heat": 0.0}, {"text": "And after I'm done, I say,\n\"What does that spell?\"And then it's just a for loop\nthat goes times many timesand prints out the word\nand the exclamation mark.So this code might have been\na little bit more intuitiveif I rewrote it or\nif I'd originallywritten it with a for loop.So this part here, the\nwhile loop and indexingand creating my\noriginal counter,we can get rid of that.And we can replace it with\nthis, for char in word.I'm originally using\nchar, so I can use charas my loop variable again.And simply, I'm just going to\niterate over the word, itself.So now, instead of\nhaving this mess here, Ihave a one-liner that says,\nfor every character in my word,do all this stuff here.So that remains the same.And then I don't even need to\nincrement a counter variable,because I'm not using\nwhile loops anymore.I'm just using a for loop.So the code becomes-- delete\nthat-- for char in word.And then delete that.And that does the\nexact same thing.And it's a lot more readable.So this was our toolbox at\nthe beginning of this course.We are two and half,\nI guess, lectures in.These are the things\nwe've added to it.We know integer,\nfloats, Booleans.We know a bit of string\nmanipulation, math operations.We added, recently, these\nconditionals and branchingto write slightly more\ninteresting programs.And now we have loops,\nfor and while loopsto add interesting and\nmore complicated programs.So with these, the second\npart of this lectureis going to be looking at\nthree different algorithms.", "start": 1200.0, "heat": 0.0}, {"text": "That's the sort of\ncomputer science partof this class, Introduction\nto Computer Scienceand Programming using Python.Don't let the word\nalgorithm scare you.They're not that complicated.You just have to sort of\nthink a little bit about them.And you'll be able to get them.So we're going to look\nat three algorithms, allin the context of solving\none problem, whichis finding the cube root.The first algorithm\nis guess and check,then we're going to look at\nan approximation algorithm,and then a bisection search.So the first is the\nguess and check method.You might have done this,\nin math, in high school.The guess and check method\nis also sometimes calledexhaustive enumeration.And you'll see why.So given a problem, let's say,\nfind the cube root of a number,let's say you can guess a\nstarting value for a solution.The guess and check\nmethod works if you'reable to check if your\nsolution is correct.So if your guess is\noriginally 0, you can say,is 0 cubed equal to the\ncube of whatever I'm tryingto find the cube root of?So if I'm trying to\nfind the cube root of 8,is 0 cubed equal to 8?No.So the solution is not correct.If it's not correct,\nguess another value.Do it systematically\nuntil you find a solutionor you've guessed all\nthe possible values,you've exhausted all\nof your search space.So here's a very simple guess\nand check code that findsthe cube root of a number.So I'm trying to find\nthe cube root of 8.So my cube is 8.I'm going to have a\nfor loop that says,I'm going to start from 0.And I'm going to go\nall the way up to--So I'm going to start from 0\nand go all the way up to 8.For every one of these\nnumbers, I'm going to say,", "start": 1320.0, "heat": 0.0}, {"text": "is my guess to the power\nof 3 equal to the cube 8?And if it is, I'm going\nto print out this message.Pretty simple, however, this\ncode is not very user friendly,right?If the user wants to\nfind the cube root of 9,they're not going to get\nany output, because we neverprint anything in\nthe case of the guessnot being a perfect cube.or the cube not\nbeing a perfect cube.So we can modify the\ncode a little bitto add two extra features.The first is we're\ngoing to be able to dealwith negative cubes,\nwhich is kind of cool.And the second is we're\ngoing to tell the user,if the cube is not\na perfect cube,hey, this cube is\nnot a perfect cube.So we're not going to\nsilently just fail,because then the user\nhas some sort of feedbackon their input.So let's step through this code.We have, first of all, a\nfor loop just like before.And we're going to go\nthrough 0 to 8 in this case.We're using the absolute\nvalue, because wemight want to find the cube\nroot of negative numbers.First thing we're doing\nis doing this check here.Instead of guessing whether\nthe guess to the power of 3is equal to the\ncube, we're goingto check if it's\ngreater or equal to,and we're going to do that\nfor the following reason.So if we're trying to\nfind the cube root of 8,for example, versus a\ncube root of 9-- this is 8and this is 9-- what is\nthis code going to do?It's going to first guess 0.0 cubed is not\ngreater or equal to 8.1 cubed is not\ngreater or equal to 8.", "start": 1440.0, "heat": 0.0}, {"text": "2 cubed is greater\nor equal to 8,so here, once we've guessed\n2, we're going to break.Because we found a\nnumber that works.And there's no need\nto keep looking.Once we've found the cubed\nroot of this number 8,there's no need to keep\nsearching the remainder, 3, 4,5, 6, 7, 8.Sort of the same idea\nwhen we're tryingto find the cube root of 9.We're going to start with 0.0 to the power of\n3 is less than 9.1 to the power of 3 is less 9.2 to the power of\n3 is less than 9.When we get to 3\nto the power of 3,that's going to\nbe greater than 9.So this code tells\nus, once we'vepicked a number that's\nbeyond the reasonable numberof our cubed root, of our cube,\nthe cubed root of our cube,then we should stop.Because, again, it doesn't\nmake sense to keep searching.Because if 3 to the power of\n3 is already greater than 9,4 to the power of 3 is also\ngoing to be greater than 9and so on.So once we break here, we\neither have guess being 2or guess being 3 depending on\nwhat cube we're trying to find.And if the guess to the power\nor 3 is not equal to the cube,then, obviously, the cube\nwas not a perfect cube.So that's this case\nhere, if we were lookingat at the cube root of 9.And otherwise, this\npart here just looksat whether we should make it\na positive or a negative cube.So if our original cube\nwas less than 0, then,obviously, the cube root\nof a negative numberis going to be a\nnegative number,and, otherwise,\nit's just our guess.So that's the guess\nand check method,", "start": 1560.0, "heat": 0.0}, {"text": "slightly more\nfeature-rich programfor guessing the cube root.But that only tells us the\ncube root of perfect cubesand doesn't really give\nus anything else, any moreinformation.So sometimes, you might\nwant to say, well,I don't care that 9\nis not a perfect cube,just give me a\nclose enough answer.So that's where approximate\nsolutions come in.So this is where we're OK with\nhaving a good enough solution.So in order to do\nthat, we're goingto start with a guess\nand then increment thatguess by some small value.Start from 0 and start\nincrementing by 0.001and just go upwards from there.And at some point, you might\nfind a good enough solution.In this program, we're going to\nkeep guessing as long as we'renot close enough.And close enough is going\nto be given by this epsilonvalue in the program.So as long as the guess cubed\nminus the cube-- so how faraway are we from\nthe actual answer--is greater than some\nepsilon, keep guessing,because the solution\nis not good enough.But once this is\nless than epsilon,then we've reached a\ngood enough solution.So two things to note with\napproximate solutions.So you can get more\naccurate answersif your step size is\nreally, really small.If you're incrementing\nby 0.0001,you're going to get a really\ngood approximate solution,but your program\nwill be a lot slower.Same sort of idea with epsilon,\nyou can change epsilon.If you change epsilon\nto be a bigger epsilon,you're sacrificing\naccuracy, but you'regoing to reach a\nsolution a lot faster.So here's the code for the\napproximate solution of a cuberoot.It might look\nintimidating, but, look,almost half this code is\njust initializing variables.So we're initializing,\nthis is the cube", "start": 1680.0, "heat": 0.0}, {"text": "we want to find\nthe cube root of.We pick an epsilon of this.We start with a guess of 0.We start with an\nincrement of 0.0001.And just for fun, let's keep\ntrack of the number of guessesthat it takes us to\nget to the answer.This is similar to the\nguess and check from before.It's not similar.Well this part is similar to\nthe guess and check from before.So we're going to take the\nguess to the power of 3minus the cube, right?So that's how far away are\nwe from the actual answer?And we're going to\nsay, if that's not goodenough-- so if\nwe're still greaterthan or equal to the\nepsilon-- then keep guessing.So we're going to be\nstuck in this loop, wherewe keep guessing\nvalues, until we'vereached a guess\nthat's good enough,so until we're\nless than epsilon.And way we keep guessing\nis just with this line,right here, which says,\nincrement my guessby increment, and increment\nbeing this really small value.That make sense?So I'm going to\nkeep incrementingmy guess by that small value.Before I go on, I'm\ngoing to run the code.And we're going to discover\na small issue with it.So with 27, we're\ngoing to run it.Perfect, it took me 300 guesses.But 2.99999 is close\nto the cube root of 27.We can find the cube\nroot of this guy here.And it took me 20,000\nguesses, but I figured outthat 200.99999, so 201,\nis close to the cuberoot of that large number.", "start": 1800.0, "heat": 0.0}, {"text": "I should have done this.This is going to be\na giveaway, you guys.Sorry.Then we're going\nto have-- let's sayI want to try cube of 10,000.So 10,000 is not a perfect cube.So we can run the code.And with 8,120,601 I had\nalready gotten an answer.But with 10,000, I'm not\ngetting an answer yet, right?So I'm thinking that there\nmight be something wrong.So I'm going to stop my code.So I just hit Control C,\nbecause I feel like I'veentered an infinite loop.And, in fact, I have.So what ended up happening\nis this problem here.So I'm going to draw something.According to the code,\nI'm going to start from 0,and I'm going to increment\nmy guesses, like that.With every little increment,\nI'm going to make a new guess.I'm going to take that\nguess to the power of 3.I'm going to subtract\nthe cube, and I'mgoing to figure out if\nI'm less than epsilon.This is the epsilon that I want\nto be in, this little bit here.So with every new\nguess, I might be,maybe-- so this is\nwhere I want to be,within this little\nboundary here.With every new guess,\nI might be here.With the next guess, over\nhere, I might be here.When I make another\nguess, I might be here.So I'm getting close to\nbeing within epsilon.But maybe with my\nnext guess, I'mgoing to hop over my epsilon and\nhave made too big of a guess.So just because of\nthe way the numberswere chosen in this example,\njust to illustrate this,using an increment of 0.01, a\nwith finding the cube of 10,000and epsilon of 0.1, it\nturns out that, as I'm", "start": 1920.0, "heat": 0.0}, {"text": "doing all these\ncalculations, I'mgoing to skip over this perfect\nsort of epsilon difference.So first, I'm going\nto be too small.And then I'm going\nto be too large.And once I've become too large\nor too far away from epsilon,the guesses I continue\nto make are justgoing to be even farther\naway from epsilon.And I'm not going\nto get to my answer.And that's why I've reached\nan infinite loop in this code.All I'm doing in\nthis code is checkingwhether my guess cube minus\ncube is less than epsilon.The only thing I\nneed to do here issort of add this\nlittle clause, here,that says, oh, by the way, also\ncheck that I'm less than cube.Because this is just like we\ndid in the very first program,when I'm checking 0,\n1, 2, 3, 4, 5, 6, 7, 8,when I'm trying to find\nthe cube root of 8.Once I've reached 8,\nI'm going to stop.And it's the same thing here.So I just added\nthis little clausethat says, well,\nwhile I'm greaterthan or equal to\nepsilon and I'm stillless than the actual\ncube, just keep searching.But once I've reached the\ncube, then stop searching.And with 10,000,\nyou can see that Ifailed to actually find-- so\nthat's what this part, here,does.It tells me I've\nfailed to find the cuberoot with those\nparticular parameters.The last thing we're going to\nlook at is bisection search.And to illustrate this, I'm\ngoing to need one volunteer.And you're going to\nplay a game with mein front of the whole class.", "start": 2040.0, "heat": 0.0}, {"text": "And there will be a prize.There go the hands.In the blue shirt, right there.Cool.So the prize is going\nto be, once again, this.I promise I don't have millions\nof these, Google glasses.I also don't work for Google.I just happened to get a couple.So the game is this.I'm going to ask you to pick\na number, a whole number,between 0 and 100.And I'm going to\ntry to guess it.And you need to\nmake it hard for me.And you need to make it so hard\nfor me that I cannot guess itwithin 10 guesses.And if you can do that, if\nI cannot guess it within 10guesses, you get this.And I'm going to draw out\nwhat I do as we go along.So do you have your number?Yes?AUDIENCE: Yeah.ANA BELL: Perfect.Let me erase that.Actually, I should've\nprobably kept that,because I'll still use it.There's the numbers, 0 to 100.Is your number 50?AUDIENCE: No.ANA BELL: 50 Was my guess.So I've made one guess.Is your number higher\nor lower than 50?AUDIENCE: Higher.ANA BELL: Higher.Is your number-- my next\nguess is going to be 75.And the reason I'm guessing 75\nis because-- what's your name?AUDIENCE: Sophie.ANA BELL: What's that?AUDIENCE: Sophie.ANA BELL: Sophie.Sophie said, 50 was too low.So I immediately know that it\ncannot be any less than 50.So I've already eliminated\nhalf of the numbers.So my next guess is 75.Is your number 75?Is your number lower or higher?AUDIENCE: Higher.ANA BELL: Since it's higher,\nI'm eliminating this half here.Is your number-- so\nbetween 75 and 100.Oh, boy, you're\nputting me on the spot.What's that?AUDIENCE: 87.ANA BELL: 87, thank you.87?AUDIENCE: No.ANA BELL: Higher or lower?", "start": 2160.0, "heat": 0.0}, {"text": "AUDIENCE: Lower.ANA BELL: Lower.So since it's lower, I'm\neliminating that half.Is your number 81?Higher or lower?AUDIENCE: Lower.ANA BELL: So she said, lower,\nso I'm eliminating that half.Is your number 78?Oh, boy, that's really hard.78, OK.Higher or lower?AUDIENCE: Lower.ANA BELL: Is your number 76?AUDIENCE: Yeah.ANA BELL: Yay.All right, perfect,\n76 was the number.So how many guesses have I made?One, two, three, four, five,\nsix-- I made six guesses.So I did get it under 10.But you know what?The game was rigged.So you get the prize anyway,\njust because I rigged the game.Here you go.Pass it down.AUDIENCE: Thank you.ANA BELL: Thank you.So notice, in bisection\nsearch, what I did was Ieliminated half the search\nspace with every guess.I said, well, she said\nit's higher or lower,so I definitely cannot be in\nthe other search space, right?If I was doing approximate\nsolution or, in this case,guess and check, I would be\nasking Sophie, is your number0, 1, 2, 3, 4, and so on?So with guess and check,\nit would have taken me76 guesses to get to the number,\nwhereas, with this bisectionsearch, that I just\ndid, it only took me 6.Isn't that cool?So that means that the\nlarger the space actuallyis, that I need to\nsearch, the better itis to use bisection search,\nthis bisection search method.So that's basically what\nI'm illustrating here.So we have our\noriginal search space.We're going to choose a\nguess halfway, eliminatehalf of the guesses.Then we're going look in\nthe remaining interval,", "start": 2280.0, "heat": 0.0}, {"text": "eliminate half the guesses,\nand so on and so on.So then this is the code\nfor bisection search.Also looks intimidating,\nbut it's not so bad.So we're initializing a\nbunch of stuff up here.The most important couple\nof things we're initializingare, first of all, this high\nand this low boundaries.So with the guessing game,\nthe low boundary was 0,and the high boundary was 100.When we're looking\nat the cube root,the low boundary\nis going to be 0,and the high boundary is\ngoing to be just my cube,because a guess to the power\nof 3 cannot be any greater thancube.And then, I'm just going\nto do the same procedurethat I did with the\nguessing game, whichis I'm going to make my\nguess, be halfway in between.So with this guessing game,\nI had to sort of choose,if there were four\nnumbers in between,should I go higher or lower?Well, when we're doing\nby bisection search,here, we don't care about that.We're just going to do\nfloating point division,because we want decimal numbers.So I have a low boundary\nand a high boundary.And I figured out\nmy halfway point.Then I have this\nwhile loop here.A while loop is similar to the\napproximation method, where,as long as I don't have a\nguest that's good enough--so this, depicted by\nthis greater or equalto epsilon-- as long as my\nguess is not good enough,I'm going to keep guessing.That's what this\nwhile loop is saying.So if the guess to the\npower of 3 minus cubeis not good enough,\nkeep guessing.And the way I keep guessing\nis this part, here,says, my guess was too low.", "start": 2400.0, "heat": 0.0}, {"text": "So if my guess was too\nlow, set the low boundaryto be the guess.Because I don't care about\nall of the other numbersthat are much lower than me.So set the low to be the guess.That's what that line is doing.And otherwise, my\nguess was too high.That's what this else is doing.So set the high to be\nthe guess, because Idon't care about numbers\nany higher than my guess.Once I have these\nnew boundaries,I make another\nguess, again, halfwayin between the new\nboundary points.So essentially, I'm\njust halving my intervalwith every single guess.And that's what the\nwhile loop is doing.And then I print out\nthe remaining part.So notice the search\nspace originally being N,we're halving it\nwith each guess.So the first guess\ndivides it by 2,the second guess divides\nit by 4, and so on.So by the time we get\nto the k-th guess,N/2k, the k-th guess, let's say\nthat's the actual answer we'reinterested in.There's only one value\nin that little interval.And that's the answer we want.So 2 to the k is\nequal to N. And thenhow many guesses did we make?k is equal to log\nbase 2 of N. So whenwe are playing the guessing\ngame of 100, my end was 100.Log base 2 of 100 is\n6.-something, I think.So in fact, I could\nhave said, if Idon't guess it\nwithin seven guesses,you would have won as well.So that's why the\ngame was rigged.So the guess,\nnotice, it convergeson the order of\nlog base N insteadof just linearly in terms of N.\nSo that's why it's so powerful.One last thing I\nwant to mention isthe code I showed only\nworks for positive cubes.And that's because\nof the following.So I have this 0 and 1.", "start": 2520.0, "heat": 0.0}, {"text": "Let's say I'm trying to\nfind the cube root of 0.5.When I first set my initial\nboundaries, my low is this one,and my high is this one.But what's the cube root of 0.5?Is it within this boundary or\nis it outside this boundary?AUDIENCE: Outside the boundary.ANA BELL: I heard, outside.It's like 0.7 something.So it's out here.So with this\nparticular code, I'mgoing to be halving my interval\nin between those numbers,but I'll never get to an answer.Because the actual cube root\nof 0.5, or numbers less than 1,is going to be\noutside that boundary.So there's a small change you\ncan make to the program, whichwill fix that.And that's in the code.I didn't put it in, but it's a\nvery small change, a small ifstatement.So that's it.All right, thank you.[APPLAUSE]", "start": 2640.0, "heat": 0.0}]