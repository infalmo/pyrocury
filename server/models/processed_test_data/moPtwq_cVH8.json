[{"text": "The following\ncontent is providedunder a Creative\nCommons license.Your support will help MIT\nOpenCourseWare continueto offer high quality\neducational resources for free.To make a donation or\nview additional materialsfrom hundreds of MIT courses,\nvisit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Today, we are going\nto do computational complexity.This is rather different\nfrom every other thingwe've seen in this class.This class is basically about\npolynomial time algorithmsand problems where we\ncan solve your problemin polynomial time.And today, it's about\nwhen you can't do that.Sometimes, we can prove\nyou can't do that.Sometimes, we're pretty\nsure you can't do that.But it's all about\nnegative resultswhen your problems\nare really complex.And there's a lot\nof fun topics, here.This is the topic of\nentire classes, like 6045.We're just going to get\na 1 hour flavor of it.So think of it as\na high level intro.But we're going to prove real\ntheorems and do real thingsand you'll get a sense\nof how all this works.So I'm going to start out with\nthree complexity classes--P, EXP, and R. How many\npeople know what P is?And it is?Polynomial time.More precisely, it's\nthe set of all problemsyou can solve in\npolynomial time.This is what the\nclass is all about.Almost every\nproblem we have seenin this class-- there's\none exception-- isin P. Does anyone\nknow the exception?It's a good puzzle for you.Not NP.What's next?EXP.How many people\nknow what EXP is?Or you can guess.Any guesses?", "start": 0.0, "heat": 0.1}, {"text": "Exponential.These are all the problems you\ncan solve in exponential time.If you want to be formal\nabout it, in this case,exponential means 2 to\nthe n to some constant.So not just 2 the n, but also\n2 to the n squared, 2 to the ncubed.Those are all\nconsidered-- exponentialand a polynomial is\nconsidered in the class EXP.Now, basically, almost every\nproblem you can dream of youcan solve in EXP.Exponential time\nis so much time.And this class has always\nbeen about taking things thatare obviously in EXP and showing\nthat they're actually in P.So if you want to\ndraw a picture,you could say, OK,\nhere's all the problemswe can solve in polynomial time.Here's all the problems we\ncan solve in exponential time.And there are problems out here.These are different classes.And we want to sort\nof bring thingsinto here as much as possible.I actually want to\ndraw this picturein a different way, which\nis as a horizontal line.So an axis.I'm going to call this\ncomputational difficulty.You could call it\ncomputational complexity,but that's a bit of\na loaded term thatactually has formal meaning.Difficulty is nice and vague.So I can draw an\nabstract picture.This is not a true\ndiagram, but it'sa very good guideline\nof what's going on.So we have-- I'm going to draw--\nI believe-- three notches.No, eventually four, so let\nme give myself some room.We have over here, the\neasy problems are P. Then,", "start": 120.0, "heat": 0.1}, {"text": "we have these problems,\nwhich are EXP.We're going to fill in\nsomething in the middle.And then this is\nsomething called R.So you've got P is\neverything, here.EXP is all the way out to\nhere, in some abstract view.The next thing is R. How\nmany people know what R is?This one, I had to look up.It's not usually given a name.No one.Teaching staff?You guys know it?These are all problems\nsolvable in finite time.R stands for finite.R stands for recursive.Recursive used to mean\nsomething completely different,back in the '30s, when people\nwere thinking about what'scomputable, what's\nnot computable.These are, basically, solvable\nproblems, computable problems.Finite time is a reasonable\nrequirement, I think,for all algorithms.And that's R. Now,\nI've drawn this arrowto keep going because there\nare problems out here.It's kind of\ndiscouraging, but thereare problems that\nare unsolvable.In fact, most problems\nare unsolvable.We're going to prove that.It's actually really\neasy to prove.Kind of depressing, but true.Let me start with some examples\nbefore we get to that proof.So I'm writing examples\nof some things we've seen.So here's an example of\na problem we've seen.Negative-weight cycle detection.I give you a graph--\na weighted graph.I want to know does it have\nany negative-weight cycles?What classes is this problem in?", "start": 240.0, "heat": 0.1}, {"text": "P. We know how to solve\nthis in polynomial time--in VE time-- using Bellman-Ford.VE time-- well, that finds\nnegative-weight cyclesreachable from s.But, I guess, if you\nadd a source thatcan reach anywhere--\nzero weight-- thenthat'll tell you\noverall that it's in P.It's also in EXP, of course.Everything in P is also in EXP.Because if you can solve\nit in polynomial time,you can solve it in\nexponential time.This is at most\nexponential time.At most polynomial.Here's a problem\nwe haven't seen.But it's pretty cool.N by n Chess.So this is the\nproblem I give you.So we're in an by n\nboard, and I give youa whole bunch of\npieces on the board,and I want to know does\nWhite win from here?I say it's White to\nmove or Black to move,and who's going to win\nform this position?This problem, can be\nsolved in exponential time.You can sort of play out\nall possible strategiesand see who wins.And it's not in P. There's\nno polynomial time algorithmto play generalized Chess.This sort of captures why\nChess-- even at eight by eightChess-- is hard-- because\nthere's no general wayto do it.So there's no special\nway to do it, probably.Computational complexity is\nall about order of growth.So we can't analyze\neight by eight Chess,but we can analyze n by n Chess.And that gives us a flavor of\nwhy 8 by 8 is so difficult.Go is also in EXP, but\nnot in P-- lots of gamesare in this category, lot's of\ncomplicated games, let's say.And so this is a first example\nof a problem that we know wecannot solve in polynomial time.Bad news.I also talked about\nTetris a little bit.Unlike the Tetris\ntraining, which we saw,this is sort of\nrealistic Tetris--", "start": 360.0, "heat": 0.1}, {"text": "all the rules of Tetris.The only catch is that I\ntell you all the pieces thatare going to come in advance.Because, otherwise,\nit's some random processand it's kind of hard to think\nabout what's the best strategy.But if I tell you\nwhat's going to come--say it's a\npseudo-random generatorand you know how it works.You know all the\npieces that will come.I want to know can I survive\nfrom a given initial board messand for a given\nsequence of pieces.This can also be solved\nin exponential time.Just try all the possibilities.We don't know whether it's\nin P. We're pretty sureit's not in P. And by the\nend of today's lecture,you'll understand why\nwe think it's not in P.But it's going to be\nsomewhere in between here.Tetris is actually right here.But I haven't defined\nwhat right here is yet.And then the next one\nis halting problem.So halting problem\nis particularly cool,as we'll see-- or interesting.It's the problem of given a\ncomputer program-- Python,whatever, it doesn't really\nmatter what language.They're all the same in\na theoretical sense--does it ever halt?Does it ever stop running,\nreturn a result, whatever?This would be really handy--\nyou're writing some code,and you've run it\nfor 5 hours, and youdon't know is that\nbecause there's a bug", "start": 480.0, "heat": 0.1}, {"text": "and you've got an infinite loop?Or is it just because\nit's really slow?So you'd like to give it\nto some program-- checkingprogram-- that says\nwill this run foreveror will it terminate.That's the halting problem.And this problem\nis not in R. Thereis no correct algorithm\nfor solving this problem.There's no way to tell,\ngiven an arbitrary program,whether it will halt.Now, in some situations--\ntake the empty program--I can tell that it halts.Or I take some special\nsimple class of programs,I can tell whether they halt or\ndetermine that they don't halt.But there's no algorithm that\nsolves it for all programs,in finite time.In infinite time,\nI can solve it.Just run it.Run the program.Given finite time, there's\nno way to solve this.And so this is a little bit\nbeyond what we can prove today.It's not that hard\nto prove, but ittakes half an hour or something.I want to get to other things.But if you take 6045,\nthey'll prove this.What I want to show you\ninstead is an easierresult-- that almost\nevery problem is not in R.I need one term, though,\nwhich is decision problems.All of these problems,\nI set it up in a waythat the answer is\nbinary-- yes or no.Is there a\nnegative-weight cycle?Yes or no?Does White win from\nthis position in Chess?Can you survive in Tetris?And does this program halt?For various reasons--\nbasically convenience--the whole field of\ncomputational complexityfocuses on decision problems.And, in fact-- so\ndecision problemsare ones where the\nanswer is yes or no.", "start": 600.0, "heat": 0.1}, {"text": "That's all.Why?Essentially because\nit doesn't matter.If you take a problem\nyou care about,you can convert it into\na decision problem.We can see examples\nof that later.Decision problems\nare basically ashard as optimization\nproblems or whatever.But let's focus on\ndecision problems.The answer is yes or no.Claim that most of\nthem are uncomputable.And we can prove\nthis pretty easilyif you know a bit of\nset theory, I guess.On the one hand, I have\nproblems I want to solve.These are decision problems.And on the other hand,\nI have algorithms,or computer programs\nto solve them.I'm going to think\nof computer programsbecause more precise\nalgorithms canbe a little bit nebulous for\nthinking about pseudocode--what's valid, what's invalid.But computer programs\nare very clear.I give you some code.You throw it into Python.Either it works or it doesn't.And it does something.Runs for a while.How can I think about the\nspace of all possible programs?Well, programs are things\nyou type into a computerin ASCII, whatever.In the end, you can think of\nit as just as a binary string.Somehow it gets\nencoded in binary.Everything is reduced to binary\nin the end, on a computer.So this is a binary string.Now, you can also think\nof a binary stringas representing a\nnumber, in binary.So you can also\nthink of a program,then, as a natural number-- some\nnumber between 0 and infinity.And an integer.So usually we represent\nthis as math bold N.That's just 0, 1, 2, 3.You can think of every\nprogram is ultimatelyreducing to an integer.It's a big integer, but, hey.It's an integer.So that's the space\nof all programs.Now, I want to think about the\nspace of all decision problems.", "start": 720.0, "heat": 0.1}, {"text": "So how can I define\na decision problem?Well, the natural way to\nthink of a decision problemis as a function that\nmaps inputs to yes or no.Function from\ninputs to yes or no.Or you can think\nof that as 1 and 0.So what's an input?Well, an input is\na binary string.So an input is a number--\na natural number.Input is a binary string, which\nwe can think of as being in N.So we've got a\nfunction from N to 0,1.So another way to represent\none of these functionsis as a table.I could just write\ndown all the answers.So I've got, well, the input\ncould be 0-- the number 0.And then, maybe it's a 0.Input could be could be 1\nand then, maybe, output is 0.Then, the input could be 2,\n3, 4, 5, 1, 0, 1, 1, whatever.So I could write the\ntable of all answers.This is another way to\nwrite down such a function.What we have, here, is an\ninfinite string of bits.Each of them could be 0 or 1.It would be a different problem.But they all exist.Any infinite string of bits\nrepresents a decision problem.They're the same thing.So a decision problem is\nan infinite string of bits.A program is a finite\nstring of bits.These are different things.One way to see that\nthey're differentis put a decimal point, here.Now, this infinite\nstring of bitsis a number-- a real\nnumber-- between 0 and 1.", "start": 840.0, "heat": 0.1}, {"text": "It's written in binary.You may not be used\nto binary point.This dot is not a decimal point.It's a binary point.But, hey.Any real number can be expressed\nby an infinite string of bitsin this way-- any real\nnumber between 0 and 1.So a decision\nproblem is basicallysomething in R, the set\nof all real numbers,whereas a program is something\nin N, the set of all integers.And the thing is, the\nnumber of real numbersis much, much bigger than\nthe number of integers.In a formal sense, we call\nthis one uncountably infinite,and this one is\ncountably infinite.I'm not going to prove\nthat here, today.You may have seen that proof.It's pretty simple.And that's bad news.That means that there\nare way more problemsthan there are\nprograms to solve them.So this means almost every\nproblem that we could conceiveof is unsolvable\nby every program.And this is pretty depressing\nthe first time I saw it.That's why we put it at\nthe end of the class.I think you get all existential.I mean the thing is\nevery program onlysolves one problem.It takes some input,\nand it's eithergoing to output yes or no.And if it's wrong on any of\nthe inputs, then it's wrong.So it's going to give an answer.Say it's a\ndeterministic algorithm.No random numbers or things.Then, there's just\nnot enough programsto go around if each program\nonly solves one problem.", "start": 960.0, "heat": 0.1}, {"text": "This is the end of the proof.Any questions about that?Kind of weird.Because yet somehow, most of\nthe problems that we think aboutare computable.I don't know why that is.But mathematically,\nmost problemsthat you could think\nof are uncomputable.Question?AUDIENCE: [INAUDIBLE].PROFESSOR: Yeah.It's something like,\nthe way that we describeproblems is usually almost\nalgorithmic, anyway.And so, usually, most problems\nwe think of are in EXP.And so they're\ndefinitely computable.There's some\nmetatheorem about howwe think about problems,\nnot just programs.So that's all I'm going to\nsay about R. So out here,we have halting problem and,\nactually, most problems.You can think of this\nas an infinite lineand then there's just\nthis small portionwhich are things you can solve.But we care about this\nportion because that'sthe interesting stuff.That's what\nalgorithms are about.Out here kind of\nnothing happens.So I want to talk about\nthis notch, which is NP.I imagine you've heard about NP.It's pretty cool, but\nalso kind of confusing.But it's actually very\nclosely related to somethingwe've seen with dynamic\nprogramming, which is guessing.So I'm going to give you\na couple of definitionsof NP-- not formal definition,\nbut high level definitions.So just like P, EXP, and R,\nit's a set of decision problems.And it's going to look very\nsimilar to P. NP does not", "start": 1080.0, "heat": 0.1}, {"text": "stand for not a polynomial.It stands for\nnondeterministic polynomial.We'll get to\nnondeterministic in a moment.The first line is the same.It's all decision problems you\ncan solve in polynomial time.That sounds like P.\nBut then, there'sthis extra line, which is\nvia a \"lucky\" algorithm.Let me tell you--\nat a high level whata lucky algorithm does\nis it can make guesses.But unlike the way that\nwe've been making guesseswith dynamic programming--\nwith dynamic programmingwe had to guess something.We tried all the possibilities.A lucky algorithm just\nneeds to try one possibilitybecause it's really lucky.It always guesses\nthe right choice.It's like magic.This is not a realistic\nmodel of computation,but it is a model of computation\ncalled nondeterministic model.And it's going to sound\ncrazy because it is crazy,but nonetheless it's\nactually really useful--even though you could\nnever really buildthis on a real computer.The nondeterministic\nmodel is nota model of real computation.It is a model of theoretical\nhypothetical computation.It gets at the\nroot-- at the coreof what is possible to solve.You'll see why, in a little bit.So in this model, an algorithm--\nit can compute stuff,but, in particular,\nit makes guesses.So should I do this\nor should I do this?And it just says-- It\ndoesn't flip a coin.It's not random.It just thinks-- it\njust makes a guess.Well, I don't know.Let's go this way.And then it comes\nanother fork in the road.It's like, well, I don't know.I'll go this way.", "start": 1200.0, "heat": 0.1}, {"text": "That's the guessing.You give it a list of\nchoices and somehow a choiceis determined, by magic--\nnondeterministic magic.And then the fun part is--\nI should say, at the endthe algorithm either\nsays yes or no.It gives you an output.The guesses are guaranteed--\nthis is the magic part--to lead to a yes\nanswer, if possible.So if you imagine the space\nof executions of this program,you start here, and you\nmake some guess and youdon't know which way to go.In dynamic programming,\nwe try all of them.But this algorithm\ndoesn't try all of them.It's like a branching universe\nmodel of the universe.So you make some\nchoice, and then youmake some other choice, and\nthen you make some other choice.All of these are guesses.And some of these\nthings will lead to yes.Some of these things\nwill lead to no.And in this magical model,\nif there's any yes out there,you will follow a path to a yes.If all of the answers\nare no, then, of course,it doesn't matter\nwhat choices you make.You will output no.But if there's ever a yes,\nmagically these guessesfind it.This is the sense of lucky.If you're trying to find a\nyes-- that's your goal in life--then this corresponds to luck.And NP is the class of\nall problems solvablein polynomial time by a\nreally lucky algorithm.Crazy.I know.Let's talk about Tetris.Tetris, I claim, is in NP.And we know how to solve\nit in exponential time.", "start": 1320.0, "heat": 0.1}, {"text": "Just try all the options.But, in fact, I don't need\nto try all the options.It would be enough just use\nthis nondeterministic magic.I could say, well, should I\ndrop the piece here, here, here,here, here, or here.And should it be rotated\nlike this, or like this,or like this, or like this?I don't know.So I guess.And I just place that piece.I make another guess where\nto place the next piece.Then I make another guess\nwhere to place the next piece.I implement the rules\nof Tetris, whichis if there's a\nfull line it clears.I figure out where\nthese things fall.I can even think about, should\nI rotate at the last second.If I don't know, I'll guess.Any choice you have to\nmake in playing Tetris,you can just guess.There's only polynomially\nmany guesses you need to make.So it's still polynomial time.That's important.It's not like we\ncan do anything.But we can make a polynomial\nnumber these magic guesses.And then at the end, I\ndetermine did I die--or rather, did I survive.It's important, actually.It only works one way.Did I survive?Yes or no?And that's easy to compute.I just see did I ever\ngo above the top row.So what this model says\nis if there is any wayto survive-- if there is\nany way to get a yes answer,then, my guesses will find\nit, magically, in this model.Therefore, Tetris is in NP.If I had instead\nsaid, did I die, then,what this algorithm would\ntell me is there any wayto die-- which, the\nanswer's probably yes,unless you're given a\nreally trivial input.So it's important you set up\nthe yes versus no, correctly.But the Tetris decision problem\n\"can I survive,\" is in NP.The decision problem \"can I\ndie,\" should not be in NP.But we don't know.Another way to think about NP.", "start": 1440.0, "heat": 0.1}, {"text": "And you might find\nthis intuitivebecause we've been\ndoing lots of guessing.It's just a little crazy.There's another way that's\nmore intuitive to many people.So if this doesn't make\nsense, don't worry, yet.This is another\nway to phrase it.Another way to think\nabout NP-- which turns outto be equivalent-- is that don't\nthink so much about algorithmsfor solving a problem,\njust think about algorithmsfor checking the\nsolution to a problem.It's usually a lot\neasier to check your workthan it is to solve a\nproblem in the first place.And NP is all about that issue.So think of decision\nproblems and thinkabout if you have a solution--\nso let's say in Tetris,the solution is yes.In fact, I need to\nsay this, probably.The more formal\nversion is wheneverthe answer is yes,\nyou can prove it.And you can check that\nproof in polynomial time.This is the more formal--\nthis a little bit high level.What does check mean?Here's what check means.Whenever an answer is \"yes,\"\nyou can write down a proofthat the answer is yes.", "start": 1560.0, "heat": 0.1}, {"text": "And someone can\ncome along and checkthat proof in polynomial\ntime and be convincedthat the answer is yes.What does convinced mean?It's not that hard.Think of it is a\ntwo player game.There's me trying\nto play Tetris,and there's you\ntrying to be convincedthat I'm really good at Tetris.It seems a little one sided,\nbut-- it's a asymmetric game.So you want to prove Tetris is--\nI want to show Tetris is in NP.Imagine I'm this\nmagical creature.Actually, it's kind of funny.It reminds me of a story.On the front of my\noffice door, youmay have seen there's\nan email I received,maybe 15 years\nago-- oh no, I guessit can't be that long ago.Must've been about\n7 years ago whenwe proved that Tetris\nis NP-complete.And the email says, \"Dear\nSir,\"-- or whatever--\"I am NP-complete.\"We don't what\nNP-complete means, yet,but it's a\nmeaningless statement.So it doesn't matter that\nyou don't know what it means.It might get funnier\nthroughout the lecture today.And he's like, I\ncan solve Tetris.I'm really good\nat playing Tetris.I'm really good at\nplaying Minesweeper--all these games that are\nthought to be intractable.He gave me his\nrecords and so on.It's like how can\nI apply my talent.So I will translate what he\nmeant to say was, \"I am lucky.\"And this is probably\nnot true, but hethought that he was lucky.He wanted to convince\nme he was lucky.So how could we do it?Well, I could give him a\nreally hard Tetris problem.And say, can you\nsurvive these pieces?And he says, \"yes,\nI can survive. \"And how does he prove to\nme that he can survive?Well, he just plays it.He shows me what to do.So proof is sequence\nof moves that you make.It's really easy\nto convince someonethat you can survive a\ngiven level of Tetris.", "start": 1680.0, "heat": 0.1}, {"text": "You just show what the\nsequence of moves are.And then I, as a mere mortal\npolynomial time algorithmcan check that that\nsequence works.I just have to implement\nthe rules of Tetris.So in Tetris, the rules\nare easy to implement.Its the knowing what\nthing to do is hard.But in NP, knowing\nwhich way to go is easy.In this version,\nyou don't even talkabout how to find the solution.It's just a matter\nof can you write downa solution that can be checked.Can prove it.This is not in polynomial time.You get arbitrarily\nmuch time to prove it.But then, the check has to\nhappen in polynomial time.Kind of clear?That's Tetris.And every problem that you\ncan solve in polynomialtime you can also,\nof course, check it.Because if you could solve\nit in polynomial time,you could just solve\nit and then seedid you get the same\nanswer that I did.So P is inside NP.But the big question\nis does p equal NP.And most people think no.P does not equal NP--\nmost sane people.So this is a big problem.It's one of the famous\nMillennium Prize problems.So in particular, if you solved\nit, you would get $1 million,and fame, and probably\nother fortune.You could do TV spots.I think that's how people\nmostly make their money.You could do a lot.You would become the most famous\ncomputer scientist in the worldif you prove this.So a lot of people have tried.Every year, there's an\nattempt to prove eitherwhat everyone believes\nor, most often,people try to prove the\nreverse-- that they are equal.I don't know why.They should bet the other way.So what does P does\nnot equal NP mean?It means that there are\nproblems, here, that are in NP", "start": 1800.0, "heat": 0.1}, {"text": "but not in P. Think\nabout what this means.This is saying P are the\nproblems that we can actuallysolve on a legitimate computer.NP are problems that we can\nsolve in this magical fairycomputer where all of\nour dreams are granted.You say, oh, I don't\nknow which way to go.It doesn't matter because\nthe machine magicallytells you which way to go.If you're goal is\nto get to a yes.So NP is a really powerful\nmodel of computation.It's an insane model\nof computation.No one in their right mind\nwould consider it legitimate.So obviously, it's\nmore powerful than P,except we don't know\nhow to prove it.Very annoying.Other phrasings of\nP does not equalNP is-- these are my\nphrasings, I them up-- youcan't engineer luck.You can believe in\nluck, if you want.But it's not something\nthat we can build outof a regular computer.That's the meaning\nof this statement.And so I think most\npeople believe that.Another phrasing would\nbe that solving problemsis harder than\nchecking solutions.A more formal version is that\ngenerating solutions or proofsof solutions can be\nharder than checking them.Another phrasing is\nit's harder to generatea proof of a theorem\nthan it is to checkthe proof of a theorem.We all know checking\nthe proof of a theoremshould be easy if you\nwrite it precisely.Just make sure each step\nfollows from the previous ones.Done.", "start": 1920.0, "heat": 0.1}, {"text": "But proving a\ntheorem, that's hard.You need inspiration.You need some clever idea.That's guessing.Inspiration equals luck equals\nguessing, in this model.And that's hard.The only way we know is\nto try all the proofs.See which of them work.So what the heck?What could we possibly say?This is all kind of weird.This would be the\nend of the lectureif you say, OK,\nwell we don't know.That's it.But thankfully-- I kind\nof need this board.I also want this one, but\nI guess I'll go over here.Fortunately, this is not\nthe end of the story.And we can say a lot\nabout things like Tetris.See I drew Tetris not\njust in this regime.We're pretty sure Tetris\nis between NP and P.That it's in NP minus P.So let me write that down.Tetris is in NP minus P. We\ndon't know that because wedon't know-- this\ncould be the empty set.What we do know\nis that if there'sanything in NP minus P--\nif they are different,then-- if there's\nanything in NP minus P,then Tetris is one\nof those things.That's why I drew\nTetris out there.It is, in a certain sense,\nthe hardest problem in NP.Tetris.Why Tetris?Well, it's not just Tetris.There are a lot of problems\nright at that little notch.But this is pretty interesting\nbecause, while we can't figurethis out, most people\nbelieve this is true.And so as long as you\nbelieve in that-- as long", "start": 2040.0, "heat": 0.1}, {"text": "as you have faith--\nthen you can provethat Tetris is in NP minus P.And so it's hard.It's not in P, in this case.In particular, not in\nP. That's kind of cool.How in the world do we\nprove something like this?It's actually not that hard.I mean it took us\nseveral months,but that's just months, whereas\nthis thing has been aroundsince, I guess, the '70s.P versus NP.Why is this true?Because Tetris is NP-hard.What does NP-hard mean?This means as hard as\nevery problem in NP.I can't say harder than\nbecause it's non-strict.So it's at least as hard\nas every problem in NP.And that's why I drew\nit at the far right.It's sort of the\nhardest extreme of NP.Among everything in NP\nyou can possibly imagine,Tetris is as hard\nas all of them.And therefore, if there's\nanything that's harder than P,then Tetris is going to be\nharder than P because it'sas far to the right as possible.Either P equals NP, in which\ncase the picture is like this.Here's P. Here's NP.Tetris is still at the\nright extreme, here.But it's less interesting\nbecause it's still in P.Or the picture looks like\nthis, and NP is strictlybigger than P. And then, because\nTetris is at the right extreme,it's outside of P. So\nwe prove this in orderto establish this claim.Just to get some\nterminology, whatis this NP-complete business?Tetris is NP-complete,\nwhich means two things.", "start": 2160.0, "heat": 0.1}, {"text": "One is that it's NP-hard.And the other is\nthat it's in NP.So if you think of the\nintersection, NP intersectNP-hard, that's NP-complete.Let me draw on the picture\nhere what this means.So I'm going to\ndraw it on the top.This is NP-hard.Everything from here to\nthe right is NP-hard.NP-hard means it's at least\nas hard as everything in NP.That means it might\nbe at this lineor it might be to the right.But in the case of Tetris,\nwe know that it's in NP.We proved that a\ncouple of times.And so we know that Tetris\nis also in this range.And so if it's in this\nrange and in this range,it's got to be right here.Completeness is nice.If you prove something\nis something complete--prove a problem is some\ncomplexity class complete--then you know sort of exactly\nwhere it falls on this line.NP-complete means right here.EXP-complete means right here.Turns out Chess is EXP-complete.EXP-hard is anything\nfrom here over.EXP is anything from\nhere, over this way.Chess is right at\nthat borderline.It is the hardest\nproblem in EXP.And that's actually\nthe only way weknow to prove that it's not NP.It's is pretty easy to\nshow that EXP is biggerthan P. And Chess is the\nfarthest to the right in EXP--of any problem in EXP-- and\nso, therefore, it's not in P.So whereas this one-- these two,\nwe're not sure are they equal.This line we know is\ndifferent from this one.We don't know about\nthese two, though.Does NP equal EXP?", "start": 2280.0, "heat": 0.1}, {"text": "Not as famous.You won't get a million\ndollars, but still a very big,open question.What else do I wanna say?Tetris, Chess, EXP-hard.So these lines, here--\nthis is NP-completeAnd this is EXP-complete.So the last thing I want to\ntalk about is reductions.Reductions-- so how do you\nprove something like this?What is as hard as even mean?I haven't defined that.But it's not hard to define.In fact, it's a concept\nwe've seen already.Reductions are actually a\nway to design algorithmsthat we've been using\nimplicitly a lot.You may have even\nheard this term.A bunch of recitations have\nused the word reductionfor graph reduction.You have some problem,\nyou convert itinto a graph problem, then you\njust call the graph algorithm.You're done.That's reduction.In general, you have\nsome problem, A,that you want to solve.And you convert it into\nsome other problem, B,that you already\nknow how to solve.It's a great tool\nbecause, in this class,you learn tons of algorithms\nfor solving tons of problems.Now, someone gives you,\nin your job or whatever,or you think about\nsome problem that youdon't know how to solve,\nthe first thing you shoulddo is-- can I convert\nit into something", "start": 2400.0, "heat": 0.1}, {"text": "I know how to solve\nbecause then you're done.Now it may not be the\nbest way to solve it,but at least it's\na way to solve it.Probably in polynomial time\nbecause we think of B as thingsyou can solve in\npolynomial time.Great.So just convert\nproblem A, which youwant to solve, into some problem\nB that you know how to solve.That's reduction.Let me give you some examples\nthat we've already seen,just to fit this into your\nmental map of the class.It's kind of a funny one\nbut it's a very simple one.So how do you solve\nunweighted shortest paths?In general?Easy one.Give you a graph with no\nweights on the edges and Iwant to the shortest\npath from s to t.AUDIENCE: BFSPROFESSOR: BFS.Linear time, right?Well, that's if\nyou're smart or if youfeel like implementing BFS.Suppose someone\ngave you Djikstra.Said, here, look, I've\ngot Djikstra code.You don't have to do anything.There's Djisktra\ncode right there.But Djikstra solves\nweighted shortest path.I don't have any weights.What do I do?Set the weights to 1.It's very easy, but\nthis is a reduction--a simple example of reduction.Not the smartest of reductions,\nbut it's a reduction.So I can convert\nunweighted shortest pathsinto weighted shortest paths\nby adding weights of 1.Done.Adding weights of\n0 would not work.But weights of 1.OK.Weights of 2 also works.Pick your favorite number, but\nas long as you're consistentabout it.That's a reduction.Here's some more\ninteresting ones.On the problems set--\nproblem set six--", "start": 2520.0, "heat": 0.1}, {"text": "there was this RenBook problem,\n\"I Can Haz Moar Frendz?\"That was the name\nof the problem.And the goal was\nto solve-- to findpaths that minimize\nthe product of weights.But what we've\ncovered in class ishow to solve a problem when\nit's the sum of weights.How do you do it?In one word, or less?Logs.Just take logs.That converts\nproducts into sums.Now you start to get the flavor.This is a problem that you could\ntake Djikstra or Bellman-Ford,and change all the\nrelaxation stepsand change it to work\ndirectly with products.That would work,\nbut it's more work.You have to prove that\nthat's still correct.It's annoying to think about.And it's annoying to program.It's not modular,\nblah, blah, blah.Whereas if you just\ndo this reduction,you can use exactly the\ncode that you had before,at the end.So that's nice.This is why\nreductions are reallythe most common algorithm design\ntechnique because you don'twant to implement an algorithm\nfor every single problem youhave.It would be nice if you could\nreuse some of those algorithmsthat you had before.Reductions let you do that.Another one, which was on the\nquiz in the true-false-- quiztwo-- was converting longest\npath into shortest path.We didn't phrase\nit as a reduction.It was just can you\nsolve longest path usingBellman-Ford.And the answer is yes.You just negate all the weights.And that converts a\nlongest path probleminto a shortest path problem.Easy.Also on the quiz-- maybe I don't\nneed to write all of these downbecause they're a little\nbit weird problems.We made them up.There was the-- what was\nthe duck tour called?Bird tours?Bird tours?Aviation tours?Whatever.You want to visit a bunch of\nsites in some specified order.The point in that problem\nis you could reduce itto a single shortest\npaths query.", "start": 2640.0, "heat": 0.1}, {"text": "And so if you already\nhave shortest path code,you don't have to think much.You just do the\ngraph application.Done.Then there's the\nleaky tank problem,which is also a graph\nreduction problem.You could represent all\nthese extra weird thingsthat were happening\nin your car by justchanging the graph a little bit.And it's a very\npowerful technique.In this class, we see it\nmostly in graph reductions.But it could apply\nall over the place.And while this is a powerful\ntechnique for coming upwith new algorithms, it's\nalso a powerful techniquefor proving things\nlike Tetris is NP-hard.So what we proved\nis that a problemcalled 3-Partition can\nbe reduced to Tetris.What's 3-Partition?3-Partition is I\ngive you n numbers.I want to know can I\ndivide them into triples,each of the same sum.So I have n numbers.Divide them into n\nover 3 groups of 3,such that the sum of\neach of the 3s is equal.Sounds like an easy\nenough problem.But it's an NP-complete problem.And people knew that since\none of the first papers.I guess that was late\n'70s, early '80s, by Karp.So Karp already proved\nthis is standingon the shoulders of giants.Karp proved 3-Partition\nis NP-complete,so I don't need to\nthink about that.All I need to\nfocus on is showingthat Tetris is harder\nthan 3-Partition.This is what I mean by harder.Harder means-- so when\nI can reduce A to B,we say the A-- B is at least\nas hard as A. Why's that?", "start": 2760.0, "heat": 0.1}, {"text": "Because I can solve A by solving\nB. I just apply this reductionand then solve B. So if I\nhad some good way to solve B,it would turn into a\ngood way to solve A.Now 3-Partition-- which\nis A, here-- we'repretty sure there's no good\nalgorithm for solving this.Pretty sure it's not in P.\nAnd so Tetris better not be Peither because if\nTetris were in P, thenwe could just take\nour 3-Partition,reduce it to Tetris, and then\n3-Partition would be in P.In fact, all of the\nNP-complete problems,you can reduce to each other.And so to show that something\nis at that little position,NP-complete, all\nyou need to do isfind some known\nNP-complete problemand reduce it to your problem.So reductions are super useful\nfor getting positive resultsfor making new\nalgorithms, but alsofor proving negative results--\nshowing that one problem isharder than another.And if you already\nbelieve this is hard,then you should\nbelieve this is hard.I think that's all I\nreally have time for.I'll give you a couple\nmore NP-complete problems.Kind of fun.Traveling salesman problem,\nyou may have heard of.Let's say you have a graph.And you want to find out\nthe shortest path thatvisits all the vertices,\nnot just one vertex.That's NP-complete.We solved longest common\nsubsequence for two strings,but if I give you\nn strings that youneed to find the longest\ncommon subsequence of,that's NP-complete.Minesweeper, Sudoku, most\npuzzles that are interestingare NP-complete.SAT.SAT is a-- I give you a Boolean\nformula like x or y AND NOTx-- something like that.I want to know is there some\nsetting of the variables thatmakes this thing come out true?Is it possible to\nmake this true?", "start": 2880.0, "heat": 0.1}, {"text": "That's NP-complete complete.This was actually\nthe first problemthat was shown NP-complete.There's this issue, right?If I'm going to show\neverything's NP-completeby reduction, how the\nheck do I get started?What's the first problem?And this is the first problem.You could sort of prove it\nby definition, almost, of NP,here.But I won't do that.Three coloring a graph.Shortest paths.This is fun.Shortest paths in\na graph is hard.But in the real world, we\nlive in a three dimensional,geometric environment.What if I want to\nfind the shortestpath from this point,\nwhere I am, to that point,over on the ceiling\nor something.And I can fly.That's NP-complete.It's kind of weird.Shortest paths in a two\ndimensional environmentis polynomial.It's a good thing that we are\non ground because, then, wecan model things\nby two dimensions.We can model things by graphs.But in 3D, shortest\npaths is NP-complete.So all these things where\na problem-- knapsack,that's another one.We've already covered knapsack.We saw a pseudo-polynomial\nalgorithm.Turns out, you can't do\nbetter than pseudo-polynomialunless P equals NP because\nknapsack is NP-complete.So there you go.Computational complexity\nin 50 minutes.", "start": 3000.0, "heat": 0.1}]